external procedure AutomatedSalesOrderly(string);
remote procedure IVVc_PastevRebate(var record IVVc,Integer);
external function string 255 FindPOSCommandText(Integer);
external procedure WindowFieldGotoForTouchScreen(Integer,Integer,string,Boolean);
external procedure IVDClass_RefreshStringList(Integer,record IVVc);
external procedure RowCalculateTaxMatrix_IVVc(var record IVVc,Integer,row IVVc);
external procedure DisplayIVThankYouAction();
external function roundmode SetRoundModeD(Integer);
external function roundmode DefaultRoundMode();
external procedure SubCashRows_IVVc(record IVVc,Boolean,var val,var val);
external procedure CalcPrice(val,val,val,var val,Integer);
external procedure ReverseString(string,var string);
remote function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure RoundBelCash(string,var val);
external procedure CalcProc(val,val,var val);
external procedure SendArtStat(string,string,string,val,val,val,Date,Integer);
external procedure CalcSum(val,val,val,val,var val,Integer);
external procedure RoundRowSum(string,string,string,var val);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external procedure FindSalesExVat(record TaxMatrixVc,string,val,Integer,Integer,var val);
remote function string 40 IVITDefaultRemote(string,string);
external function Boolean TestForMATVARINS(Integer);
remote updating function LongInt IVCheckIfSaveAllowed(var record IVVc,record IVVc,LongInt,LongInt);
external function Boolean TouchScreenLook();
external procedure ToolKeyPad_Numbers(string);
external function Boolean IVVc_PasteQuantity(var record IVVc,Integer);
external procedure IVVc_PasteItem(record IVVc,Integer,Integer);
remote procedure IVSumup(var record IVVc,Boolean);
external procedure SplitEclass(string,var Array string);
external function Boolean IVDClassInsertRowTest(Integer, Integer);
remote procedure IVVc_PasteInvDate(var record IVVc,record LocalMachineBlock,var Integer,var Integer);
remote function string 255 CurDrawerCode(string);
external procedure B1ToB2Val(val,val,val,var val);
external function Boolean GetItemPriceDiscount3(string,val,var record INVc,string,val,val,val,val,val,string,string,string,string,
                                                var val,var string,var val,var string,var val,var string,Integer,var Boolean,Date,Time,
                                                string,Boolean,var Boolean,string,var string,var val,string,string,var string);// Edit ************************** Tuesday, 15 September 2015 11:59:12
remote procedure RecalcOnePlusOneGift(var record OnePOneRebVc);

global
function Boolean IVDClassInvalidButtonAction(Integer wn,Integer value)
BEGIN
  Boolean res;
  record IVVc IVr;
  Integer normalmode,updatemode;
 
  res = true;
  normalmode = 0;//Rs_normal
  updatemode = 2;//Rs_update
  if (WindowState(wn)==normalmode) then begin
    GetWindowRecord(wn,IVr);
    if (IVr.Invalid!=0) then begin
      res = false;
    end;
  end;  
  if (WindowState(wn)==updatemode) then begin
    GetPrevWindowRecord(wn,IVr);
    if (IVr.Invalid!=0) then begin
      res = false;
    end;
  end;  
  IVDClassInvalidButtonAction = res;
  RETURN;
END;

global
function Boolean IVDClassCreditedRowEFAfter(Integer wn,Integer rownr,Boolean changedf)
begin  
  Integer res;
  record IVVc IVr;
  row IVVc IVrw;
  record IVVc orgIVr;
  Integer credrow;

  if (changedf) then begin  
    GetWindowRecord(wn,IVr);
    if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
      if (IVr.CredInv>0) then begin
        MatRowGet(IVr,rownr,IVrw);
        if (IVrw.CreditedRow>=0) then begin
          orgIVr.SerNr = IVr.CredInv;
          if (ReadFirstMain(orgIVr,1,true)) then begin
            credrow = IVrw.CreditedRow;
            MatRowGet(orgIVr,credrow,IVrw);
            IVrw.CreditedRow = credrow;
            MatRowPut(IVr,rownr,IVrw);
          end;
          PutWindowRecord(wn,IVr);
        end;
      end;
    end;
  end;
  IVDClassCreditedRowEFAfter = true;
  return;
end;

global
procedure IVDClassTileItems()
begin
  WindowDeactivateField(CurWindow);
  ActivateTile(CurWindow,1);
  return;
end;

global
procedure IVDClassTileItemsSet1()
begin
  WindowDeactivateField(CurWindow);
  ActivateTile(CurWindow,1);
  return;
end;

global
procedure IVDClassTileItemsSet2()
begin
  WindowDeactivateField(CurWindow);
  ActivateTile(CurWindow,2);
  return;
end;

global
procedure IVDClassTileItemsSet3()
begin
  WindowDeactivateField(CurWindow);
  ActivateTile(CurWindow,3);
  return;
end;

global
procedure IVDClassTileItemsSet4()
begin
  WindowDeactivateField(CurWindow);
  ActivateTile(CurWindow,4);
  return;
end;

global
procedure IVDClassTileItemsSet5()
begin
  WindowDeactivateField(CurWindow);
  ActivateTile(CurWindow,5);
  return;
end;

global
procedure IVDClassTileItemsSet6()
begin
  WindowDeactivateField(CurWindow);
  ActivateTile(CurWindow,6);
  return;
end;

global
procedure IVDClassTileItemsSet7()
begin
  WindowDeactivateField(CurWindow);
  ActivateTile(CurWindow,7);
  return;
end;

global
procedure IVDClassTileMoreItems()
begin
  WindowDeactivateField(CurWindow);
  ActivateTile(CurWindow,8);
  return;
end;

global
procedure IVDClassTileTerms()
begin
  WindowDeactivateField(CurWindow);
  ActivateTile(CurWindow,9);
  return;
end;

global
procedure IVDClassAddressTile()
begin
  WindowDeactivateField(CurWindow);
  ActivateTile(CurWindow,12);
  return;
end;

global
procedure IVDClassTileCurrency()
begin
  WindowDeactivateField(CurWindow);
  ActivateTile(CurWindow,10);
  return;
end;

global
procedure IVDClassTileCash()
begin
  WindowDeactivateField(CurWindow);
  ActivateTile(CurWindow,11);//?
  return;
end;

global
procedure IVDClassTileButtons()
begin
  WindowDeactivateField(CurWindow);
  ActivateTile(CurWindow,11);
  return;
end;

global
procedure IVDClassToolKeyPadDelete()
BEGIN
  KeyPadSelectAll(CurWindow);
  KeyPadDelete(CurWindow);
  RETURN;
END;  

global
function string 40 IVITDefault(string tstr)
BEGIN
  string 40 lsubset;
  record LocalMachineBlock LMr;
  record DIVc DIr;
      
// What, looping over DIVc in client?
//  lsubset = IVITDefaultRemote(tstr,CurMachineName);
  BlockLoad(LMr);
  if (nonblank(LMr.DefRestDisp)) then begin
    lsubset = LMr.DefRestDisp;
  end else begin
    DIr.Code = "";
    if (LoopMain(DIr,1,true)) then begin
      lsubset = DIr.Code;
    end;
  end;
  IVITDefault = lsubset;
  RETURN;
END;  
 
/*JAJ, remote*/ 
procedure slIVHAL(Integer wn)
BEGIN
  record IVVc IVr;
  record DIVc DIr;
  Boolean found;
  string 255 ckey,t2,tstr;

  ClearStringList(wn);
  found = true;
  ckey = "DICode:" & GetWindowSubset(wn);
  while (LoopKey(ckey,DIr,1,found)) begin
    tstr = DIr.Name & " ";
    tstr = tstr & DIr.colnr;
    SetListString(wn,len(tstr),tstr,false);
  end;
  PutWindowRecord(wn,IVr);
  RETURN;
END;          

global
procedure IVDClassToolUp()
BEGIN
  record IVVc IVr;
  record DIVc DIr;
  Array string 20 ac;
  string 255 lsubset;
  Integer wn;

  wn = CurWindow;
  GetWindowRecord(wn,IVr);
  DIr.Code = GetWindowSubset(wn);
  if (ReadFirstMain(DIr,1,true)) then begin
    SplitEclass(DIr.DispGroups,ac);
    SetWindowSubset(wn,ac[0]);
    if (blank(GetWindowSubset(wn))) then begin
      lsubset = IVITDefault("");
      SetWindowSubset(wn,lsubset);      
    end;
  end;
  slIVHAL(wn);
  UpdateBrowses("INVc");
  PutWindowRecord(wn,IVr);
  RETURN;
END;  

global
procedure IVDClassToolFileDesktop()
BEGIN
  record IVVc IVr;
  Integer wn;
  string 255 lsubset;

  wn = CurWindow;
  GetWindowRecord(wn,IVr);
  lsubset = IVITDefault("");
  SetWindowSubset(wn,lsubset);      
  slIVHAL(wn);
  UpdateBrowses("INVc");
  PutWindowRecord(wn,IVr);
  RETURN;
END;  

procedure IVDClassToolKeyPadAdd()
BEGIN
  Integer wn,rownr;
  record INVc INr;
  record IVVc IVr;
  row IVVc IVrw;
  Boolean testf;
  Integer i,rwcnt;
  
  wn = CurWindow;
  if (WindowActiveField(wn)=="Quant") then begin testf = true; end;
  if (WindowActiveField(wn)=="Price") then begin testf = true; end;
  DeselectWindow(wn,false);
  if (ReadMarkedRecord(wn,INr)) then begin 
  end;
  WindowDeactivateField(wn);
  if (testf) then begin
    rownr = WindowActiveRow(wn);
    if (rownr>=0) then begin
      GetWindowRecord(wn,IVr);  
      MatRowGet(IVr,rownr,IVrw);
      if (nonblank(INr.Code)) then begin
        if (INr.Code!=IVrw.ArtCode) then begin
          testf = false;
        end;
      end;
      if (testf) then begin
        IVrw.Quant = IVrw.Quant + 1;
        MatRowPut(IVr,rownr,IVrw);
        IVVc_PasteQuantity(IVr,rownr);
        PutWindowRecord(wn,IVr);  
        goto LIVToolKeyPadAdd;
      end;
    end;
  end;
  if (nonblank(INr.Code)) then begin
    GetWindowRecord(wn,IVr);  
    rwcnt = MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.ArtCode==INr.Code) then begin
        rownr = i;
        goto L55IVToolKeyPadAdd;
      end;
    end;
    rownr = rwcnt;
L55IVToolKeyPadAdd:;  
    if (rownr==rwcnt) then begin
      ClearRow(IVr,IVrw,1);
      IVrw.ArtCode = INr.Code;
      MatRowPut(IVr,rownr,IVrw);
      PutWindowRecord(wn,IVr);  
      IVVc_PasteItem(IVr,rownr,wn);
    end else begin
      MatRowGet(IVr,rownr,IVrw);
      IVrw.Quant = IVrw.Quant + 1;
      MatRowPut(IVr,rownr,IVrw);
      IVVc_PasteQuantity(IVr,rownr);
      PutWindowRecord(wn,IVr);
    end;
    WindowFieldGotoForTouchScreen(wn,rownr,"Quant",true);
  end;
LIVToolKeyPadAdd:;  
  RETURN;
END;  

global
function Boolean IVDClassRLClick(Integer wn,Integer rownr)
begin
  record IVVc IVr;
  
  if (TouchScreenLook and IVDClassInsertRowTest(wn,0)) then begin // 030830, kyb, ugly fix
    IVDClassToolKeyPadAdd;
  end;
  
  IVDClassRLClick = true;
  return;
end;

global
procedure IVDClassToolKeyPad1()
BEGIN
  ToolKeyPad_Numbers("1");
  RETURN;
END;  

global
procedure IVDClassToolKeyPad2()
BEGIN
  ToolKeyPad_Numbers("2");
  RETURN;
END;  

global
procedure IVDClassToolKeyPad3()
BEGIN
  ToolKeyPad_Numbers("3");
  RETURN;
END;  

global
procedure IVDClassToolKeyPad4()
BEGIN
  ToolKeyPad_Numbers("4");
  RETURN;
END;  

global
procedure IVDClassToolKeyPad5()
BEGIN
  ToolKeyPad_Numbers("5");
  RETURN;
END;  

global
procedure IVDClassToolKeyPad6()
BEGIN
  ToolKeyPad_Numbers("6");
  RETURN;
END;  

global
procedure IVDClassToolKeyPad7()
BEGIN
  ToolKeyPad_Numbers("7");
  RETURN;
END;  

global
procedure IVDClassToolKeyPad8()
BEGIN
  ToolKeyPad_Numbers("8");
  RETURN;
END;  

global
procedure IVDClassToolKeyPad9()
BEGIN
  ToolKeyPad_Numbers("9");
  RETURN;
END;  

global
procedure IVDClassToolKeyPad0()
BEGIN
  ToolKeyPad_Numbers("0");
  RETURN;
END;  

global
procedure IVDClassToolKeyPad00()
BEGIN
  ToolKeyPad_Numbers("00");
  RETURN;
END;  

global
procedure IVDClassToolKeyPadPoint()
BEGIN
  ToolKeyPad_Numbers(DECIMALSEPARATOR); //## international
  RETURN;
END;  

global
procedure IVDClassToolKeyPadEnter()
BEGIN
  KeyPadEnter(CurWindow);
  RETURN;
END;  

global
procedure IVDClassToolKeyPadExact()
BEGIN
  Integer wn;
  record IVVc IVr;
  
  wn = CurWindow;
  KeyPadEnter(wn);
  GetWindowRecord(wn,IVr);
  WindowDeactivatefield(wn);
  IVSumup(IVr,true);  
  PutWindowRecord(wn,IVr);
  RETURN;
END;  

function Boolean IVDClassBeforeivcashcommandEditField(Integer wn)
begin
  Boolean res;

  if (nonblank(GetWindowNameArg(wn))) then begin
    if (TestForMATVARINS(wn)) then begin
    end;
  end;
  if (GetWindowString(wn,"ivcashcommandlastitemsernrf")=="true") then begin
    if (blank(GetWindowString(wn,"ivcashcommand"))) then begin
      PutWindowString(wn,"ivcashcommand",FindPOSCommandText(kPOSCommandsTypeSerialNr));
    end;
  end;
  IVDClassBeforeivcashcommandEditField = res;
  return;
end;

global
function Boolean IVDClassBeforeEditField(Integer wn,string fieldname,Integer fn, Integer rownr)
begin
  Boolean res;
  Integer nwn;
  record IVVc IVr;
  row IVVc IVrw;
  record INVc INr;

  switch (fieldname) begin  
    case "Quant": 
      GetWindowRecord(wn,IVr);      
      MatRowGet(IVr,rownr,IVrw);
      if (IVrw.Quant==0) then begin
        if (TestForMATVARINS(wn)) then begin end;
      end;
    case "ArtCode": ;
    case "CustCode": 
      if (TouchScreenLook and GuiType!=kGuiiPhone and GuiType!=kGuiAndroid) then begin      
        GetWindowRecord(wn,IVr);      
        if (WindowState(wn)!=0) then begin
          nwn = OpenPasteWindow(wn,GetWindowPasteName(wn,fieldname),IVr.CustCode);
        end;
      end;
    case "SerialNr": 
      if (TouchScreenLook) then begin      
        if (WindowState(wn)!=0) then begin
          if (rownr>=0) then begin
            GetWindowRecord(wn,IVr);      
            MatRowGet(IVr,rownr,IVrw);
            if (ReadFirstItem(IVrw.ArtCode,INr,true,false)) then begin
              if (INr.SerNrf>0) then begin
                nwn = OpenPasteWindow(wn,GetWindowPasteName(wn,fieldname),"");
              end;
            end;
          end;
        end;
      end;
    case "ivcashcommand": 
      if (TouchScreenLook and GuiType!=kGuiiPhone and GuiType!=kGuiAndroid) then begin      
        res = IVDClassBeforeivcashcommandEditField(wn);
      end;
    otherwise
//      if (WindowActiveButton(wn)==0) then begin
/*
        if (TouchScreenLook and GuiType!=kGuiiPhone) then begin      
          if (WindowState(wn)!=0) then begin
            nwn = OpenPasteWindow(wn,GetWindowPasteName(wn,fieldname),IVr.CustCode);
          end;
        end;
*/
//      end;
  end;
  IVDClassBeforeEditField = res;
  RETURN;
END;

global
procedure IVDClassOpenCalendar()
BEGIN
  Integer nwn;
  record RcVc RepSpec;
  Date td;
  
  RepSpec.f1 = CurrentUser;
  td = CurrentDate;
  td.day = 1;
  RepSpec.sStartDate = td;
  td.day = DaysInMonth(td.year,td.month);
  RepSpec.sEndDate = td;
  nwn = OpenWindow("MonthWClass",0,0,"","",RepSpec);
  RETURN;
END;

global
procedure IVDClassNewActivity()
BEGIN
  record ActVc Actr;
  row ActVc Actrw;
  record IVVc IVr;
  row IVVc IVrw;
  Integer wn,nwn;
  Integer i,rwcnt;
    
  wn = CurWindow;
  if (WindowState(wn)!=0) then begin goto LIVDClassNewActivity; end;
  GetWindowRecord(wn,IVr);
  RecordNew(Actr);
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    Actrw.Text = IVrw.ArtCode;
    MatRowPut(Actr,MatRowCnt(Actr),Actrw);
  end;
  nwn = OpenWindow("ActDClass",0,0,"","",Actr);
LIVDClassNewActivity:;  
  RETURN;
END;

global
procedure IVDClassToolIVReturn()
BEGIN
  record IVVc IVr;
  record IVVc newIVr;
  row IVVc cashIVrw;
  row IVVc newIVrw;
  row IVVc IVrw;
  Integer i,rwcnt;
  Integer wn,nwn;
  Boolean foundcashf;
  val credcardv;
  val t,t2;
  integer err1,err2;
  record TaxMatrixVc TMr;
  record LocalMachineBlock LMb;

  wn = CurWindow;
  DeselectWindow(wn,true);
  GetWindowRecord(wn,IVr);
  
  SubCashRows_IVVc(IVr,true,t,t2);
/*
why not to return smthing on account ? 
  if (IVr.InvType!=kInvoiceTypeCash) and (t!=0) then begin 
    goto LIVDClassToolIVReturn; 
  end;
*/  
  if (IVr.OrderNr>0) then begin
    goto LIVDClassToolIVReturn; 
  end;
  if (IVr.OKFlag==0) then begin
    BlockLoad(LMb);
    if (HasLocalization("POL")) then begin
      IVr.FiscalFlag = 0;
    end;
    rwcnt = MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.stp==kInvoiceRowTypeNormal) or (IVrw.stp==kInvoiceRowTypeStructuredItemComponent) then begin
        IVrw.Quant = -IVrw.Quant;
        IVrw.Sum = -IVrw.Sum;
        IVrw.rowGP = -IVrw.rowGP;
        RowCalculateTaxMatrix_IVVc(IVr,i,IVrw);
        MatRowPut(IVr,i,IVrw);
      end;
      if ((IVrw.stp==kInvoiceRowTypeGiftVoucherSold) or (IVrw.stp==kInvoiceRowTypeGiftVoucherPayment)) then begin
        MatRowDelete(IVr,i);
        rwcnt = MatRowCnt(IVr);
      end;
      if (IVrw.stp==kInvoiceRowTypeCreditCardPayment) then begin
        credcardv = credcardv + IVrw.Sum;
        IVrw.Sum = -IVrw.Sum;
        MatRowPut(IVr,i,IVrw);
      end;

      if (foundcashf==false) then begin
        if ((IVrw.stp==kInvoiceRowTypeCashPayment) or (IVrw.stp==kInvoiceRowTypeLoyaltyPointsPayment)) then begin
          CopyRow(IVr,IVrw,cashIVrw);
          cashIVrw.Sum = -t;
          MatRowDelete(IVr,i);
          rwcnt = MatRowCnt(IVr);
          i = i -1;
          foundcashf = true;
        end;
      end;
    end;
//    if (foundcashf) or (credcardv!=0) then begin //what if new window with just item created ? 
    if (true) then begin
      if (foundcashf) then begin
        cashIVrw.Sum = cashIVrw.Sum + credcardv;
        MatRowPut(IVr,MatRowCnt(IVr),cashIVrw);
      end;
      IVSumup(IVr,true);
      PutWindowRecord(wn,IVr);
      IVDClass_RefreshStringList(wn,IVr);
      WindowFieldGotoForTouchScreen(wn,-1,"ivcashcommand",true);
    end else begin
      MessageBox(2074,"");
    end;
  end else begin
    RecordNew(newIVr);
    RecordCopy(newIVr,IVr);
    if (HasLocalization("POL")) then begin
      newIVr.FiscalFlag = 0;
    end;
    newIVr.OKFlag = 0;
    newIVr.SerNr = -1;
    newIVr.InvDate = CurrentDate;
    newIVr.MachineName = CurMachineName;
    newIVr.DrawerCode = CurDrawerCode(newIVr.MachineName);
//    newIVr.InvType = kInvoiceTypeCredit;
    IVVc_PasteInvDate(newIVr,LMb,err1,err2);
    
    rwcnt = MatRowCnt(newIVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowDelete(newIVr,i);
      rwcnt = MatRowCnt(newIVr);
      i = i - 1;
    end;
    rwcnt = MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,newIVrw);
      if (newIVrw.stp==kInvoiceRowTypeNormal) or (newIVrw.stp==kInvoiceRowTypeStructuredItemComponent) then begin
        newIVrw.Quant = -newIVrw.Quant;
        newIVrw.Sum = -newIVrw.Sum;
        newIVrw.rowGP = -newIVrw.rowGP;
        RowCalculateTaxMatrix_IVVc(newIVr,i,newIVrw);
        MatRowPut(newIVr,MatRowCnt(newIVr),newIVrw);
      end;
/*
      if (newIVrw.stp==kInvoiceRowTypeCreditCardPayment) then begin
        credcardv = credcardv + newIVrw.Sum;
        newIVrw.Sum = -newIVrw.Sum;
        MatRowPut(newIVr,MatRowCnt(newIVr),newIVrw);
      end;
      if (foundcashf==false) then begin
        if (newIVrw.stp==kInvoiceRowTypeCashPayment) then begin
          CopyRow(newIVr,newIVrw,cashIVrw);
          cashIVrw.Sum = -t;
          foundcashf = true;
        end;
      end;
*/
    end;
/*
    if (foundcashf) then begin
      cashIVrw.Sum = cashIVrw.Sum + credcardv;
      MatRowPut(newIVr,MatRowCnt(newIVr),cashIVrw);
    end;
*/
    
    if (MatRowCnt(newIVr)>0) then begin
      if (IVr.SerNr!=newIVr.SerNr) then begin
        ClearRow(newIVr,newIVrw,kInvoiceRowTypeCredit);    
        newIVrw.OrdRow = IVr.SerNr;
        MatRowPut(newIVr,MatRowCnt(newIVr),newIVrw);
      end;
    end;
    
    IVSumup(newIVr,true);
    CloseWindow(wn);
    if (SingleUserMode) then begin 
      newIVr.SerNr = NextSerNr("IVVc",newIVr.TransDate,"",true,newIVr.LangCode);
    end;
    nwn = OpenWindow("IVDClass",1,0,"","",newIVr);
    IVDClass_RefreshStringList(nwn,newIVr);
    WindowFieldGotoForTouchScreen(nwn,-1,"ivcashcommand",true);
  end;
LIVDClassToolIVReturn:;  
  RETURN;
END;

global
procedure IVDClassIVLCLASS()
BEGIN
  Integer nwn;
  record IVVc IVr;
  
  nwn = OpenWindow("IVLClass",0,0,"","",IVr);
  RETURN;
END;

// Edit ************************** Wednesday, 16 August 2017 17:55:46
global
procedure IVDchsum(var record IVVc IVp,Integer rownr)
BEGIN
  row IVVc IVrw;
  row IVVc IV2rw;
  val t,s,rowsum,tproc,unitprdisc;
  val qty,sum;
  string 255 location;
  record TaxMatrixVc TMr;
  val gp;
  Integer i,rwcnt;

  if (rownr>=0) then begin
    MatRowGet(IVp,rownr,IVrw);
  end;
  location = IVrw.Location;
  if (blank(location)) then begin
    location = IVp.Location;
  end;
  qty = IVrw.Quant;
  if ((IVrw.stp==kInvoiceRowTypeNormal) or (IVrw.stp==kInvoiceRowTypeStructuredItemComponent) or (IVrw.stp==kInvoiceRowTypeInterest) or (IVrw.stp==kInvoiceRowTypeCorrection) or (IVrw.stp==kInvoiceRowTypeMultiBuyDiscount)) then begin
    if (nonblank(IVrw.ArtCode)) then begin
      t = qty * IVrw.BasePrice;
      if (IVrw.PriceFactor!=0) then begin
        t = t/IVrw.PriceFactor;
      end;
      sum = IVrw.Sum;
      s = MulRateToBase1(IVp.CurncyCode,sum,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
      //UnpackRowFieldMatrix(IVrw,"TaxMatrix",TMr);
      FindSalesExVat(TMr,IVrw.VATCode,s,IVp.InclVAT,IVp.NoTAXonVAT,rowsum);      
      IVrw.rowGP = rowsum - t;
    end else begin
      IVrw.rowGP = 0;
      IVrw.BasePrice = 0;
    end;
    if (rownr>=0) then begin
      MatRowPut(IVp,rownr,IVrw);
    end;
  end;
  if (rownr>=0) then begin
    MatRowGet(IVp,rownr,IVrw);
  end;
  unitprdisc = Round(IVrw.Sum / IVrw.Quant,DefaultRoundMode);
  if (rownr>=0) then begin
    MatRowPut(IVp,rownr,IVrw);
  end;
  gp = IVrw.rowGP;
  rwcnt = MatRowCnt(IVp);  
  for (i=rownr+1;i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IV2rw);
    switch (IV2rw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        if (IV2rw.MotherArtCode==IVrw.ArtCode) then begin
          gp = gp + IV2rw.rowGP;
        end;
      otherwise
        i = rwcnt;
    end;
  end;    
  CalcProc(rowsum,gp,tproc);  
  SendArtStat(IVrw.ArtCode,location,IVrw.Recepy,gp,tproc,unitprdisc,IVp.TransDate,0);
  RETURN;
END;

global
function Boolean IVDchrsum(var record IVVc IVp,Integer rownr)
BEGIN
  row IVVc IVrw;
  val s,p,q,frv;
  Boolean res,frvchangedf,sumchangedf;
  record GeneralOptionBlock GOb;
  record BelRusCashBlock BelRusCashr;
	
	val t,price,vreb,baseprice,temp,tax2prc;// Edit ************************** Tuesday, 15 September 2015 12:12:57
  string 255 curitemname,salesacc,vatcode,tax2code,location,taxtemplatecode;// Edit ************************** Tuesday, 15 September 2015 12:12:58
  Boolean dummyf;// Edit ************************** Tuesday, 15 September 2015 12:12:59
	integer i,mtrw;
	boolean first,calcprice1;// Edit ************************** Tuesday, 15 September 2015 12:13:39
	record INVc INr;
	date fromDate,toDate;
	
	fromDate = StringToDate("15/09/2015");
	toDate = StringToDate("30/09/2015");
	
	if (CurrentDate>=fromDate and CurrentDate<=toDate) then begin
  first = true;
  if(currentcompany==14) then begin // Edit ************************** Tuesday, 15 September 2015 11:39:44
		if(nonblank(IVp.RebCode) and (IVp.RebCode<"20%")) then begin
		
			mtrw = matrowcnt(IVp);
			For(i=0;i<mtrw;i=i+1) begin
				matrowget(IVp,i,IVrw);
				if(IVrw.stp==kInvoiceRowTypeNormal and nonblank(IVrw.ArtCode))then begin
					if(first) then begin
						price = IVrw.Price;
						location = IVrw.Location;
						if (blank(location)) then begin
							location = IVp.Location;
						end;
						if (GetItemPriceDiscount3(IVrw.ArtCode,IVrw.Quant,INr,IVp.CurncyCode,
																IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,
																IVp.LangCode,IVp.CustCat,IVp.PriceList,IVp.RebCode,
																price,curitemname,vreb,vatcode,baseprice,salesacc,
																IVp.ExportFlag,calcprice1,IVp.TransDate,IVp.TransTime,IVp.CustCode,true,dummyf,IVp.PayDeal,tax2code,tax2prc,IVp.Region,location,taxtemplatecode)) then begin

							IVrw.vRebate = vreb;
							MatRowPut(IVp,i,IVrw);
						end;
						first = false;
					end else begin
							IVrw.vRebate = 20;					
					end;
					MatRowPut(IVp,i,IVrw);					
				end;
			end; 
		end;
	end;
	end;
  
  BlockLoad(GOb);
  MatRowGet(IVp,rownr,IVrw);
  if ((IVrw.stp==kInvoiceRowTypeNormal) or (IVrw.stp==kInvoiceRowTypeStructuredItemComponent) or (IVrw.stp==kInvoiceRowTypeInterest) or (IVrw.stp==kInvoiceRowTypeCorrection)) then begin
    p = IVrw.Price; 
    CalcPrice(IVrw.BasePrice,IVrw.PriceFactor,IVrw.vRebate,p,GOb.UseDiscount);
    IVrw.Price = p;  
    q = IVrw.Quant;
    if (IsStandardProduct) then begin
      if (blank(q)) then begin q = 1; end;
    end;
    CalcSum(q,IVrw.Price,IVrw.PriceFactor,IVrw.vRebate,s,GOb.UseDiscount);  
    if (HasLocalization("BLR")) then begin
      BlockLoad(BelRusCashr);
      if (SetInSet(IVp.PayDeal,BelRusCashr.CashPayTerm)) then begin
        RoundBelCash(IVp.CurncyCode,s);
      end else begin
        RoundRowSum(IVp.CurncyCode,IVp.PayDeal,"IVVc",s);
      end;
    end else begin
      RoundRowSum(IVp.CurncyCode,IVp.PayDeal,"IVVc",s);
    end;
    if (s!=IVrw.Sum) or ((s==0.00) and (blank(IVrw.Sum))) then begin
      sumchangedf = true;
    end;
    if (IVp.OrderNr>0) then begin
      if (IVrw.OrdRow>=0) then begin
        frv = IVrw.Quant*IVrw.FIFO;
        if (frv!=IVrw.FIFORowVal) then begin
          frvchangedf = true;
        end;
      end;
    end;
    if (sumchangedf) then begin
      IVrw.Sum = s;
      res = true;        
      RowCalculateTaxMatrix_IVVc(IVp,rownr,IVrw);
    end;
    if (frvchangedf) then begin
      IVrw.FIFORowVal = frv;
    end;
    if (frvchangedf or sumchangedf) then begin
      MatRowPut(IVp,rownr,IVrw);
    end;
  end;
  if (IVrw.Price==0) then begin res = true; end;
  IVDchrsum = res;
  RETURN;
END;

global
function Boolean IVDClassActiveFieldOnNew(Integer wn)
begin
  Boolean res;
  record CashierDefBlock CDb;
  record IVVc IVr;

  if (CompileType==ctiPhone or CompileType==ctiPad or CompileType==ctAndroidPhone or CompileType==ctAndroidTab) then begin
    res = true;
    goto LIVDClassActiveFieldOnNew;
  end;
  
  GetWindowRecord(wn,IVr);
  BlockLoad(CDb);
  switch (CDb.DefInvoiceField) begin
    case 0:
      if (TouchScreenLook) then begin    
        WindowFieldGotoForTouchScreen(wn,-1,"ivcashcommand",true);
        res = true;
      end;
    case 1:
      WindowFieldGoto(wn,IVr,0,"ArtCode",true);
      res = true;
    case 2:
      WindowFieldGoto(wn,IVr,0,"SerialNr",true);
      res = true;
  end;
  
LIVDClassActiveFieldOnNew:;
  IVDClassActiveFieldOnNew = res;
  return;
end;// Edit ************************** Wednesday, 16 August 2017 17:55:38

global
function Boolean IVDClassBasePriceEFAfter(Integer wn,Integer fn,Integer rownr,Integer changed)
begin  
  record IVVc IVr;
  row IVVc IVrw;
  val t;

  if (changed!=0) and (rownr>=0) then begin  
    GetWindowRecord(wn,IVr);
    DeselectWindow(wn,false);
    MatRowGet(IVr,rownr,IVrw);
    B1ToB2Val(IVrw.BasePrice,IVr.BaseRate1,IVr.BaseRate2,t);
    IVrw.BasePriceB2 = t;
    MatRowPut(IVr,rownr,IVrw);
    switch (IVrw.stp) begin
      case 4: 
        if (IVDchrsum(IVr,rownr)) then begin
        end;
        IVDchsum(IVr,rownr);
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal1;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal1:;
        if (IVDchrsum(IVr,rownr)) then begin
        end;
        IVDchsum(IVr,rownr);
      case 11: 
        if (IVDchrsum(IVr,rownr)) then begin
        end;
        IVDchsum(IVr,rownr);
    end;
    IVSumup(IVr,true);
    PutWindowRecord(wn,IVr);
  end;  
  IVDClassBasePriceEFAfter = true;
  return;
end;

global
function Boolean IVDClassvRebateEFAfter(Integer wn,Integer fn,Integer rownr,Integer changed)
begin  
  record IVVc IVr;

  if (changed!=0) and (rownr>=0) then begin  
    GetWindowRecord(wn,IVr);
    IVVc_PastevRebate(IVr,rownr);
    PutWindowRecord(wn,IVr);
    AutomatedSalesOrderly("HasPriceLists+Edit_IVVc");
  end;  
  IVDClassvRebateEFAfter = true;
  return;
end;

global //Edit***************************Sasha2,10:12 21.06.2016 {
function Boolean PasteRetItemDClassOnClose(Integer wn,Integer wn2)
begin
  DeselectWindow(wn,false);
  WindowDoCancel(wn);
  PasteRetItemDClassOnClose = false;
  return;
end; //Edit***************************Sasha2,10:12 21.06.2016 }

global  //Edit***************************Sasha2,10:12 21.06.2016 {
procedure PasteRetItemDClassButtonFlags(Integer wn,var Boolean duplOK,var Boolean newOK,var Boolean saveOK,var Boolean restOK)
begin
  duplOK = false;
  newOK = false;
  saveOK = false;
  return;
end; //Edit***************************Sasha2,10:12 21.06.2016 }

//Edit***************************Sasha2,11:39 09.09.2016 {
function boolean DelAddrCodeAfterEdit(Integer wn,Integer changed)
begin
record SHVc SHr;
record INVc INr;
string 200 adr;
Boolean testf;
  
  if(changed==1)then begin
    getwindowrecord(wn,SHr);
    if (nonblank(SHr.DelAddrCode)) then begin
      INr.Code = SHr.DelAddrCode;
      testf = Readfirstmain(INr,1,true);
      if (testf==false) then begin
        INr.AlternativeCode = SHr.DelAddrCode;
        testf = ReadFirstKey("AlternativeCode",INr,1,true);
        if (testf) then begin
          SHr.DelAddrCode = INr.Code;
        end;
      end;
      if (testf==false) then begin
        INr.BarCode = SHr.DelAddrCode;
        testf = ReadFirstKey("BarCode",INr,1,true);
        if (testf) then begin
          SHr.DelAddrCode = INr.Code;
        end;
      end;
      if (testf) then begin
        putwindowrecord(wn,SHr);   
      end;
    end;
	end;
  
DelAddrCodeAfterEdit = true;
return;
end; //Edit***************************Sasha2,11:39 09.09.2016 }

function boolean OPOItemPairAfterEdit(Integer wn,Integer changed)
begin
record OnePOneRebVc OPORebr;
record INVc INr;
string 200 adr;
Boolean testf;
  
  if(changed==1)then begin
    getwindowrecord(wn,OPORebr);
		RecalcOnePlusOneGift(OPORebr);
		putwindowrecord(wn,OPORebr);   
	end;
  
OPOItemPairAfterEdit = true;
return;
end; //Edit***************************Sasha2,11:39 09.09.2016 }



global 
function Boolean PstOPOrbItIVDClassOnOverStrike(Integer wn,Integer rownr)
begin
	record OnePOneRebVc OPORebr;
	
	GetWindowRecord(wn,OPORebr);
	RecalcOnePlusOneGift(OPORebr);
	PutWindowRecord(wn,OPORebr);    
  PstOPOrbItIVDClassOnOverStrike = true;
  return;
end;



global //Edit***************************Sasha2,11:38 09.09.2016 {
function Boolean PasteRetItemDClassAfterEditField(Integer wn,string fieldname,Integer fn, Integer rownr,Integer changed)
BEGIN
  Boolean res;
  
  switch (fieldname) begin
    case "DelAddrCode": res = DelAddrCodeAfterEdit(wn,changed);
        
  end;
  PasteRetItemDClassAfterEditField = res;
  RETURN;
END; //Edit***************************Sasha2,11:38 09.09.2016 }




global  // _-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_- Anton Preisinger15:06 10.04.2019
function Boolean PstOPOrbItIVDClassAfterEditField(Integer wn,string fieldname,Integer fn, Integer rownr,Integer changed)
BEGIN
  Boolean res;
  switch (fieldname) begin
    case "FirstItmCode": res = OPOItemPairAfterEdit(wn,changed);
		case "SecondItmCode": res = OPOItemPairAfterEdit(wn,changed);
  end;
  PstOPOrbItIVDClassAfterEditField = res;
  RETURN;
END;

global  // _-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_- Anton Preisinger11:01 11.04.2019
function Boolean PstOPOrbItIVDClassActiveEditField(Integer wn,string fieldname,Integer fn,Integer wnst,Integer rownr,Integer changed)
begin
  Boolean res;
  
  res = true;
	switch (fieldname) begin
		case "OPORebTableSerNr": res = false;
		case "PairsumPrice": res = false;
	end;
  PstOPOrbItIVDClassActiveEditField = res;
  return;
end;


global  // _-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_- Anton Preisinger17:21 09.04.2019
function Boolean PstOPOrbItIVDClassOnClose(Integer wn,Integer wn2)
begin
  DeselectWindow(wn,false);
  WindowDoCancel(wn);
  PstOPOrbItIVDClassOnClose = false;
  return;
end; 

global   // _-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_- Anton Preisinger17:21 09.04.2019
procedure PstOPOrbItIVDClassButtonFlags(Integer wn,var Boolean duplOK,var Boolean newOK,var Boolean saveOK,var Boolean restOK)
begin
  duplOK = false;
  newOK = false;
  saveOK = false;
  return;
end; 







//-------------------------------------------------------------------------------------added by dima-f 16.11.17
global
procedure IVWebDClassButtonFlags(Integer wn,var Boolean duplOK,var Boolean newOK,var Boolean saveOK,var Boolean restOK)
begin
  saveOK = false;
  return;
end;
//-------------------------------------------------------------------------------------added by dima-f 16.11.17
global
procedure IVWebLsm()
BEGIN
  Integer nwn,wn;
  record IVVc IVr;

  wn = CurWindow;
  RecordNew(IVr);
  nwn = OpenWindow("IVWebDClass",1,wn,"","",IVr);

  RETURN;
END;








global 
procedure NewINBPICategorySClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
		rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="CATEGORY")then begin
				astr[acnt] = NCSrw.CCodeName;
				acnt = acnt + 1;
			end;
		end;
	end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,2,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="CATEGORY")then begin
						astr[acnt] = NCSrw.CCodeName;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;




global 
procedure StockECSClassArrayOnOpen(var Array string astr,var Integer acnt,string GlobalItemArtCode)
BEGIN
  record BPICategoryVc Categr;
	
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record GlobalItemVc GIr;
	row GlobalItemVc GIrw;
	record CompaniesBlock CPb;
	row CompaniesBlock CPrw;
	record WEBReservStock WRSb;
	string 255 vResStockSet;
	integer OldComp;
	
	OldComp = currentcompany;
	
	blockload(CPb);
	rwcnt = matrowcnt(CPb);
	for(i=0;i<rwcnt;i=i+1) begin
		matrowget(CPb,i,CPrw);
		if(CPrw.ActiveStatus==0)then begin
			if(SetCompany((i+1),false))then begin
				blockload(WRSb);
				vResStockSet = vResStockSet  & "," & WRSb.ResStockSet;
			end;
		end;
	end;
	
	resetcompany(OldComp);
	
	GIr.Code = GlobalItemArtCode;
	if(ReadfirstMain(GIr,1,true))then begin
		rwcnt = matrowcnt(GIr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(GIr,i,GIrw);
			if(GIrw.Instock>0 and setinset(GIrw.Location,vResStockSet))then begin
				astr[acnt] = GIrw.Location & "             " & GIrw.Instock;
				acnt = acnt + 1;
			end;
		end;
	end;
 
  RETURN;
END;






global 
procedure CompanySClassArrayOnOpen(var Array string astr,var Integer acnt)
BEGIN
  record BPICategoryVc Categr;
	
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record CompaniesBlock CPb;
	row CompaniesBlock CPrw;
	
	blockload(CPb);
	rwcnt = matrowcnt(CPb);
	for(i=0;i<rwcnt;i=i+1) begin
		matrowget(CPb,i,CPrw);
		if(CPrw.ActiveStatus==0)then begin
			astr[acnt] = CPrw.CompCode & "             " & CPrw.CompName;
			acnt = acnt + 1;
		end;
	end;
 
  RETURN;
END;






global 
procedure Company2SClassArrayOnOpen(var Array string astr,var Integer acnt)
BEGIN
  record BPICategoryVc Categr;
	
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record CompaniesBlock CPb;
	row CompaniesBlock CPrw;
	
	blockload(CPb);
	rwcnt = matrowcnt(CPb);
	for(i=0;i<rwcnt;i=i+1) begin
		matrowget(CPb,i,CPrw);
		if(CPrw.ActiveStatus==0)then begin
			astr[acnt] = CPrw.ShortName & "             " & CPrw.CompName;
			acnt = acnt + 1;
		end;
	end;
 
  RETURN;
END;




global 
procedure NewINBPIMaterialSClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	record BPIMaterialVc BPIMaterialr;
	
	while (loopmain(BPIMaterialr,1,true)) begin
		astr[acnt] = BPIMaterialr.Name;
		acnt = acnt + 1;
	end;
	
	/*NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
		rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="MATERIAL")then begin
				BPIMaterialr.Code = NCSrw.CCode;
				readfirstmain(BPIMaterialr,1,true);
				astr[acnt] = BPIMaterialr.Name;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="MATERIAL")then begin
						BPIMaterialr.Code = NCSrw.CCode;
						readfirstmain(BPIMaterialr,1,true);
						astr[acnt] = BPIMaterialr.Name;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;*/	
  RETURN;
END;



global 
procedure NewBPIColorSClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	record BPIColorVc BPIColorr;
	
	while (loopmain(BPIColorr,1,true)) begin
		astr[acnt] = BPIColorr.Name;
		acnt = acnt + 1;
	end;
	
	/*NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="COLOR")then begin
				BPIColorr.Code = NCSrw.CCode;
				readfirstmain(BPIColorr,1,true);
				astr[acnt] = BPIColorr.Name;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="COLOR")then begin
						BPIColorr.Code = NCSrw.CCode;
						readfirstmain(BPIColorr,1,true);
						astr[acnt] = BPIColorr.Name;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;*/
  RETURN;
END;




global 
procedure NewINBPIShapeSClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	record BPIShapeVc BPIShaper;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="SHAPE")then begin
				BPIShaper.Code = NCSrw.CCode;
				readfirstmain(BPIShaper,1,true);
				astr[acnt] = BPIShaper.Name;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="SHAPE")then begin
						BPIShaper.Code = NCSrw.CCode;
						readfirstmain(BPIShaper,1,true);
						astr[acnt] = BPIShaper.Name;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;



global 
procedure NewINBPISizeSClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	record BPISizeVc BPISizer;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="SIZE")then begin
				BPISizer.Code = NCSrw.CCode;
				readfirstmain(BPISizer,1,true);
				astr[acnt] = BPISizer.Name;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="SIZE")then begin
						BPISizer.Code = NCSrw.CCode;
						readfirstmain(BPISizer,1,true);
						astr[acnt] = BPISizer.Name;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;




global 
procedure NewINBPIUseSClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	record BPIUseVc BPIUser;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="USE")then begin
				BPIUser.Code = NCSrw.CCode;
				readfirstmain(BPIUser,1,true);
				astr[acnt] = BPIUser.Name;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="USE")then begin
						BPIUser.Code = NCSrw.CCode;
						readfirstmain(BPIUser,1,true);
						astr[acnt] = BPIUser.Name;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;




global 
procedure NewINBPISexSClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	record BPISexVc BPISexr;
	
	while (loopmain(BPISexr,1,true)) begin
		astr[acnt] = BPISexr.Name;
		acnt = acnt + 1;
	end;
	
	/*NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="SEX")then begin
				BPISexr.Code = NCSrw.CCode;
				readfirstmain(BPISexr,1,true);
				astr[acnt] = BPISexr.Name;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="SEX")then begin
						BPISexr.Code = NCSrw.CCode;
						readfirstmain(BPISexr,1,true);
						astr[acnt] = BPISexr.Name;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;*/	
  RETURN;
END;





global 
procedure NewINBPIPlatingSClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	record BPIPlatingVc BPIPlatingr;
	
	
	while (loopmain(BPIPlatingr,1,true)) begin
		astr[acnt] = BPIPlatingr.Name;
		acnt = acnt + 1;
	end;
	
	/*NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="PLATING")then begin
				BPIPlatingr.Code = NCSrw.CCode;
				readfirstmain(BPIPlatingr,1,true);
				astr[acnt] = BPIPlatingr.Name;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="PLATING")then begin
						BPIPlatingr.Code = NCSrw.CCode;
						readfirstmain(BPIPlatingr,1,true);
						astr[acnt] = BPIPlatingr.Name;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;*/	
  RETURN;
END;




global 
procedure NewINBPIClaritySClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	record BPIClarityVc BPIClarityr;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="CLARITY")then begin
				BPIClarityr.Code = NCSrw.CCode;
				readfirstmain(BPIClarityr,1,true);
				astr[acnt] = BPIClarityr.Name;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="CLARITY")then begin
						BPIClarityr.Code = NCSrw.CCode;
						readfirstmain(BPIClarityr,1,true);
						astr[acnt] = BPIClarityr.Name;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;





global 
procedure NewINBPIWeightSClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	record BPIWeightVc BPIWeightr;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="WEIGHT")then begin
				BPIWeightr.Code = NCSrw.CCode;
				readfirstmain(BPIWeightr,1,true);
				astr[acnt] = BPIWeightr.Name;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="WEIGHT")then begin
						BPIWeightr.Code = NCSrw.CCode;
						readfirstmain(BPIWeightr,1,true);
						astr[acnt] = BPIWeightr.Name;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;




global 
procedure NewINBPICutSClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	record BPICutVc BPICutr;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="CUT")then begin
				BPICutr.Code = NCSrw.CCode;
				readfirstmain(BPICutr,1,true);
				astr[acnt] = BPICutr.Name;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="CUT")then begin
						BPICutr.Code = NCSrw.CCode;
						readfirstmain(BPICutr,1,true);
						astr[acnt] = BPICutr.Name;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;




global 
procedure NewINBPIStoneSClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	record BPIStoneVc BPIStoner;
	
	while (loopmain(BPIStoner,1,true)) begin
		astr[acnt] = BPIStoner.Name;
		acnt = acnt + 1;
	end;
	
	/*NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="STONE")then begin
				BPIStoner.Code = NCSrw.CCode;
				readfirstmain(BPIStoner,1,true);
				astr[acnt] = BPIStoner.Name;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="STONE")then begin
						BPIStoner.Code = NCSrw.CCode;
						readfirstmain(BPIStoner,1,true);
						astr[acnt] = BPIStoner.Name;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;*/	
  RETURN;
END;



global 
procedure NewINBPIStrapSClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	record BPIStrapVc BPIStrapr;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="STRAP")then begin
				BPIStrapr.Code = NCSrw.CCode;
				readfirstmain(BPIStrapr,1,true);
				astr[acnt] = BPIStrapr.Name;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="STRAP")then begin
						BPIStrapr.Code = NCSrw.CCode;
						readfirstmain(BPIStrapr,1,true);
						astr[acnt] = BPIStrapr.Name;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;




global 
procedure NewINBPIOdourSClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	record BPIOdourVc BPIOdourr;
	
	while (loopmain(BPIOdourr,1,true)) begin
		astr[acnt] = BPIOdourr.Name;
		acnt = acnt + 1;
	end;
	
	/*NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="ODOUR")then begin
				BPIOdourr.Code = NCSrw.CCode;
				readfirstmain(BPIOdourr,1,true);
				astr[acnt] = BPIOdourr.Name;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="ODOUR")then begin
						BPIOdourr.Code = NCSrw.CCode;
						readfirstmain(BPIOdourr,1,true);
						astr[acnt] = BPIOdourr.Name;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;*/
  RETURN;
END;




global 
procedure NewINBPIColorSClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	record BPIColorVc BPIColorr;

	
	while (loopmain(BPIColorr,1,true)) begin
		astr[acnt] = BPIColorr.Name;
		acnt = acnt + 1;
	end;
	
	/*NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="COLOR")then begin
				BPIColorr.Code = NCSrw.CCode;
				readfirstmain(BPIColorr,1,true);
				astr[acnt] = BPIColorr.Name;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="COLOR")then begin
						BPIColorr.Code = NCSrw.CCode;
						readfirstmain(BPIColorr,1,true);
						astr[acnt] = BPIColorr.Name;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;*/	
  RETURN;
END;


global 
procedure NewINBPICategory2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
		rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="CATEGORY")then begin
				astr[acnt] = NCSrw.CCode;
				acnt = acnt + 1;
			end;
		end;
	end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,2,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="CATEGORY")then begin
						astr[acnt] = NCSrw.CCode;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;



global 
procedure NewINBPIMaterial2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
		rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="MATERIAL")then begin
				astr[acnt] = NCSrw.CCode;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="MATERIAL")then begin
						astr[acnt] = NCSrw.CCode;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;



global 
procedure NewBPIColor2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="COLOR")then begin
				astr[acnt] = NCSrw.CCode;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="COLOR")then begin
						astr[acnt] = NCSrw.CCode;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;




global 
procedure NewINBPIShape2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="SHAPE")then begin
				astr[acnt] = NCSrw.CCode;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="SHAPE")then begin
						astr[acnt] = NCSrw.CCode;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;



global 
procedure NewINBPISize2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="SIZE")then begin
				astr[acnt] = NCSrw.CCode;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="SIZE")then begin
						astr[acnt] = NCSrw.CCode;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;




global 
procedure NewINBPIUse2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="USE")then begin
				astr[acnt] = NCSrw.CCode;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="USE")then begin
						astr[acnt] = NCSrw.CCode;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;




global 
procedure NewINBPISex2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="SEX")then begin
				astr[acnt] = NCSrw.CCode;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="SEX")then begin
						astr[acnt] = NCSrw.CCode;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;





global 
procedure NewINBPIPlating2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="PLATING")then begin
				astr[acnt] = NCSrw.CCode;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="PLATING")then begin
						astr[acnt] = NCSrw.CCode;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;




global 
procedure NewINBPIClarity2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="CLARITY")then begin
				astr[acnt] = NCSrw.CCode;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="CLARITY")then begin
						astr[acnt] = NCSrw.CCode;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;





global 
procedure NewINBPIWeight2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="WEIGHT")then begin
				astr[acnt] = NCSrw.CCode;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="WEIGHT")then begin
						astr[acnt] = NCSrw.CCode;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;




global 
procedure NewINBPICut2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="CUT")then begin
				astr[acnt] = NCSrw.CCode;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="CUT")then begin
						astr[acnt] = NCSrw.CCode;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;




global 
procedure NewINBPIStone2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="STONE")then begin
				astr[acnt] = NCSrw.CCode;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="STONE")then begin
						astr[acnt] = NCSrw.CCode;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;



global 
procedure NewINBPIStrap2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="STRAP")then begin
				astr[acnt] = NCSrw.CCode;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="STRAP")then begin
						astr[acnt] = NCSrw.CCode;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;




global 
procedure NewINBPIOdour2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="ODOUR")then begin
				astr[acnt] = NCSrw.CCode;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="ODOUR")then begin
						astr[acnt] = NCSrw.CCode;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;






global 
procedure NewIN2Length2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Type)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr, j;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record BTRxClassSetVc NCSr;
	row BTRxClassSetVc NCSrw;
	
	NCSr.Type = Type;
	if(readfirstmain(NCSr,2,true))then begin
		rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="LENGTH")then begin
				i = rwcnt;
				for (j=0;j<=100;j=j+0.1) begin
					astr[acnt] = NCSrw.CCode;
					acnt = acnt + 1;
				end;
			end;
		end;
	end;	
  RETURN;
END;




global 
procedure NewIN2BPIWidth2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Type)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr, j;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record BTRxClassSetVc NCSr;
	row BTRxClassSetVc NCSrw;
	
	NCSr.Type = Type;
	if(readfirstmain(NCSr,2,true))then begin
		rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="WIDTH")then begin
				i = rwcnt;
				for (j=0;j<=100;j=j+0.1) begin
					astr[acnt] = NCSrw.CCode;
					acnt = acnt + 1;
				end;
			end;
		end;
	end;	
  RETURN;
END;




global 
procedure NewIN2Height2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Type)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr, j;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record BTRxClassSetVc NCSr;
	row BTRxClassSetVc NCSrw;
	
	NCSr.Type = Type;
	if(readfirstmain(NCSr,2,true))then begin
		rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="HEIGHT")then begin
				i = rwcnt;
				for (j=0;j<=100;j=j+0.1) begin
					astr[acnt] = NCSrw.CCode;
					acnt = acnt + 1;
				end;
			end;
		end;
	end;	
  RETURN;
END;






global 
procedure NewIN2Diameter2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Type)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr, j;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record BTRxClassSetVc NCSr;
	row BTRxClassSetVc NCSrw;
	
	NCSr.Type = Type;
	if(readfirstmain(NCSr,2,true))then begin
		rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="DIAMETER")then begin
				i = rwcnt;
				for (j=0;j<=100;j=j+0.1) begin
					astr[acnt] = NCSrw.CCode;
					acnt = acnt + 1;
				end;
			end;
		end;
	end;	
  RETURN;
END;







global 
procedure NewIN2BPIVolume2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Type)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr, j;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record BTRxClassSetVc NCSr;
	row BTRxClassSetVc NCSrw;
	
	NCSr.Type = Type;
	if(readfirstmain(NCSr,2,true))then begin
		rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="VOLUME")then begin
				i = rwcnt;
				for (j=0;j<=100;j=j+0.1) begin
					astr[acnt] = NCSrw.CCode;
					acnt = acnt + 1;
				end;
			end;
		end;
	end;	
  RETURN;
END;







global 
procedure NewIN2Weight2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Type)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr, j;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record BTRxClassSetVc NCSr;
	row BTRxClassSetVc NCSrw;
	
	NCSr.Type = Type;
	if(readfirstmain(NCSr,2,true))then begin
		rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="WEIGHT")then begin
				i = rwcnt;
				for (j=0;j<=100;j=j+0.1) begin
					astr[acnt] = NCSrw.CCode;
					acnt = acnt + 1;
				end;
			end;
		end;
	end;	
  RETURN;
END;







global 
procedure NewIN2ItemSizeSClassArrayOnOpen(var Array string astr,var Integer acnt,string Type)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr, j;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record BTRxClassSetVc NCSr;
	row BTRxClassSetVc NCSrw;
	
	NCSr.Type = Type;
	if(readfirstmain(NCSr,2,true))then begin
		rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="IT_SIZE")then begin
				i = rwcnt;
				for (j=0;j<=100;j=j+0.1) begin
					astr[acnt] = NCSrw.CCode;
					acnt = acnt + 1;
				end;
			end;
		end;
	end;	
  RETURN;
END;







global 
procedure NewINBPIColor2SClassArrayOnOpen(var Array string astr,var Integer acnt,string Group,string SubGroup)
BEGIN
  record BPICategoryVc Categr;
  Integer i,rwcnt,rwnr;
  Boolean TrHs;
	record NewINVc NINr;
	row NewINVc NINrw;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	
	NCSr.Group = Group;
	NCSr.Type = SubGroup;
	if(readfirstmain(NCSr,2,true))then begin
	rwcnt = matrowcnt(NCSr);
		for(i=0;i<rwcnt;i=i+1) begin
			matrowget(NCSr,i,NCSrw);
			if(NCSrw.CType=="COLOR")then begin
				astr[acnt] = NCSrw.CCode;
				acnt = acnt + 1;
			end;
		end;
  end else begin
		TrHs = true;
		NCSr.Group = "";
		while (loopmain(NCSr,1,TrHs)) begin
			if(NCSr.Type==SubGroup)then begin
				rwcnt = matrowcnt(NCSr);
				for(i=0;i<rwcnt;i=i+1) begin
					matrowget(NCSr,i,NCSrw);
					if(NCSrw.CType=="COLOR")then begin
						astr[acnt] = NCSrw.CCode;
						acnt = acnt + 1;
					end;
				end;
				TrHs = false;
			end;	
		end;
	end;	
  RETURN;
END;


//server-only
external function roundmode DefaultRoundMode();
external function Integer GetFIFOPerSerialNr(record INVc,record ITVc,record CostAccBlock);
external procedure CalcCostPrice(val,val,val,Integer,val,var val,var val);
external function string 255 NextSerialNumber(string,string,record SerNrTrackBlock);
external function Integer ItemCostPerLocation(record INVc);
external function roundmode SetRoundModeD(Integer);
external function val FindWAPriceBackdated(Integer,record INVc,string,val,Date,Boolean,Integer);
external function Boolean ConsigmentStock(string,string,Date);
external function Boolean TREOStock(string,string,Date);
external function val FindCostPriceLIFOBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer,Integer);
external function val FindCostPriceBP(Integer,record INVc,string);
external function val GetStockQty(string,string,Date,Boolean);
//external function val FindCostPriceCostPrice(Integer,record INVc,string);
external function roundmode CostPriceDecimals();
external procedure GetCostsFromRecords(record ItemHistVc,var val,var val,Boolean,Date);
external function Integer ArtCodeCostPerLocation(string);
external function Integer CostPricePerLocation(record INVc,record ITVc,record CostAccBlock);
external function Integer WAPerLocation(record INVc,record ITVc,record CostAccBlock);
external function Integer FIFOPerLocation(record INVc,record ITVc,record CostAccBlock);
external function val CalculateQty2(val,val);
external function Boolean TestArtCode(string,string,record INVc);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure GetStockedItemFromRecepy(record SHVc,var string,var val);
external function Boolean ExpandStructItem(string,string,val,var record SHVc);
external procedure PrintItemHistLine(record ItemHistVc,val);
external function val FindCostPriceWA(Integer,record INVc,string);
external procedure CurValToOtherCur(Date,string,val,string,var val,roundmode); //Edit***************************Sasha2,15:16 18.03.2015
external function val AbsoluteVal(val); //Edit***************************Sasha2,12:46 20.05.2016


// adjustqty = Quantities from lines above with the same item number, indicates how many IHr will be skipped until first will be used
// takenqty = How many quantities was used from the qty
// skippedqty = How many quantities was skipped on the IHr we will use for cost


function val FindCostPriceCP(Integer WAPerLocation,record INVc INr,string location)
begin
  val res;
  
  if (INr.PriceFactor!=0) then begin
    res = INr.InPrice / INr.PriceFactor;
  end else begin
    res = INr.InPrice;
  end;
  FindCostPriceCP = res;
  return;
end;

//Edit***************************Sasha2,13:25 18.03.2015 {
function val AddCurValToTrans_CalculateCosts(record ItemHistVc IHr,val qty,var val adjv,var val skippedqty,var val takenqty,Boolean costfrrecf,Boolean printf,Boolean todaysratef,Integer OverwriteCostModel,Integer PerLocation,record INVc INr,integer rownr,var record IVVc fifocurIVr,var record StockMovVc fifocurSMr,integer recordtype)
begin
  val res;
  val remcost,t;
  val remcostprice,totcostprice;
  record ItemHistVc printIHr,CurrIHr; //Edit***************************Sasha2,15:09 18.03.2015
  row IVVc fifocurIVrw; //Edit***************************Sasha2,13:29 18.03.2015
  row StockMovVc fifocurSMrw; //Edit***************************Sasha2,13:29 18.03.2015
  val remcost_curr,currcost,convertedsum; //Edit***************************Sasha2,13:37 18.03.2015
  
  logtext(0,"AddCurValToTrans_CalculateCosts");
  
  res = blankval;
  switch (OverwriteCostModel) begin 
    case 1:
      t = FindCostPriceCP(PerLocation,INr,IHr.Location);
      remcostprice = (IHr.RemQty-takenqty)*t;
      totcostprice = IHr.Qty*t;
    case 2:
      t = FindCostPriceBP(PerLocation,INr,IHr.Location);
      remcostprice = (IHr.RemQty-takenqty)*t;
      totcostprice = IHr.Qty*t;
    case 3:
      t = FindCostPriceWA(PerLocation,INr,IHr.Location);
//      remcostprice = (IHr.RemQty-takenqty)*t; this or below ? , but this sounds worng doesnt it ?  or maybe only for FIFO ? 
      remcostprice = IHr.RemQty*t;
      
      totcostprice = IHr.Qty*t;
    otherwise
      remcostprice = IHr.RemCostPrice;
      totcostprice = IHr.TotCostPrice;
  end;
  if (costfrrecf) or (todaysratef) then begin
    GetCostsFromRecords(IHr,remcostprice,totcostprice,todaysratef,CurrentDate);
  end;
  if (printf) then begin
    RecordCopy(printIHr,IHr);
//    printIHr.RemQty = printIHr.RemQty - takenqty;
    if (printIHr.RemQty>(qty - takenqty)) then begin
      printIHr.RemQty = qty - takenqty;
    end else begin
      printIHr.RemQty = printIHr.RemQty;
    end;
    if (printIHr.RemQty>qty) then begin
      remcostprice = (remcostprice*qty)/printIHr.RemQty;
      printIHr.RemQty = qty;
    end else begin
      switch (OverwriteCostModel) begin
        case 1:
          remcostprice = printIHr.RemQty*FindCostPriceCP(PerLocation,INr,IHr.Location);
        case 2:
          remcostprice = printIHr.RemQty*FindCostPriceBP(PerLocation,INr,IHr.Location);
      end;
    end;
    PrintItemHistLine(printIHr,remcostprice);
  end;
  remcost = remcostprice - adjv*(Round(totcostprice/IHr.Qty,CostPriceDecimals));
  remcost_curr = (IHr.TotCostPriceCurncy/IHr.Qty)*IHr.RemQty - adjv*(Round(IHr.TotCostPriceCurncy/IHr.Qty,CostPriceDecimals)); //Edit***************************Sasha2,13:50 18.03.2015
  if ((adjv - IHr.RemQty)<0) then begin
    t = IHr.RemQty - adjv;
    skippedqty = IHr.RemQty-t;
    adjv = 0;
  end else begin
    adjv = adjv - IHr.RemQty;
    skippedqty = IHr.RemQty;
    t = 0;
  end;
  if (adjv==0) then begin // stop skipping...
    if (t+takenqty>qty) then begin
      t = qty - takenqty;
    end;
    if (t!=0) then begin
    
      switch (recordtype) begin //Edit***************************Sasha2,14:43 18.03.2015 {
        case 1:
          if (MatRowCnt(fifocurIVr)>rownr) then begin 
            MatRowGet(fifocurIVr,rownr,fifocurIVrw);
            if (nonblank(fifocurIVrw.Spec) and fifocurIVrw.Spec!=IHr.CurncyCode) then begin
              if (fifocurIVrw.Quant!=1) then begin
                CurrIHr.ArtCode = IHr.ArtCode;
                CurrIHr.FileName = "PUVc";
                if (ReadLastKey("FNArtCode",CurrIHr,2,false) and CurrIHr.ArtCode==IHr.ArtCode) then begin
                  if (CurrIHr.CurncyCode!=fifocurIVrw.Spec) then begin
                    CurValToOtherCur(IHr.TransDate,fifocurIVrw.Spec,fifocurIVrw.FIFO,CurrIHr.CurncyCode,convertedsum,DefaultCurRoundOff);
                    fifocurIVrw.FIFO = convertedsum;
                    fifocurIVrw.FrRate = round(CurrIHr.TotCostPriceCurncy/CurrIHr.TotCostPrice,DefaultCurRoundOff);
                    fifocurIVrw.BaseRate1 = 1;
                    fifocurIVrw.Spec = CurrIHr.CurncyCode;
                    fifocurIVrw.Quant = 1;
                  end else begin
                    fifocurIVrw.Quant = 1;
                  end;
                end else begin
                  goto LAddCurValToTrans_CalculateCosts;
                end;
              end;
            end;
          end else begin
            ClearRow(fifocurIVr,fifocurIVrw,1);
            fifocurIVrw.Spec = IHr.CurncyCode;
          end; 
        case 2:
          if (MatRowCnt(fifocurSMr)>rownr) then begin 
            MatRowGet(fifocurSMr,rownr,fifocurSMrw);
            if (nonblank(fifocurSMrw.Spec) and fifocurSMrw.Spec!=IHr.CurncyCode) then begin
              if (fifocurSMrw.Quant!=1) then begin
                CurrIHr.ArtCode = IHr.ArtCode;
                CurrIHr.FileName = "PUVc";
                if (ReadLastKey("FNArtCode",CurrIHr,2,false) and CurrIHr.ArtCode==IHr.ArtCode) then begin
                  if (CurrIHr.CurncyCode!=fifocurSMrw.Spec) then begin
                    CurValToOtherCur(IHr.TransDate,fifocurSMrw.Spec,fifocurSMrw.SentFIFORowVal,CurrIHr.CurncyCode,convertedsum,DefaultCurRoundOff);
                    fifocurSMrw.SentFIFORowVal = convertedsum;
                    fifocurSMrw.NewPrice = round(CurrIHr.TotCostPriceCurncy/CurrIHr.TotCostPrice,DefaultCurRoundOff); //from rate
                    fifocurSMrw.OldPrice = 1; //to rate
                    fifocurSMrw.Spec = CurrIHr.CurncyCode;
                    fifocurSMrw.Quant = 1;
                  end else begin
                    fifocurSMrw.Quant = 1;
                  end;
                end else begin
                  goto LAddCurValToTrans_CalculateCosts;
                end;
              end;
            end;
          end else begin
            ClearRow(fifocurSMr,fifocurSMrw,1);
            fifocurSMrw.Spec = IHr.CurncyCode;
          end; 
      end;//Edit***************************Sasha2,14:44 18.03.2015 }
      if (IHr.RemQty==t) then begin
        res = res + remcostprice;
        currcost = (IHr.TotCostPriceCurncy/IHr.Qty)*IHr.RemQty; //Edit***************************Sasha2,14:42 18.03.2015
      end else begin
        if (t==IHr.RemQty-skippedqty) then begin
          res = res + remcost;
          currcost = remcost_curr; //Edit***************************Sasha2,14:42 18.03.2015
        end else begin
          res = res + (round(totcostprice/IHr.Qty,CostPriceDecimals) * t);
          currcost = round(IHr.TotCostPriceCurncy/IHr.Qty,CostPriceDecimals) * t; //Edit***************************Sasha2,14:42 18.03.2015
        end;
      end;
      switch (recordtype) begin //Edit***************************Sasha2,14:43 18.03.2015 {
        case 1:
          if (nonblank(fifocurIVrw.Spec) and fifocurIVrw.Spec!=IHr.CurncyCode) then begin
            CurValToOtherCur(IHr.TransDate,IHr.CurncyCode,currcost,fifocurIVrw.Spec,convertedsum,DefaultCurRoundOff);
            currcost = convertedsum;
          end;
          fifocurIVrw.FIFO = fifocurIVrw.FIFO + currcost; 
          MatRowPut(fifocurIVr,rownr,fifocurIVrw); 
        case 2:
          if (nonblank(fifocurSMrw.Spec) and fifocurSMrw.Spec!=IHr.CurncyCode) then begin
            CurValToOtherCur(IHr.TransDate,IHr.CurncyCode,currcost,fifocurSMrw.Spec,convertedsum,DefaultCurRoundOff);
            currcost = convertedsum;
          end;
          fifocurSMrw.SentFIFORowVal = fifocurSMrw.SentFIFORowVal + currcost; 
          MatRowPut(fifocurSMr,rownr,fifocurSMrw); 
      end;//Edit***************************Sasha2,14:44 18.03.2015 }
      takenqty = takenqty + t;
    end;
  end;
  
 LAddCurValToTrans_CalculateCosts:; //Edit***************************Sasha2,15:09 18.03.2015 
  
  AddCurValToTrans_CalculateCosts = res;
  return;
end; //Edit***************************Sasha2,13:24 18.03.2015 }

function val CalculateCosts(record ItemHistVc IHr,val qty,var val adjv,var val skippedqty,var val takenqty,Boolean costfrrecf,Boolean printf,Boolean todaysratef,Integer OverwriteCostModel,Integer PerLocation,record INVc INr)
begin
  val res;
  val remcost,t;
  val remcostprice,totcostprice;
  record ItemHistVc printIHr;
  
  res = blankval;
  switch (OverwriteCostModel) begin 
    case 1:
      t = FindCostPriceCP(PerLocation,INr,IHr.Location);
      remcostprice = (IHr.RemQty-takenqty)*t;
      totcostprice = IHr.Qty*t;
    case 2:
      t = FindCostPriceBP(PerLocation,INr,IHr.Location);
      remcostprice = (IHr.RemQty-takenqty)*t;
      totcostprice = IHr.Qty*t;
    case 3:
      t = FindCostPriceWA(PerLocation,INr,IHr.Location);
//      remcostprice = (IHr.RemQty-takenqty)*t; this or below ? , but this sounds worng doesnt it ?  or maybe only for FIFO ? 
      remcostprice = IHr.RemQty*t;
      
      totcostprice = IHr.Qty*t;
    otherwise
      remcostprice = IHr.RemCostPrice;
      totcostprice = IHr.TotCostPrice;
  end;
  if (costfrrecf) or (todaysratef) then begin
    GetCostsFromRecords(IHr,remcostprice,totcostprice,todaysratef,CurrentDate);
  end;
  if (printf) then begin
    RecordCopy(printIHr,IHr);
//    printIHr.RemQty = printIHr.RemQty - takenqty;
    if (printIHr.RemQty>(qty - takenqty)) then begin
      printIHr.RemQty = qty - takenqty;
    end else begin
      printIHr.RemQty = printIHr.RemQty;
    end;
    if (printIHr.RemQty>qty) then begin
      remcostprice = (remcostprice*qty)/printIHr.RemQty;
      printIHr.RemQty = qty;
    end else begin
      switch (OverwriteCostModel) begin
        case 1:
          remcostprice = printIHr.RemQty*FindCostPriceCP(PerLocation,INr,IHr.Location);
        case 2:
          remcostprice = printIHr.RemQty*FindCostPriceBP(PerLocation,INr,IHr.Location);
      end;
    end;
    PrintItemHistLine(printIHr,remcostprice);
  end;
  remcost = remcostprice - adjv*(Round(totcostprice/IHr.Qty,CostPriceDecimals));
  if ((adjv - IHr.RemQty)<0) then begin
    t = IHr.RemQty - adjv;
    skippedqty = IHr.RemQty-t;
    adjv = 0;
  end else begin
    adjv = adjv - IHr.RemQty;
    skippedqty = IHr.RemQty;
    t = 0;
  end;
  if (adjv==0) then begin // stop skipping...
    if (t+takenqty>qty) then begin
      t = qty - takenqty;
    end;
    if (t!=0) then begin
      if (IHr.RemQty==t) then begin
        res = res + remcostprice;
      end else begin
        if (t==IHr.RemQty-skippedqty) then begin
          res = res + remcost;
        end else begin
          res = res + (round(totcostprice/IHr.Qty,CostPriceDecimals) * t);
        end;
      end;
      takenqty = takenqty + t;
    end;
  end;
  CalculateCosts = res;
  return;
end;

global //Edit***************************Sasha2,12:42 18.03.2015 {
function val AddCurValToTrans_FindCostPriceFIFO(Integer FIFOPerLocation,record INVc INr,string location,string serialnr,val qty,val adjustqty,Boolean costfrrecf,Boolean printf,Boolean todaysratef,Integer OverwriteCostModel,Integer consigstock,integer rownr,var record IVVc fifocurIVr,var record StockMovVc fifocurSMr,integer recordtype)
begin
  record ItemHistVc IHr;
  string 200 thekey;
  Integer keys;
  Boolean foundf,testf;
  val res,adjv,t,takenqty,remcost,skippedqty;
  Date blankd;
  
  logtext(0,"AddCurValToTrans_FindCostPriceFIFO");
  
  res = blankval;
  takenqty = 0;
  IHr.ArtCode = INr.Code;
  IHr.Location = location;
  if ((FIFOPerLocation==0) or (blank(location))) then begin
    thekey = "ActiveQty";
    keys = 1;
  end else begin
    thekey = "ActiveLocQty";
    keys = 2;
  end;
  adjv = adjustqty;
  ResetLoop(IHr);
  foundf = true;
  while (LoopKey(thekey,IHr,keys,foundf)) begin
    if (IHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==2) then begin
      if (IHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (takenqty>=qty) then begin
      foundf = false;
    end;
    if (IHr.RemQty<0) then begin
      if ((blank(IHr.SerialNr)) and (blank(IHr.Variety))) then begin // If a normal stocked item has a record with negative RemQty, there is no need to read further
        foundf = false;
      end;
    end;
    if (foundf) then begin
      testf = true;
      switch (consigstock) begin
        case 1: 
          if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)) then begin//current status
//          if (IHr.ConsigStock!=0) then begin 
            testf = false;
          end;
        case 2: 
          if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)==false) then begin
//          if (IHr.ConsigStock==0) then begin 
            testf = false;
          end;          
      end;
      if (printf) then begin
        if (nonblank(location)) then begin
          if (OverwriteCostModel!=kCostModelWA) then begin
            if (IHr.Location!=location) then begin testf = false; end;
          end;
        end;
      end;
      if (testf) then begin
        //res = res + CalculateCosts(IHr,qty,adjv,skippedqty,takenqty,costfrrecf,printf,todaysratef,OverwriteCostModel,FIFOPerLocation,INr); //Edit***************************Sasha2,13:26 18.03.2015
        res = res + AddCurValToTrans_CalculateCosts(IHr,qty,adjv,skippedqty,takenqty,costfrrecf,printf,todaysratef,OverwriteCostModel,FIFOPerLocation,INr,rownr,fifocurIVr,fifocurSMr,recordtype); //Edit***************************Sasha2,13:26 18.03.2015
      end;
    end;
  end;
  AddCurValToTrans_FindCostPriceFIFO = res;
  return;
end; //Edit***************************Sasha2,12:42 18.03.2015 }

global
function val FindCostPriceFIFO(Integer FIFOPerLocation,record INVc INr,string location,string serialnr,val qty,val adjustqty,Boolean costfrrecf,Boolean printf,Boolean todaysratef,Integer OverwriteCostModel,Integer consigstock)
begin
  record ItemHistVc IHr;
  string 200 thekey;
  Integer keys;
  Boolean foundf,testf;
  val res,adjv,t,takenqty,remcost,skippedqty;
  Date blankd;
  
  res = blankval;
  takenqty = 0;
  IHr.ArtCode = INr.Code;
  IHr.Location = location;
  if ((FIFOPerLocation==0) or (blank(location))) then begin
    thekey = "ActiveQty";
    keys = 1;
  end else begin
    thekey = "ActiveLocQty";
    keys = 2;
  end;
  adjv = adjustqty;
  ResetLoop(IHr);
  foundf = true;
  while (LoopKey(thekey,IHr,keys,foundf)) begin
    if (IHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==2) then begin
      if (IHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (takenqty>=qty) then begin
      foundf = false;
    end;
    if (IHr.RemQty<0) then begin
      if ((blank(IHr.SerialNr)) and (blank(IHr.Variety))) then begin // If a normal stocked item has a record with negative RemQty, there is no need to read further
        foundf = false;
      end;
    end;
    if (foundf) then begin
      testf = true;
      switch (consigstock) begin
        case 1: 
          if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)) then begin//current status
//          if (IHr.ConsigStock!=0) then begin 
            testf = false;
          end;
        case 2: 
          if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)==false) then begin
//          if (IHr.ConsigStock==0) then begin 
            testf = false;
          end;          
      end;
      if (printf) then begin
        if (nonblank(location)) then begin
          if (OverwriteCostModel!=kCostModelWA) then begin
            if (IHr.Location!=location) then begin testf = false; end;
          end;
        end;
      end;
      if (testf) then begin
        res = res + CalculateCosts(IHr,qty,adjv,skippedqty,takenqty,costfrrecf,printf,todaysratef,OverwriteCostModel,FIFOPerLocation,INr);
      end;
    end;
  end;
  FindCostPriceFIFO = res;
  return;
end;

global
function val FindCostPriceLIFO(Integer FIFOPerLocation,record INVc INr,string location,string serialnr,val qty,val adjustqty,Boolean costfrrecf,Boolean printf,Boolean todaysratef,Integer OverwriteCostModel,Integer consigstock)
begin
  record ItemHistVc IHr;
  string 200 thekey;
  Integer keys;
  Boolean foundf,testf;
  val res,adjv,t,takenqty,remcost,skippedqty;
  Date blankd;
  
  res = blankval;
  takenqty = 0;
  IHr.ArtCode = INr.Code;
  IHr.Location = location;
  if ((FIFOPerLocation==0) or (blank(location))) then begin
    thekey = "ActiveQty";
    keys = 1;
  end else begin
    thekey = "ActiveLocQty";
    keys = 2;
  end;
  adjv = adjustqty;
  ResetLoop(IHr);
  foundf = true;
  while (LoopBackKey(thekey,IHr,keys,foundf)) begin
    if (IHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==2) then begin
      if (IHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (takenqty>=qty) then begin
      foundf = false;
    end;
    if (IHr.RemQty<0) then begin
      if ((blank(IHr.SerialNr)) and (blank(IHr.Variety))) then begin // If a normal stocked item has a record with negative RemQty, there is no need to read further
        foundf = false;
      end;
    end;
    if (foundf) then begin
      testf = true;
      switch (consigstock) begin
        case 1: 
          if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)) then begin
//          if (IHr.ConsigStock!=0) then begin 
            testf = false;
          end;
        case 2: 
          if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)==false) then begin
//          if (IHr.ConsigStock==0) then begin 
            testf = false;
          end;
      end;
      if (testf) then begin
        res = res + CalculateCosts(IHr,qty,adjv,skippedqty,takenqty,costfrrecf,printf,todaysratef,OverwriteCostModel,0,INr);
      end;
    end;
  end;
  FindCostPriceLIFO = res;
  return;
end;


global
function val FindCostPriceSerial1(record INVc INr,string location,string serialnr,val qty,val adjustqty,Boolean printf,Integer consigstock,var record IVVc fifocurIVr,integer rownr,record StockMovVc fifocurSMr,integer recordtype,integer perlocation)
begin
  record ItemHistVc IHr;
  string 200 thekey;
  Integer keys;
  Boolean foundf,testf;
  val res,adjv,t,takenqty,remcost,skippedqty;
	Date blankd;
	
  res = blankval;
  takenqty = 0;
  IHr.ArtCode = INr.Code;
  IHr.Location = location;
  thekey = "ActiveQty";
  keys = 1;
  if (nonblank(IHr.Location)) then begin
    thekey = "ActiveLocQty";
    keys = 2;
  end;
  adjv = adjustqty;
  ResetLoop(IHr);
  foundf = true;
  while (LoopKey(thekey,IHr,keys,foundf)) begin
    if (IHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==2) then begin
      if (IHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (takenqty>=qty) then begin
      foundf = false;
    end;
    testf = foundf;
    if (nonblank(serialnr)) then begin
      if (IHr.SerialNr!=serialnr) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      testf = true;
      switch (consigstock) begin
        case 1: 
          if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)) then begin
//          if (IHr.ConsigStock!=0) then begin 
            testf = false;
          end;
        case 2: 
          if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)==false) then begin
//          if (IHr.ConsigStock==0) then begin 
            testf = false;
          end;
      end;
      if (testf) then begin
        res = res +  AddCurValToTrans_CalculateCosts(IHr,qty,adjv,skippedqty,takenqty,false,printf,false,0,perlocation,INr,rownr,fifocurIVr,fifocurSMr,recordtype);
      end;
    end;
  end;
  FindCostPriceSerial1 = res;
  return;
end;


global
function val FindCostPriceSerial(record INVc INr,string location,string serialnr,val qty,val adjustqty,Boolean printf,Integer consigstock)
begin
  record ItemHistVc IHr;
  string 200 thekey;
  Integer keys;
  Boolean foundf,testf;
  val res,adjv,t,takenqty,remcost,skippedqty;
	
  Date blankd;
  res = blankval;
  takenqty = 0;
  IHr.ArtCode = INr.Code;
  IHr.Location = location;
  thekey = "ActiveQty";
  keys = 1;
  if (nonblank(IHr.Location)) then begin
    thekey = "ActiveLocQty";
    keys = 2;
  end;
  adjv = adjustqty;
  ResetLoop(IHr);
  foundf = true;
  while (LoopKey(thekey,IHr,keys,foundf)) begin
    if (IHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==2) then begin
      if (IHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (takenqty>=qty) then begin
      foundf = false;
    end;
    testf = foundf;
    if (nonblank(serialnr)) then begin
      if (IHr.SerialNr!=serialnr) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      testf = true;
      switch (consigstock) begin
        case 1: 
          if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)) then begin
//          if (IHr.ConsigStock!=0) then begin 
            testf = false;
          end;
        case 2: 
          if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)==false) then begin
//          if (IHr.ConsigStock==0) then begin 
            testf = false;
          end;
      end;
      if (testf) then begin
        res = res + CalculateCosts(IHr,qty,adjv,skippedqty,takenqty,false,printf,false,0,0,INr);
      end;
    end;
  end;
  FindCostPriceSerial = res;
  return;
end;



function val FindLastCostPriceSerial(record INVc INr,string location,string serialnr,val qty,Boolean printf,Integer consigstock)
begin
  record ItemHistVc IHr;
  string 200 thekey;
  Integer keys;
  Boolean foundf,testf;
  val res,adjv,t,takenqty,remcost,skippedqty,lqty;
  
  lqty = -qty;
  res = blankval;
  takenqty = 0;
  IHr.ArtCode = INr.Code;
  IHr.SerialNr = serialnr;
  thekey = "ArtCodeSerialNr";
  keys = 2;
  adjv = 0;
  ResetLoop(IHr);
  foundf = true;
  while (LoopBackKey(thekey,IHr,keys,foundf)) begin
    if (IHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (IHr.SerialNr!=serialnr) then begin
      foundf = false;
    end;
    if (takenqty>=lqty) then begin
      foundf = false;
    end;
    testf = foundf;
    if (testf) then begin
      testf = true;
      switch (consigstock) begin
        case 1: 
          if (IHr.ConsigStock!=0) then begin 
            testf = false;
          end;
        case 2: 
          if (IHr.ConsigStock==0) then begin 
            testf = false;
          end;
      end;
      if (testf) then begin
        if (IHr.Qty<lqty) then begin
          takenqty = takenqty + IHr.Qty;
        end else begin
          takenqty = takenqty + lqty;
        end;
        res = res + (IHr.TotCostPrice*lqty)/IHr.Qty;
      end;
    end;
  end;

  FindLastCostPriceSerial = res;
  return;
end;

global
function val QtyUsedBeforeDate(record ItemHistVc sourceIHr,Boolean fifodatef,Date td)
begin
  val res;
  record ItemHistVc IHr;
  Boolean found,testf;
  
  found = true;
  IHr.Source = sourceIHr.SerNr;
  while (LoopKey("Source",IHr,1,found)) begin
    if (IHr.Source!=sourceIHr.SerNr) then begin
      found = false;
    end;
    if (found) then begin
      testf = true;
      if (fifodatef) then begin
        if (IHr.FIFODate>td) then begin testf = false; end;
       end else begin
        if (IHr.TransDate>td) then begin testf = false; end;
      end;
      if (IHr.FileName=="RetVc") then begin testf = false; end;//returned goods have source but should not be used for calcualtion, they dont take out of stock
      if (testf) then begin
        res = res - IHr.Qty;
      end;
    end;
  end;
  QtyUsedBeforeDate = res;
  return;
end;

global
function val FindCostPriceBasePrice(record CostAccBlock CAb,record INVc INr,record ITVc ITr)
begin
  val res;
  val CostPerc;
  
  res = blankval;
  CostPerc = INr.CostPerc;
  if (blank(CostPerc)) then begin
    if (CAb.ItemGroupCostModel!=0) then begin//ISVC, per location
      CostPerc = ITr.CostPerc;
    end;
  end;
  if (CostPerc==0) then begin
    CostPerc = CAb.CostPerc;
  end;
  if (CostPerc==0) then begin
    CostPerc = 100;
  end;
  res = Round((INr.UPrice1 * CostPerc)/100,SetRoundModeD(3));
  if (INr.PriceFactor!=0) then begin        
    res = res/INr.PriceFactor; 
  end;
  FindCostPriceBasePrice = res;
  return;
end;

function Boolean FindNegativeSourceFIFOCost(Integer FIFOPerLocation,record INVc INr,string location,string serialnr,val qty,val adjustqty,Date td,var val inprice)
begin
  record ItemHistVc IHr;
  record ItemHistVc sourceIHr;
  string 200 thekey;
  Integer keys;
  Boolean foundf,testf;
  val qcnt,fifoq,fifov;
  
  inprice = qty * INr.InPrice;
  qcnt = -qty;
  fifoq = 0;
  fifov = 0;
  foundf = true;
  IHr.ArtCode = INr.Code;
  IHr.Location = location;
  IHr.FIFODate = td;
  if ((FIFOPerLocation==0) or (blank(IHr.Location))) then begin
    thekey = "ArtCodeFD";
    if (blank(td)) then begin
      keys = 1;
    end else begin
      keys = 2;
    end;
  end else begin
    thekey = "ArtCodeLocFD";
    keys = 3;
  end;
  while (LoopBackKey(thekey,IHr,keys,foundf)) begin
    if (IHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==3) then begin
      if (IHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (IHr.Qty>0) then begin foundf = false; end; // As soon as we have a positive one, we stop, on purpouse, because after this it is impossible to figure out negative qty FIFO cost...
    if (foundf) then begin
      testf = true;
      if (IHr.StockAffectf==0) then begin testf = false; end;
      if (IHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (IHr.Invalid!=0) then begin testf = false; end;
      if (testf) then begin
        sourceIHr.SerNr = IHr.Source;
        if (ReadFirstMain(sourceIHr,1,true)) then begin
          if (qcnt>=sourceIHr.Qty) then begin
            fifoq = fifoq + sourceIHr.Qty;
            fifov = fifov + sourceIHr.TotCostPrice;
            qcnt = qcnt - sourceIHr.Qty;
          end else begin
            fifoq = fifoq + qcnt;
            fifov = fifov + ((sourceIHr.TotCostPrice / sourceIHr.Qty) * qcnt);
            qcnt = 0;
          end;
          if (qcnt<=0) then begin
            foundf = false;
          end;
        end;
      end;
    end;
  end;
  if (fifoq>0) then begin
    qcnt = -qty;
    if (fifoq<qcnt) then begin
      inprice = -((fifov / fifoq) * qcnt);
    end else begin
      inprice = -fifov;
    end;
  end;
  return;
end;

global
function val FindCostPriceFIFOBackDated(Integer FIFOPerLocation,record INVc INr,string location,string serialnr,val qty,val adjustqty,Date td,Boolean costfrrecf,Integer print,Boolean ondayratef,Integer OverwriteCostModel,Integer consigstock,Integer repcalcwa)
//val adjustqty ? 
begin
  record ItemHistVc IHr;
  record ItemHistVc nextIHr;
  record ItemHistVc outIHr;
  record ItemHistVc printIHr;
  record ITVc ITr;
  string 200 thekey;
  Integer keys;
  Boolean foundf,firstf,testf;
  val qcnt,res,instock,inprice,qusebefdat;
  val remcostprice,totcostprice,t,usedqty,outqty,nextqty;
  record CostAccBlock CAb;
  LongInt looppos;

  res = blankval;
  testf = false;
  BlockLoad(CAb);
  if (qty<0) then begin
    switch (OverwriteCostModel) begin
      case 2:
        ITr.Code = INr.Group;
        if (ReadFirstMain(ITr,1,true)) then begin
        end;
        inprice = qty * FindCostPriceBasePrice(CAb,INr,ITr);
      case 3:
        inprice = qty * INr.WeighedAvPrice;
      otherwise
        FindNegativeSourceFIFOCost(FIFOPerLocation,INr,location,serialnr,qty,adjustqty,td,inprice);
    end;
    goto LFindCostPriceFIFOBackDated;
  end;
  if (blankdate(td)) or (td==CurrentDate) then begin
    testf = true;
  end;  
  switch (OverwriteCostModel) begin
    case 1:
      if (blankdate(td)) or (td>=CurrentDate) then begin
        testf = true;
      end;
    case 2:
      if (blankdate(td)) or (td>=CurrentDate) then begin
        testf = true;
      end;
  end;
  if (testf) then begin
    inprice = FindCostPriceFIFO(FIFOPerLocation,INr,location,serialnr,qty,adjustqty,costfrrecf,print!=0,ondayratef,OverwriteCostModel,consigstock);
    goto LFindCostPriceFIFOBackDated;
  end;
  IHr.ArtCode = INr.Code;
  IHr.Location = location;
  IHr.FIFODate = td;
  
/*if FIFO per location it is not that simple at all
*/
  

  if ((FIFOPerLocation==0) or (blank(IHr.Location))) then begin
    thekey = "ArtCodeFD";
    keys = 2;
    instock = GetStockQty(INr.Code,"",td,false);
  end else begin
    thekey = "ArtCodeLocFD";
    keys = 3;
    instock = GetStockQty(INr.Code,location,td,false);
  end;
  
  RecordNew(nextIHr);
  ResetLoop(IHr);
  foundf = true;
  while (LoopBackKey(thekey,IHr,keys,foundf)) begin
    if (IHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==3) then begin
      if (IHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (foundf) then begin
      testf = true;
      if (IHr.StockAffectf==0) then begin testf = false; end;
      if (IHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (IHr.Invalid!=0) then begin testf = false; end;
      if (testf) then begin
        qcnt = qcnt + IHr.Qty;
        if (IHr.Qty<0) then begin 
          outqty = outqty - IHr.Qty;
        end;
        if (qcnt>=(instock-adjustqty)) then begin
          looppos = GetLoopPosition(IHr);
          RecordCopy(nextIHr,IHr);
          RecordCopy(printIHr,IHr);
          printIHr.RemQty = printIHr.Qty;
          switch (OverwriteCostModel) begin 
            case 3:
              printIHr.RemCostPrice = printIHr.TotCostPrice;
            otherwise
              printIHr.RemCostPrice = printIHr.TotCostPrice;
          end;
          foundf = false;
        end;
      end;
    end;
  end;

  outqty = 0;
/* // This causes problems, what is this function supposed to solve, cause whatever it does it screwes up the new "QtyUsedBeforeDate" function
  RecordCopy(outIHr,nextIHr);
  outIHr.ArtCode = INr.Code;
  outIHr.Location = location;
  outIHr.FIFODate = td;

  qcnt = 0;
// shuld be possible to move to loop above    
  foundf = true;
  while (LoopBackKey(thekey,outIHr,keys,foundf)) begin // Start from the nextIHr record and find all out things
    if (outIHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==3) then begin
      if (outIHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (foundf) then begin
      testf = true;
      if (outIHr.StockAffectf==0) then begin testf = false; end;
      if (outIHr.Invalid!=0) then begin testf = false; end;
      if (testf) then begin
        qcnt = qcnt + outIHr.Qty;
        if (qcnt>=(instock-adjustqty)) then begin
          foundf = false;
        end;
        if (outIHr.Qty>0) then begin 
          if (CAb.RetFIFOQue!=0) then begin
            if (outIHr.FileName=="RetVc") then begin
            end else begin
              testf = false; 
            end;
          end else begin
            testf = false; 
          end;
        end;
      end;
      if (outIHr.Invalid!=0) then begin testf = false; end;
      if (testf) then begin
        outqty = outqty - outIHr.Qty;
      end;
    end;
  end;
  outqty = outqty + adjustqty;
*/
  ResetLoop(nextIHr);
  nextIHr.ArtCode = INr.Code;
  nextIHr.Location = location;
  SetLoopPosition(nextIHr,looppos-1);  

  inprice = 0;
  usedqty = 0;
  firstf = true;
  foundf = true;
  while (LoopKey(thekey,nextIHr,keys,foundf)) begin // Start from the nextIHr record
    if (nextIHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==3) then begin
      if (nextIHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (nextIHr.FIFODate>td) then begin
      foundf = false;
    end;
    if (usedqty>=qty) then begin
      foundf = false;
    end;
    if (foundf) then begin
      testf = true;
      if (nextIHr.StockAffectf==0) then begin testf = false; end;
      if (nextIHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (nextIHr.Invalid!=0) then begin testf = false; end;
      if (nextIHr.Qty<0) then begin testf = false; end;
      if (testf) then begin
        qusebefdat = QtyUsedBeforeDate(nextIHr,FIFOPerLocation!=0,AddDay(td,0)); // nextIHr.FIFODate
//        qusebefdat = QtyUsedBeforeDate(nextIHr,true,AddDay(td,-1)); //what if run on date when "things" happen 
        nextqty = nextIHr.Qty - outqty - qusebefdat;
        outqty = outqty - nextIHr.Qty - qusebefdat;
        if (outqty<0) then begin
          outqty = 0;
        end;
        if (nextqty<0) then begin
          testf = false;
        end;
      end;
      if (testf) then begin
        if ((usedqty+nextqty)>qty) then begin
          nextqty = qty - usedqty;
        end else begin
          nextqty = nextqty; 
        end;
        usedqty = usedqty + nextqty;
        switch (consigstock) begin
          case 1: 
            if (ConsigmentStock(nextIHr.ArtCode,nextIHr.SerialNr,td)) then begin
//            if (nextIHr.ConsigStock!=0) then begin 
              testf = false;
            end;
          case 2: 
            if (ConsigmentStock(nextIHr.ArtCode,nextIHr.SerialNr,td)==false) then begin
//            if (nextIHr.ConsigStock==0) then begin 
              testf = false;
            end;
        end;
        if (testf) then begin        
        switch (OverwriteCostModel) begin 
          case 3:
            if (FIFOPerLocation!=0) then begin
              t = nextIHr.WATotCostPerLoc/nextIHr.Qty;
            end else begin
              t = nextIHr.WATotCost/nextIHr.Qty;
            end;
            t = FindWAPriceBackdated(FIFOPerLocation,INr,nextIHr.Location,1,td,false,repcalcwa);
            if (nextIHr.FileName=="RetVc") then begin
              if (CAb.RetFIFOQue!=0) then begin
                remcostprice = nextIHr.Qty*t;
              end else begin
                remcostprice = nextIHr.RemQty*t;
              end;
            end else begin
//              remcostprice = nextIHr.RemQty*t;
              if (nextqty>nextIHr.Qty) then begin
                remcostprice = nextIHr.Qty*t;
              end else begin
                remcostprice = nextqty*t;
              end;
            end;
            if (nextIHr.Qty>0) then begin
              totcostprice = nextIHr.Qty*t;
            end else begin
              totcostprice = nextIHr.Qty*t;
            end;
//StopAlert("totcostprice " & totcostprice & " nextIHr.SerNr " & nextIHr.SerNr);        
            
          case 2:
            remcostprice = FindCostPriceBasePrice(CAb,INr,ITr) * nextIHr.Qty; // nextIHr.BPTotCost; // BPTotCost seems to be blank at all time
            totcostprice = FindCostPriceBasePrice(CAb,INr,ITr) * nextIHr.Qty; // nextIHr.BPTotCost; // BPTotCost seems to be blank at all time
          case 1:
            if (INr.PriceFactor!=0) then begin
              remcostprice = nextIHr.CPTotCost / INr.PriceFactor; //CPTotCost; I don't think CPTotCost is correct....
              totcostprice = nextIHr.CPTotCost / INr.PriceFactor; //CPTotCost; I don't think CPTotCost is correct....
            end else begin
              remcostprice = nextIHr.CPTotCost; //CPTotCost; I don't think CPTotCost is correct....
              totcostprice = nextIHr.CPTotCost; //CPTotCost; I don't think CPTotCost is correct....
            end;
          otherwise
//            remcostprice = nextIHr.RemCostPrice;
            remcostprice = nextIHr.TotCostPrice;
            totcostprice = nextIHr.TotCostPrice;
        end;
        if (costfrrecf) or (ondayratef) then begin
          GetCostsFromRecords(nextIHr,remcostprice,totcostprice,ondayratef,td);
        end;
        if (print==2) then begin
          if (nextqty!=0) then begin
//          if (remcostprice!=0) and (nextqty!=0) then begin// qty can be no zero and price zero
            RecordCopy(printIHr,nextIHr);
            switch (OverwriteCostModel) begin 
              case 3:
                if (nextIHr.FileName=="RetVc") then begin
                  if (CAb.RetFIFOQue!=0) then begin
                    printIHr.RemQty = nextIHr.Qty;
                  end;
                end;
            end;
            printIHr.RemQty = nextqty;
            PrintItemHistLine(printIHr,nextqty * Round((totcostprice / nextIHr.Qty),CostPriceDecimals));
          end;          
        end;
        
        inprice = inprice + nextqty * Round((totcostprice / nextIHr.Qty),CostPriceDecimals);
        printIHr.RemQty = printIHr.RemQty + nextqty;
        end;
      end;
    end;
  end;
  if (print==1) then begin
    if (printIHr.Qty!=0) then begin
//    if (printIHr.TotCostPrice!=0) then begin // qty can be no zero and price zero
      PrintItemHistLine(printIHr,Round(printIHr.TotCostPrice,CostPriceDecimals));
    end;
  end;
LFindCostPriceFIFOBackDated:;  
  res = Round(inprice,CostPriceDecimals);
  FindCostPriceFIFOBackDated = res;
  return;
end;

global
procedure GetCostModel(record INVc INr,record CostAccBlock CAb,var record ITVc ITr,var Integer primary,var Integer queuedcostmodel,Boolean serialprimary)
begin
  Boolean defprimaryf;
  Integer defqueued;
  
  primary = INr.PrimaryCostModel;
  queuedcostmodel = INr.QueuedCostModel;

  if (CAb.ItemGroupCostModel!=0) then begin
    ITr.Code = INr.Group;
    if (ReadFirstMain(ITr,1,true)) then begin
      if (primary==0) then begin primary = ITr.PrimaryCostModel; end;
      if (queuedcostmodel==0) then begin queuedcostmodel = ITr.QueuedCostModel; end;
    end;
  end;
  if (primary==0) then begin
    primary = CAb.PrimaryCostModel;
  end;
  if (primary==0) then begin primary = 9; end;// 9 means none on item and group

  if (queuedcostmodel==0) then begin
    queuedcostmodel = CAb.QueuedCostModel;
  end else begin
    queuedcostmodel = queuedcostmodel - 1;
  end;
  defqueued = queuedcostmodel;
  if (INr.SerNrf>0) then begin
    switch (INr.FIFOPerSerialNr) begin
      case 1: queuedcostmodel = defqueued;
      case 2:
        if (serialprimary) then begin
          primary = 20;
        end;
        queuedcostmodel = 20;
      otherwise
        if (CAb.FIFOPerSerialNr!=0) then begin
          if (serialprimary) then begin
            primary = 20;
          end;
          queuedcostmodel = 20;
        end;
    end;
    if (INr.FIFOPerSerialNr==0) then begin
    if (CAb.ItemGroupCostModel!=0) then begin
      switch (ITr.FIFOPerSerialNr) begin
        case 1: queuedcostmodel = defqueued;
        case 2:
          if (serialprimary) then begin
            primary = 20;
          end;
          queuedcostmodel = 20;
        otherwise
          if (CAb.FIFOPerSerialNr!=0) then begin
            if (serialprimary) then begin
              primary = 20;
            end;
            queuedcostmodel = 20;
          end;
      end;
    end;
    end;
  end;
  return;
end;

global //Edit***************************Sasha2,12:03 18.03.2015 {
function val AddCurValToTrans_FindCostPrice(string artcode,string location,string serialnr,val qty,val adjustqty,Boolean todaysratef,integer rownr,var record IVVc fifocurIVr,var record StockMovVc fifocurSMr,integer recordtype)
begin
  record INVc INr;
  record ITVc ITr;
  Integer primary,queuecostmodel,waperloc;
  record CostAccBlock CAb;
  val res,v;

	logtext(0,"AddCurValToTrans_FindCostPrice");
	
  if (ReadFirstItem(artcode,INr,false,false)) then begin
    BlockLoad(CAb);
    GetCostModel(INr,CAb,ITr,primary,queuecostmodel,true);
    if (INr.ItemType==0) or (INr.ItemType==3) then begin
      switch (primary) begin
        case 1: primary = 1;
        case 2: primary = 2;
        case 3: 
          primary = 3;
          waperloc = 0;
        case 9: 
          primary = 9;
        otherwise 
          primary = 1;
      end;
    end else begin
      waperloc = WAPerLocation(INr,ITr,CAb);
    end;
		if(currentcompany==28 and recordtype==2)then begin //kostyl StockMove idea; 16:49 08.01.2019
			primary = 4;
			queuecostmodel = 0;
		end;
    switch (primary) begin
      case 1: res = qty*INr.InPrice; //CostPricePerLocation(INr,ITr,CAb) 
//      case 1: res = qty*FindCostPriceCostPrice(CostPricePerLocation(INr,ITr,CAb),INr,location);//no alue per location
      case 2: res = qty*FindCostPriceBasePrice(CAb,INr,ITr); 
      case 3:
        v = FindCostPriceWA(waperloc,INr,location);
        if (INr.ItemType!=kItemTypeStocked) then begin
          if (v==0) then begin v = INr.InPrice; end;
        end;
        res = qty*v;
      case 4: 
        switch (queuecostmodel) begin
          case 0: res = AddCurValToTrans_FindCostPriceFIFO(FIFOPerLocation(INr,ITr,CAb),INr,location,serialnr,qty,adjustqty,false,false,todaysratef,0,0,rownr,fifocurIVr,fifocurSMr,recordtype); //Edit***************************Sasha2,12:43 18.03.2015
          case 1: res = FindCostPriceLIFO(FIFOPerLocation(INr,ITr,CAb),INr,location,serialnr,qty,adjustqty,false,false,todaysratef,0,0);
        end;
      case 20: logtext(0,"5");
        //res = FindCostPriceSerial(INr,location,serialnr,qty,adjustqty,false,0);
//adjustqty must be zero for Serial Nr tracking , not sure for Batch nr
        if (qty<0) then begin
          //res = -FindLastCostPriceSerial(INr,location,serialnr,qty,false,0);//here
          res = AddCurValToTrans_FindCostPriceFIFO(FIFOPerLocation(INr,ITr,CAb),INr,location,serialnr,qty,adjustqty,false,false,todaysratef,0,0,rownr,fifocurIVr,fifocurSMr,recordtype); // Edit ************************** BPI Ukraine - KramarAlexandr - Thursday, 30 May 2019 14:05:28
					 logtext(0,"5.1");
        end else begin
          res = FindCostPriceSerial1(INr,location,serialnr,qty,adjustqty,false,0,fifocurIVr,rownr,fifocurSMr,recordtype,FIFOPerLocation(INr,ITr,CAb));
					logtext(0,"5.2");
        end;
    end;
  end;
  if (blank(res)) then begin
    if (qty<0) then begin
//      res = qty*INr.InPrice;
    end;
  end else begin
    if (qty<0) then begin
//      res = -res;//or here
    end;
  end;
  res = Round(res,CostPriceDecimals);
  AddCurValToTrans_FindCostPrice = res;
  RETURN;
END; //Edit***************************Sasha2,12:03 18.03.2015 }

global //Edit***************************Sasha2,12:03 18.03.2015 {
function val ForIV_FindCostPrice(string artcode,string location,string serialnr,val qty,val adjustqty,Boolean todaysratef,integer rownr,var record IVVc fifocurIVr,integer recordtype)
begin
  record StockMovVc fifocurSMr;
  val res;
  	
  	logtext(0,"ForIV_FindCostPrice");
    res = AddCurValToTrans_FindCostPrice(artcode,location,serialnr,qty,adjustqty,todaysratef,rownr,fifocurIVr,fifocurSMr,recordtype);
  
  ForIV_FindCostPrice = res;
  RETURN;
END; //Edit***************************Sasha2,12:03 18.03.2015 }

global //Edit***************************Sasha2,12:03 18.03.2015 {
function val ForSM_FindCostPrice(string artcode,string location,string serialnr,val qty,val adjustqty,Boolean todaysratef,integer rownr,var record StockMovVc fifocurSMr,integer recordtype)
begin
  record IVVc fifocurIVr;
  val res;
  
    res = AddCurValToTrans_FindCostPrice(artcode,location,serialnr,qty,adjustqty,todaysratef,rownr,fifocurIVr,fifocurSMr,recordtype);
  
  ForSM_FindCostPrice = res;
  RETURN;
END; //Edit***************************Sasha2,12:03 18.03.2015 }

global
function val FindCostPrice(string artcode,string location,string serialnr,val qty,val adjustqty,Boolean todaysratef)
begin
  record INVc INr;
  record ITVc ITr;
  Integer primary,queuecostmodel,waperloc;
  record CostAccBlock CAb;
  val res,v;
  
  if (ReadFirstItem(artcode,INr,false,false)) then begin
    BlockLoad(CAb);
    GetCostModel(INr,CAb,ITr,primary,queuecostmodel,true);
    if (INr.ItemType==0) or (INr.ItemType==3) then begin
      switch (primary) begin
        case 1: primary = 1;
        case 2: primary = 2;
        case 3: 
          primary = 3;
          waperloc = 0;
        case 9: 
          primary = 9;
        otherwise 
          primary = 1;
      end;
    end else begin
      waperloc = WAPerLocation(INr,ITr,CAb);
    end;
    switch (primary) begin
      case kCostModelCostPrice: res = qty*INr.InPrice;//CostPricePerLocation(INr,ITr,CAb)
//      case 1: res = qty*FindCostPriceCostPrice(CostPricePerLocation(INr,ITr,CAb),INr,location);//no alue per location
      case kCostModelPctBasePrice: res = qty*FindCostPriceBasePrice(CAb,INr,ITr);
      case kCostModelWA: 
        v = FindCostPriceWA(waperloc,INr,location);
        if (INr.ItemType!=kItemTypeStocked) then begin
          if (v==0) then begin v = INr.InPrice; end;
        end;
        res = qty*v;
      case kCostModelQueued:
        switch (queuecostmodel) begin
          case kQueuedCostModelFIFO: res = FindCostPriceFIFO(FIFOPerLocation(INr,ITr,CAb),INr,location,serialnr,qty,adjustqty,false,false,todaysratef,0,0);
          case kQueuedCostModelLIFO: res = FindCostPriceLIFO(FIFOPerLocation(INr,ITr,CAb),INr,location,serialnr,qty,adjustqty,false,false,todaysratef,0,0);
        end;
      case 20: 
//        res = FindCostPriceSerial(INr,location,serialnr,qty,adjustqty,false,0);
//adjustqty must be zero for Serial Nr tracking , not sure for Batch nr
        if (qty<0) then begin
          res = -FindLastCostPriceSerial(INr,location,serialnr,qty,false,0);//here
        end else begin
          res = FindCostPriceSerial(INr,location,serialnr,qty,0,false,0);
        end;
    end;
  end;
  if (blank(res)) then begin
    if (qty<0) then begin
//      res = qty*INr.InPrice;
    end;
  end else begin
    if (qty<0) then begin
//      res = -res;//or here
    end;
  end;
  res = Round(res,CostPriceDecimals);
  FindCostPrice = res;
  RETURN;
END;

// Returns Cost for ONE item
global
function val FindCPPriceBackdated(Integer CPPerLocation,record INVc INr,string location,val isqtyp,Date todatp,Boolean curncytday)
begin
  val res;
  record ItemHistVc ItemHistr;
  Boolean found,testf;
  Integer keys;
  string 255 ckey;
  Boolean perlocf;
  
  if (blankdate(todatp) or isqtyp<0) then begin
    res = INr.InPrice;
  end else begin
    if (isqtyp==0) then begin
      goto LFindCPPriceBackdated;
    end;
    if (CPPerLocation!=0) and nonblank(location) then begin
      ckey = "ArtCodeLoc";
      keys = 3;
      ItemHistr.Location = location;
      perlocf = true;
    end else begin
      ckey = "ArtCode";
      keys = 2;
      perlocf = false;
    end;
    ItemHistr.ArtCode = INr.Code;
    ItemHistr.TransDate = todatp;
    found = true;
    while (LoopBackKey("ArtCode",ItemHistr,2,found)) begin    
      if (found) then begin
        if (ItemHistr.ArtCode!=INr.Code) then begin found = false; end;
      end; 
      if (perlocf) then begin
        if (ItemHistr.Location!=location) then begin found = false; end;
      end;
      testf = found;
      if (ItemHistr.StockAffectf==0) then begin testf = false; end;
      if (ItemHistr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (ItemHistr.Invalid!=0) then begin testf = false; end;
      if (ItemHistr.Qty<0) then begin testf = false; end;
      if (testf) then begin
        if (perlocf) then begin
          res = ItemHistr.CPTotCostPerLoc; // this value doesn't seem to be correct anywhere... it is only used here, but set in a few places...
        end else begin
          if (INr.PriceFactor!=0) then begin
            res = ItemHistr.CPTotCost / ItemHistr.Qty / INr.PriceFactor;
          end else begin
            res = ItemHistr.CPTotCost / ItemHistr.Qty;
          end;
        end;
        if (res<0) then begin res = -res; end;
        found = false;
      end;
    end;
  end;
LFindCPPriceBackdated:;  
  FindCPPriceBackdated = res;  
  return;
end;

// Returns Cost for one item, and backdated it is COSTPRICE not BP....
global
function val FindBPPriceBackdated(record CostAccBlock CAb,record INVc INr,string location,val isqtyp,Date todatp,Boolean curncytday)
begin
  val res;
  record ItemHistVc ItemHistr;
  Boolean found,testf;
  record ITVc ITr;
  
  if (blankdate(todatp) or isqtyp<0) then begin
    ITr.Code = INr.Group;
    if (ReadFirstMain(ITr,1,true)) then begin
    end;
    res = FindCostPriceBasePrice(CAb,INr,ITr);
  end else begin
    ItemHistr.ArtCode = INr.Code;
    ItemHistr.TransDate = todatp;
    found = true;
    while (LoopBackKey("ArtCode",ItemHistr,2,found)) begin    
      if (found) then begin
        if (ItemHistr.ArtCode!=INr.Code) then begin found = false; end;
      end; 
      testf = found;
      if (ItemHistr.StockAffectf==0) then begin testf = false; end;
      if (ItemHistr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (ItemHistr.Invalid!=0) then begin testf = false; end;
      if (ItemHistr.Qty<0) then begin testf = false; end;
      if (testf) then begin
        if (INr.PriceFactor!=0) then begin
          res = ItemHistr.CPTotCost / ItemHistr.Qty / INr.PriceFactor;
        end else begin
          res = ItemHistr.CPTotCost / ItemHistr.Qty;
        end;
        found = false;
      end;
    end;
  end;
  FindBPPriceBackdated = res;  
  return;
end;

// This isn't used in many places....
global
function val FindCostPriceBackDated(string artcode,string location,string serialnr,val qty,Date td,Boolean ondayratef)
begin
  record INVc INr;
  record ITVc ITr;
  Integer primary,queuecostmodel;
  record CostAccBlock CAb;
  val res;
  val adjustqty;
  
  adjustqty = 0;
  if (ReadFirstItem(artcode,INr,false,false)) then begin
    BlockLoad(CAb);
    GetCostModel(INr,CAb,ITr,primary,queuecostmodel,false);
    switch (primary) begin
      case 1: res = FindCPPriceBackdated(CostPricePerLocation(INr,ITr,CAb),INr,location,qty,td,ondayratef);
      case 2: res = FindBPPriceBackdated(CAb,INr,location,qty,td,ondayratef);
      case 3: res = FindWAPriceBackdated(WAPerLocation(INr,ITr,CAb),INr,location,qty,td,ondayratef,0);
      case 4:
        switch (queuecostmodel) begin
          case 0: res = FindCostPriceFIFOBackDated(FIFOPerLocation(INr,ITr,CAb),INr,location,serialnr,qty,0,td,false,0,ondayratef,0,0,0);
          case 1: res = FindCostPriceLIFOBackDated(FIFOPerLocation(INr,ITr,CAb),INr,location,serialnr,qty,0,td,false,0,ondayratef,0,0,0);
          case 20: res = FindCostPriceFIFOBackDated(FIFOPerLocation(INr,ITr,CAb),INr,location,serialnr,qty,0,td,false,0,ondayratef,0,0,0); // wrong...
        end;
//      case 20: res = FindCostPriceSerialBackDated(FIFOPerLocation(INr,ITr,CAb),INr,location,serialnr,qty,td,false);
    end;
  end;
  res = Round(res,CostPriceDecimals);
  FindCostPriceBackDated = res;
  return;
end;

global
procedure FindAdjstockvQtySHVc(string fnr,record SHVc SHp,string stockartcodep,Integer currow,var val adjstockvp)
BEGIN
  Integer j;
  record SHVc RecSHp;
  row SHVc SHrw;
  Boolean isstruct;
  string 20 locartcode;
  val recqty;

  adjstockvp = blankval;
  if (fnr=="SHVc") then begin
    for (j=0;j<currow;j=j+1) begin
      MatRowGet(SHp,j,SHrw);
      isstruct = ExpandStructItem(SHrw.ArtCode,SHrw.Recepy,SHrw.Ship,RecSHp);
      if (isstruct) then begin
        if (MatRowCnt(RecSHp)!=1) then begin goto LFindAdjstockvQtySHVcSkipRow; end;
        GetStockedItemFromRecepy(RecSHp,locartcode,recqty); 
        if (stockartcodep==locartcode) then begin
          adjstockvp = adjstockvp + recqty;
        end;  
      end;  
LFindAdjstockvQtySHVcSkipRow:;    
    end;  
  end;
  RETURN;
END;

global
procedure CalculateSHRowFIFO(record CostAccBlock CostAccRec,string location,record ORVc ORr,record SHVc SHp,row SHVc SHrw,Integer currow)
BEGIN
  val adjstockv,t,v;
  row SHVc SH2rw;
  Integer j;
  string 10 loc2;
  record INVc INr;
  Boolean testf;
  record SerNrTrackBlock SNrb;
  string 255 serialnr;
  val qty,sum;
  record OrdSettBlock OSb;
  row ORVc ORrw;

  BlockLoad(SNrb);
  BlockLoad(OSb);
  if (ReadFirstItem(SHrw.ArtCode,INr,true,false)) then begin end;
  for (j=0;j<currow;j=j+1) begin  
    MatRowGet(SHp,j,SH2rw);
    testf = true;
    loc2 = SH2rw.Location;
    if (blank(loc2)) then begin
      loc2 = location;
    end;
//    if (TestArtCode(SH2rw.ArtCode,SHrw.ArtCode,INr)) and (location==loc2) then begin
    if (TestArtCode(SH2rw.ArtCode,SHrw.ArtCode,INr)==false) then begin
      testf = false;
    end;
    if (CostAccRec.FIFOPerLocation!=0) then begin
      if (location!=loc2) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      adjstockv = adjstockv + SH2rw.Ship;
    end;
  end;
  if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
    SHrw.FIFORowVal = blankval;
    qty = blankval;
    serialnr = FirstInRange(SHrw.SerialNr,60);
    while (nonblank(serialnr)) begin
      SHrw.FIFORowVal = SHrw.FIFORowVal + FindCostPrice(SHrw.ArtCode,location,serialnr,1.00,adjstockv,false);
      qty = qty + 1;
      adjstockv = adjstockv + 1;
      serialnr = NextSerialNumber(SHrw.ArtCode,serialnr,SNrb);
      if (qty>=SHrw.Ship) then begin serialnr = ""; end;
    end;
  end else begin
    SHrw.FIFORowVal = FindCostPrice(SHrw.ArtCode,location,SHrw.SerialNr,SHrw.Ship,adjstockv,false);
  end;
  SHrw.FIFORowVal = Round(SHrw.FIFORowVal,SetRoundModeD(5));
  SHrw.FIFO = SHrw.FIFORowVal/SHrw.Ship;
  SHrw.FIFO = Round(SHrw.FIFO,SetRoundModeD(5));  
//  SHrw.WAB2 = (INr.WeighedAvPriceB2/INr.WeighedAvPrice)*SHrw.FIFO;
  SHrw.WAB2 = INr.WeighedAvPriceB2;
  if (SHp.OKFlag!=0) then begin
    if (OSb.UpdateGPWhenDel!=0) then begin
      if (SHrw.OrdRow<MatRowCnt(ORr)) then begin
        if (SHrw.FIFORowVal>=0 and SHrw.Ship>0 and SHrw.InStock>0 and SHrw.OrdRow>-1) then begin
          MatRowGet(ORr,SHrw.OrdRow,ORrw);
          v = SHrw.FIFORowVal;
          if (ORrw.PriceFactor!=0) then begin
            v = v*ORrw.PriceFactor;
          end;
          t = v + ORrw.Shipd2*SHrw.BBCostPrice;
          t = t/(SHrw.Ship+ORrw.Shipd2);
          SHrw.BBCostPrice = Round(t,DefaultRoundMode);
        end;
      end;
    end;
  end;
  RETURN;
END;

global
procedure UpdateSHFIFO(record SHVc SHp)
BEGIN
  record MainStockBlock MSb;
  record CostAccBlock CostAccRec;
  record SHVc RecSHr;
  row SHVc SHrw,SH2rw,RecSHrw;
  Integer i,rwcnt;
  Integer j;
  string 10 location,loc2;  
  Boolean isstruct;
  string 20 stockartcode;
  val t,recqty,adjstockv;
  record ORVc ORr;
  
  BlockLoad(CostAccRec);
  location = SHp.Location;
  if (blank(location)) then begin
    BlockLoad(MSb);
    location = MSb.MainStock;
  end;
  ORr.SerNr = SHp.OrderNr;
  ReadFirstMain(ORr,1,true);
  rwcnt = MatRowCnt(SHp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SHp,i,SHrw);
    loc2 = SHrw.Location;
    if (blank(loc2)) then begin
      loc2 = location;
    end;
    if (nonblank(SHrw.ArtCode)) then begin
      if (SHrw.Ship!=0) then begin
        isstruct = ExpandStructItem(SHrw.ArtCode,SHrw.Recepy,SHrw.Ship,RecSHr);
        if (isstruct==false) then begin
          CalculateSHRowFIFO(CostAccRec,loc2,ORr,SHp,SHrw,i);
        end else begin
          adjstockv = blankval;
          SHrw.FIFORowVal = blankval;
          if (MatRowCnt(RecSHr)!=1) then begin goto L88UpdateSHFIFOSkipRow; end;
//same as in  FindAdjstockvQtySHVc       
//          if (MatRowCnt(RecSHr)==0) then begin goto L88UpdateSHFIFOSkipRow; end;
          GetStockedItemFromRecepy(RecSHr,stockartcode,recqty);
          FindAdjstockvQtySHVc("SHVc",SHp,stockartcode,i,adjstockv);  
          SHrw.FIFORowVal = FindCostPrice(stockartcode,loc2,"",recqty,adjstockv,false);
          SHrw.FIFORowVal = Round(SHrw.FIFORowVal,SetRoundModeD(5));          
          SHrw.FIFO = SHrw.FIFORowVal/recqty;
          SHrw.FIFO = Round(SHrw.FIFO,SetRoundModeD(5));
        end;  
      end else begin
        SHrw.FIFO = blankval;
        SHrw.FIFORowVal = blankval;
      end;
      MatRowPut(SHp,i,SHrw);
    end;
L88UpdateSHFIFOSkipRow:;    
  end;
  RETURN;
END;

// Function safe, very few reads.
function Boolean FindDestinationFIFO(record MainStockBlock MSb,record CostAccBlock CAb,record INVc INr,record ITVc ITr,string location,string serialnr,var record ItemHistVc destIHr)
begin
  Boolean res;
  string 200 thekey;
  Integer keys;
  Boolean foundf;
  
  res = false;
  destIHr.ArtCode = INr.Code;
  destIHr.Location = location;
//  if (FIFOPerLocation(INr,ITr,CAb)==0) then begin
  if (ItemCostPerLocation(INr)==0) then begin//must be same as in FindSourceFIFO otherwise we look here in all locations and in  FindSourceFIFO 1 location
    thekey = "ActiveQty";
    keys = 1;
  end else begin
    thekey = "ActiveLocQty";
    keys = 2;
  end;
  ResetLoop(destIHr);
  foundf = true;
  while (LoopKey(thekey,destIHr,keys,foundf)) begin
    if (destIHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==2) then begin
      if (destIHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (foundf) then begin
      if (destIHr.Qty<0) then begin
        res = true;
        goto LFindDestinationFIFO;
      end else begin
        res = false;
        goto LFindDestinationFIFO;
      end;
    end;
  end;
LFindDestinationFIFO:;
  FindDestinationFIFO = res;
  RETURN;
END;

updating procedure UpdateItemHistory_In_OverDelivered(record MainStockBlock MSb,record CostAccBlock CAb,record ItemHistVc inIHr,record INVc INr,record ITVc ITr)
begin
  record ItemHistVc destinationIHr;
  record ItemHistVc oldIHr;
  val rem,useqty,totuseqty;
  Boolean foundf;
  
  rem = inIHr.Qty;
  while (rem>0) begin
    foundf = FindDestinationFIFO(MSb,CAb,INr,ITr,inIHr.Location,inIHr.SerialNr,destinationIHr);
    if (foundf) then begin
      RecordCopy(oldIHr,destinationIHr);
    end;
    destinationIHr.RemQty = -destinationIHr.RemQty;
    if (foundf) then begin
      if (rem>destinationIHr.RemQty) then begin
        useqty = destinationIHr.RemQty;
      end else begin
        useqty = rem;
      end;
    end else begin
      useqty = rem;
    end;
    if (foundf) then begin
      destinationIHr.Source = inIHr.SerNr;
      destinationIHr.RemQty = -(destinationIHr.RemQty - useqty);
      destinationIHr.CurncyCode = inIHr.CurncyCode;// Edit ************************** Monday, 12 May 2014 14:07:04
      destinationIHr.InDate = inIHr.InDate;// Edit ************************** Monday, 30 March 2015 10:33:38
      destinationIHr.InFileName = inIHr.InFileName;// Edit ************************** Monday, 30 March 2015 10:33:39
      destinationIHr.RemCostPriceCurncy = inIHr.TotCostPriceCurncy/inIHr.Qty*-destinationIHr.RemQty;// Edit ************************** Monday, 12 May 2014 10:32:08    
      destinationIHr.TotCostPriceCurncy = inIHr.TotCostPriceCurncy/inIHr.Qty*-destinationIHr.Qty;// Edit ************************** Monday, 12 May 2014 10:32:08  
			logtext(0,destinationIHr.TotCostPriceCurncy & " TotCostPriceCurncy");
      if (RecordUpdate(oldIHr,destinationIHr,false)==0) then begin end;
      totuseqty = totuseqty + useqty;
    end;
    rem = rem - useqty;
  end;
  if (totuseqty!=0) then begin
    RecordCopy(oldIHr,inIHr);
    inIHr.RemQty = inIHr.RemQty - totuseqty;
    inIHr.RemCostPrice = inIHr.RemCostPrice - (inIHr.TotCostPrice/inIHr.Qty)*totuseqty;
    inIHr.RemCostPriceCurncy = inIHr.RemCostPriceCurncy - inIHr.TotCostPriceCurncy/inIHr.Qty * totuseqty;// Edit ************************** Monday, 12 May 2014 10:32:08    
    logtext(0,inIHr.TotCostPriceCurncy & " TotCostPriceCurncy 2");
		if (RecordUpdate(oldIHr,inIHr,false)==0) then begin end;
  end;
  return;
end;

global
procedure FindTempStockRow(LongInt rownr,string artcode,Boolean matchartcodef,record TempStockVc TSr,var row TempStockVc resTSrw)
begin
  row TempStockVc TSrw;
  Integer i,rwcnt;
  Boolean testf;
  
  ClearRow(TSr,resTSrw,1);
  rwcnt = MatRowCnt(TSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(TSr,i,TSrw);
    testf = true;
    if (TSrw.Row!=rownr) then begin testf = false; end;
    if (matchartcodef) then begin
      if (TSrw.ArtCode!=Left(artcode,len(TSrw.ArtCode))) then begin testf = false; end;
    end;    
    if (testf) then begin
      CopyRow(TSr,TSrw,resTSrw);
      i = rwcnt;
    end;
  end;
  return;
end;

global
updating procedure StoreItemHistory_In(record MainStockBlock MSb,string artcode,string serialnr,string location,string filename,Date td,Date fifod,val qty,val coeff,val totalcost,LongInt transnr,Integer rownr,Integer stockaffectf,string position,string vecode,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record ItemHistVc IHr;
  record INVc INr;
  record ITVc ITr;
  record CostAccBlock CAb;
  Integer primary,queuecostmodel;
  val t;
  Boolean setremqty;
  Date blankd;
  row TempStockVc TSrw;
  record ItemHistVc oldIHr; // Edit ************************** Monday, 12 May 2014 10:02:25
  record PUVc PUr;// Edit ************************** Monday, 12 May 2014 10:02:25
  row PUVc PUrw;// Edit ************************** Monday, 12 May 2014 10:02:38
  record IVVc IVr; // Edit ************************** Thursday, 15 May 2014 11:40:43
  row IVVc IVrw; // Edit ************************** Thursday, 15 May 2014 11:40:43
  val totcostpricecurncy;// Edit ************************** Monday, 12 May 2014 10:15:03
  string 5 curncy;// Edit ************************** Monday, 12 May 2014 10:15:03
  record ItemHistVc sourceIHr;// Edit ************************** Thursday, 15 May 2014 11:40:48
  record BaseCurBlock BCb;// Edit ************************** Thursday, 15 May 2014 11:40:51
  record RetVc Retr;// Edit ************************** Thursday, 15 May 2014 11:40:45
  row RetVc Retrw;// Edit ************************** Thursday, 15 May 2014 11:40:43
  date indate; // Edit ************************** Thursday, 15 May 2014 11:40:43
  string 20 infile; // Edit ************************** Thursday, 15 May 2014 11:40:43
  val qty1; // Edit ************************** Thursday, 15 May 2014 11:40:43
  boolean findfcurcost,TrHs,testf; // Edit ************************** Thursday, 15 May 2014 11:40:43
  
  blockload(BCb); // Edit ************************** Thursday, 15 May 2014 11:40:43
	
	
  if (blank(artcode)) then begin 
    goto LStoreItemHistory_In;
  end;
  BlockLoad(CAb);  
  RecordNew(IHr);
  setremqty = true;
  IHr.ArtCode = artcode;
  IHr.Variety = "";
  IHr.StockAffectf = stockaffectf;
  if (ReadFirstItem(artcode,INr,false,false)) then begin
    if (artcode!=INr.Code) then begin
      IHr.Variety = right(artcode,len(artcode)-len(INr.Code));
      IHr.ArtCode = INr.Code;
    end;
    switch (INr.ItemType) begin
      case kItemTypePlain:
        switch (filename) begin
          case "SHVc": ;
          otherwise 
            IHr.StockAffectf = 0;
        end;
        setremqty = false;
      case kItemTypeStocked: 
        if (IHr.StockAffectf==0) then begin
          setremqty = false;
        end;
      case kItemTypeStructured:
        if (nonblank(INr.Recepy)) then begin
          IHr.StockAffectf = 0;
        end;
      case kItemTypeService:
        IHr.StockAffectf = 0;
        setremqty = false;
    end;
  end;
  IHr.SerialNr = serialnr;
  IHr.Location = location;
  IHr.FileName = filename;
  IHr.TransDate = td;
  IHr.FIFODate = fifod;
  IHr.Qty = qty;
  IHr.Qty2 = CalculateQty2(IHr.Qty,coeff);
  IHr.TransNr = transnr;
  IHr.Row = rownr;
  if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)) then begin
    IHr.ConsigStock = 1;
  end;
  if (TREOStock(IHr.ArtCode,IHr.SerialNr,blankd)) then begin
    IHr.TREOStock = 1;
  end;
  if (setremqty) then begin
    IHr.RemQty = qty;
  end else begin
    IHr.RemQty = blankval;
  end;
  IHr.Source = -1;
  IHr.TotCostPrice = totalcost;
  IHr.RemCostPrice = totalcost; 
  // Edit Start ---------------------------------------------- Edit Start
	//Monday, 12 May 2014 10:01:51
	infile = "";
	indate = IHr.TransDate;
  switch(filename)begin
  	case "PUVc":	PUr.SerNr = transnr;
  								readfirstmain(PUr,1,true);
  								matrowget(PUr,IHr.Row,PUrw);
  								curncy = PUr.CurncyCode;
  								infile = filename;
  								indate = IHr.TransDate;
  								if(blank(curncy))then begin
  									curncy = BCb.BaseCur1;
  								end;
  								totcostpricecurncy = PUrw.UPrice * PUrw.Quant;
		case	"IVVc":	IVr.SerNr = transnr;
  								readfirstmain(IVr,1,true);
  								If(IVr.Invalid>0)then begin
  									sourceIHr.FileName = "IVVc";
  									sourceIHr.TransNr = IVr.SerNr;
  									sourceIHr.Row = IHr.Row;
  									Readlastkey("FNTransNr",sourceIHr,3,true);
  									curncy = sourceIHr.CurncyCode;
										indate = sourceIHr.InDate;
										infile = sourceIHr.InFileName;
										totcostpricecurncy = sourceIHr.TotCostPriceCurncy;
  								end else begin
  								  matrowget(IVr,IHr.Row,IVrw);
										curncy = INr.LastPurchCurncyCode;
										if (IVrw.Quant<0) then begin //Edit-------------------Vitalii 13:18 15.01.2016
										  if (IVrw.FIFOCur>0) then begin //Edit***************************Sasha2,12:47 20.05.2016 {
										    totcostpricecurncy = AbsoluteVal(IVrw.FIFOCur*IVrw.Quant);
										    curncy = IVrw.CurncyCodeCur;
										    findfcurcost = true;
										  end else begin //Edit***************************Sasha2,12:47 20.05.2016 }
  										  //totcostpricecurncy = IVrw.FIFO * IHr.Qty;
  										  oldIHr.ArtCode = artcode;
  										  oldIHr.FileName = "IVVc";
  										  qty1 = IVrw.Quant;
  										  ResetLoop(oldIHr);
  										  TrHs = true;
  										  findfcurcost = false;
  										  while (LoopBackKey("FNArtCode",oldIHr,2,TrHs)) begin
                          if (oldIHr.ArtCode<>artcode) then begin TrHs = false; end;
                          if (qty1>=0) then begin TrHs = false; end;
                          if (TrHs) then begin
                            testf = true;
                            if (oldIHr.FileName<>"IVVc") then begin testf = false; end;
                            if (oldIHr.StockAffectf==0) then begin testf = false; end;
                            //if (oldIHr.Qty>0) then begin testf = false; end;
                            if (oldIHr.Location<>location) then begin testf = false; end;
                            if (oldIHr.TransNr>transnr) then begin testf = false; end;
                            if (testf) then begin
                              if (oldIHr.Qty<qty1) then begin
                                totcostpricecurncy = totcostpricecurncy + oldIHr.TotCostPriceCurncy/oldIHr.Qty*qty1;
                                findfcurcost = true;
                                qty1 = 0;
                              end else begin
                                if (oldIHr.Qty>0) then begin
                                  totcostpricecurncy = totcostpricecurncy - oldIHr.TotCostPriceCurncy;
                                  findfcurcost = true;
                                end else begin
                                  totcostpricecurncy = totcostpricecurncy + oldIHr.TotCostPriceCurncy;
                                  findfcurcost = true;
                                end;
                                qty1 = qty1 - oldIHr.Qty;
                              end;
                              if (qty1==0) then begin
                                TrHs = false;
                              end;
                            end;
                          end;
  										  end;  
										  end;
										  
										  if (totcostpricecurncy<0) then begin // for case if there are no positive invoices (with qty>0). Just negative invoices (with qty<0).
										    findfcurcost = false;
										  end;
										  
										  if(findfcurcost==false)then begin
										  	totcostpricecurncy = INr.LastPurchPrice2 * IHr.Qty;
										  end;
										end else begin
										  totcostpricecurncy = INr.LastPurchPrice2 * IHr.Qty;
										end; 
										infile = filename;
										indate = IHr.TransDate;
  								end;
  	case	"StockMovVc":	if(IHr.Qty>=0)then begin
  												sourceIHr.FileName = "StockMovVc";
  												sourceIHr.TransNr = IHr.TransNr;
  												sourceIHr.Row = IHr.Row;
  												readlastkey("FNTransNr",sourceIHr,3,false);
													curncy = sourceIHr.CurncyCode;
													indate = sourceIHr.InDate;
  												infile = sourceIHr.InFileName;
													totcostpricecurncy = sourceIHr.TotCostPriceCurncy;
  											end;
  	case	"RetVc":	if(IHr.Qty>=0)then begin
  												Retr.SerNr = IHr.TransNr;
  												readfirstmain(Retr,1,true);
													matrowget(Retr,IHr.Row,Retrw);
													//sourceIHr.ArtCode = IHr.ArtCode;
													sourceIHr.FileName = "SHVc";
													sourceIHr.Row = Retrw.SHRow;
													sourceIHr.TransNr = Retr.SHNr;
													readfirstkey("FNTransNr",sourceIHr,3,true);
													curncy = sourceIHr.CurncyCode;
													indate = sourceIHr.InDate;
  												infile = sourceIHr.InFileName;
													totcostpricecurncy = sourceIHr.TotCostPriceCurncy/-sourceIHr.Qty*IHr.Qty;
													logtext(0,totcostpricecurncy & " totcostpricecurncy 123");
  											end;
  end;
  IHr.CurncyCode = curncy;
  IHr.InDate = indate;// Edit ************************** Monday, 30 March 2015 10:21:18
  IHr.InFileName = infile;// Edit ************************** Monday, 30 March 2015 10:21:17
  IHr.TotCostPriceCurncy = totcostpricecurncy;
  IHr.RemCostPriceCurncy = totcostpricecurncy; 
  // Edit End ---------------------------------------------- Edit End
  
  ITr.Code = INr.Group;
  if (ReadFirstMain(ITr,1,true)) then begin
  end;
  if (usetmpstkf) then begin
    FindTempStockRow(IHr.Row,IHr.ArtCode,true,TSr,TSrw);
    IHr.PrimaryCostModel = TSrw.PrimaryCostModel;
    IHr.QueuedCostModel = TSrw.QueuedCostModel;
    IHr.ItemType = TSrw.ItemType;
    IHr.FIFOPerSerialNr = TSrw.FIFOPerSerialNr;
    IHr.FIFOPerLocation = TSrw.FIFOPerLocation;
    IHr.NoNLCostOnShip = TSrw.NoNLCostOnShip;
    IHr.WAPerLocation = TSrw.WAPerLocation;
    IHr.WABase2 = TSrw.WABase2;
    IHr.UpdWeightAvFromRet = TSrw.UpdWeightAvFromRet;
    IHr.UpdWeightAvFromRetPU = TSrw.UpdWeightAvFromRetPU;
    IHr.StockAffectf = TSrw.StockAffectf;
  end else begin
    GetCostModel(INr,CAb,ITr,primary,queuecostmodel,false);
    IHr.PrimaryCostModel = primary;
    IHr.QueuedCostModel = queuecostmodel;
    IHr.ItemType = INr.ItemType;
    IHr.FIFOPerSerialNr = GetFIFOPerSerialNr(INr,ITr,CAb);
    IHr.FIFOPerLocation = FIFOPerLocation(INr,ITr,CAb);
    IHr.NoNLCostOnShip = CAb.NoNLCostOnShip;
    IHr.WAPerLocation = WAPerLocation(INr,ITr,CAb);
    IHr.WABase2 = CAb.WABase2;
    IHr.UpdWeightAvFromRet = CAb.UpdWeightAvFromRet;
    IHr.UpdWeightAvFromRetPU = CAb.UpdWeightAvFromRetPU;
  end;

  IHr.WATotCost = IHr.Qty*INr.WeighedAvPrice;

  IHr.WATotCostPerLoc = IHr.Qty*FindCostPriceWA(1,INr,location);
  IHr.CPTotCost = IHr.Qty*INr.InPrice;
  CalcCostPrice(IHr.Qty,INr.InPrice,INr.PriceFactor,0,100,t,IHr.CPTotCost);
//  IHr.CPTotCostPerLoc = IHr.Qty*;
  IHr.BPTotCost = IHr.Qty*FindCostPriceBasePrice(CAb,INr,ITr);
//  IHr.BPTotCostPerLoc = IHr.Qty*;
  IHr.Position = position;
/*  this may not be right
  switch (primary) begin
    case 1:
     IHr.CPTotCost = totalcost;
//     IHr.CPTotCostPerLoc = totalcost;
    case 2:
     IHr.BPTotCost = totalcost;
//     IHr.BPTotCostPerLoc = totalcost;
    case 3:
     IHr.WATotCost = totalcost;
     IHr.WATotCostPerLoc = totalcost;
  end;
*/

  IHr.SerNr = NextSerNr("ItemHistVc",IHr.TransDate,-1,false,"");
  if (RecordStore(IHr,false)) then begin end;
  if (IHr.StockAffectf!=0) then begin
    UpdateItemHistory_In_OverDelivered(MSb,CAb,IHr,INr,ITr);
  end;
LStoreItemHistory_In:;
  return;
end;


//server-only
external function string 60 AddObjectToObjectList(string,string);
external procedure NextM4SerialNumber(string,var string);
external procedure ExtractObj(string,var Integer,var string);
external procedure NormalizeObjstr(var string);
external function boolean CompanyIsJWLikeCompany(Integer);
external function string 255 StrReplace(string,string,string);
remote updating procedure CreatePOfromCCSH(record SHVc);
external function Boolean VIVc_PasteVECode(var record VIVc,Integer,Boolean,Boolean,var string);
external function Boolean GetAccName(string,var string,Integer);
external procedure ExtractObj(string,var Integer,var string);
external procedure ExtractObjectsByType(string, string, var array string, var integer);
remote procedure VICalcVals(var record VIVc);
external procedure VISumup(record VIVc,var val);
external procedure VIVc_PastePayVal(var record VIVc);
//external procedure MyExtractObj(string,var Integer,var string);
 external function val AbsoluteVal(val);
remote updating procedure CreateNewGlobalItem(var record INVc);
external function roundmode SetRoundModeD(Integer);
external updating procedure DeleteTransaction(LongInt,Integer);
external procedure TRSumup(var record TRVc,var val);
external function string 60 RemoveObjectFromObjectList(string,string);


SetLangMode(LangRussian,"RUS",0);

global updating function LongInt CheckClassifGlblImprt(array string headers,array string params,var record INVc INr)
begin

	LongInt res;
  row NewINVc newINrw;
	record INVc OldINr,tmpINr,OldConsINr;
	record NewINVc OthCompnewINr;
  record INVc IN2r,INConsr,IN3r;
	record NewINVc newINr2;
  record ITVc ITr;
  integer mtrw,i,insertmode,updatemode,j; //Edit***************************Sasha2,17:50 07.12.2015
  string 20 codestring;
	string 100 lastSerNr,newSerNr;
  LongInt stat1,long41;
  string 200 rawclass,uloc,group;
  integer pos,rwcnt, t,tcnt,oldComp,CompQty,k;
  record DIVc DIr;
  boolean upd,insertDispNameNotCode,TrHs,TrHs1,testf;
  record DiCheckBlock DiCb; //Edit***************************Sasha2,16:52 07.12.2015
  row DiCheckBlock DiCbw; //Edit***************************Sasha2,16:52 07.12.2015
  vector string 255 diCheckTypes; //Edit***************************Sasha2,17:22 07.12.2015
  string 255 newdispstr,foundtypes,outdisps,mes; //Edit***************************Sasha2,17:37 07.12.2015
  string 20 type; //Edit***************************Sasha2,10:34 08.12.2015
  boolean NewValidClassif;
	record NewClassSetVc NCSr;
	row NewClassSetVc NCSrw;
	record BPIBrandVc Brandr;
	record BPICollectionVc Collectr;
	record BPIGroupVc Groupr;
	record BPISubGroupVc SGroupr;
	vector string 255 vclassification, vclassificationfield;
	vector boolean vclasstipecode, AllSetTypes;
	record NewClassifChBlock NCCHb;	
	array string 100 aTipeClass;
	record BPICategoryVc BPICategoryr;
	record BPIMaterialVc BPIMaterialr;
	record BPIColorVc BPIColorr;
	record BPIShapeVc BPIShaper;
	record BPISizeVc BPISizer;
	record BPIUseVc BPIUser;
	record BPISexVc BPISexr;
	record BPIPlatingVc BPIPlatingr;
	record BPIClarityVc BPIClarityr;
	record BPIWeightVc BPIWeightr;
	record BPICutVc BPICutr;
	record BPIStoneVc BPIStoner;
	record BPIStrapVc BPIStrapr;
	record BPIOdourVc BPIOdourr;
	record ConsCompBlock CCB;
	record CompaniesBlock Compb;
	row CompaniesBlock Comprw;
	Array string 255 astr;
  Integer acnt,strlen,y;
	record IdINSNOneBlock IINSNOb;
	row IdINSNOneBlock IINSNOrw;
	string 255 SNOneNumber, param;
	val SNMiddleval;
	boolean Catef,TrHs2;
	array string 100 asnt;
	integer check,curcomp;
	record ConsItemVc ConsIr,CIr;



	
	for (i=0;i<headers.length;i=i+1) begin
		param = headers[i];
		params[i] = trim(params[i]);
		if(nonblank(params[i]))then begin
			switch(param)begin
				case"Collection": 	
													Collectr.Name = params[i];
													if(ReadFirstKey("Name",Collectr,1,true))then begin
														INr.BPICollection = Collectr.Code;
													end else begin
														res = 1;
													end;
				case"Group":
													Groupr.Name = params[i];
													if(ReadFirstKey("Name",Groupr,1,true))then begin
														INr.BPIGroup = Groupr.Code;
													end else begin
														res = 2;
													end;
				case"Sub-Group":
													SGroupr.Name = params[i];
													if(ReadFirstKey("Name",SGroupr,1,true))then begin
														INr.BPISubGroup = SGroupr.Code;
													end else begin
														res = 3;
													end;
				case"Category":
													BPICategoryr.Name = params[i];
													if(ReadFirstKey("Name",BPICategoryr,1,true))then begin
														INr.BPICategory = BPICategoryr.Code;
													end else begin
														res = 4;
													end;
				case"Material":
													BPIMaterialr.Name = params[i];
													if(ReadFirstKey("Name",BPIMaterialr,1,true))then begin
														INr.BPIMaterial = BPIMaterialr.Code;
													end else begin
														res = 5;
													end;
				case"Color":
													BPIColorr.Name = params[i];
													if(ReadFirstKey("Name",BPIColorr,1,true))then begin
														INr.BPIColor = BPIColorr.Code;
													end else begin
														res = 1;
													end;
				case"Shape":
													BPIShaper.Name = params[i];
													if(ReadFirstKey("Name",BPIShaper,1,true))then begin
														INr.BPIShape = BPIShaper.Code;
													end else begin
														res = 6;
													end;
				case"Size":
													BPISizer.Name = params[i];
													if(ReadFirstKey("Name",BPISizer,1,true))then begin
														INr.BPISize = BPISizer.Code;
													end else begin
														res = 1;
													end;
				case"Use":
													BPIUser.Name = params[i];
													if(ReadFirstKey("Name",BPIUser,1,true))then begin
														INr.BPIUse = BPIUser.Code;
													end else begin
														res = 7;
													end;
				case"Gender":
													BPISexr.Name = params[i];
													if(ReadFirstKey("Name",BPISexr,1,true))then begin
														INr.BPISex = BPISexr.Code;
													end else begin
														res = 8;
													end;
				case"Plating":
													BPIPlatingr.Name = params[i];
													if(ReadFirstKey("Name",BPIPlatingr,1,true))then begin
														INr.BPIPlating = BPIPlatingr.Code;
													end else begin
														
													end;
				case"Weight":
													BPIWeightr.Name = params[i];
													if(ReadFirstKey("Name",BPIWeightr,1,true))then begin
														INr.BPIWeight = BPIWeightr.Code;
													end else begin
														res = 9;
													end;
				case"Cut1":
													BPICutr.Name = params[i];
													if(ReadFirstKey("Name",BPICutr,1,true))then begin
														INr.BPICut = BPICutr.Code;
													end else begin
														res = 10;
													end;
				case"Stone1":
													BPIStoner.Name = params[i];
													if(ReadFirstKey("Name",BPIStoner,1,true))then begin
														INr.BPIStone = BPIStoner.Code;
													end else begin
														res = 11;
													end;
				case"Strap Material":
													BPIStrapr.Name = params[i];
													if(ReadFirstKey("Name",BPIStrapr,1,true))then begin
														INr.BPIStrap = BPIStrapr.Code;
													end else begin
														res = 12;
													end;
				case"Odour":
													BPIOdourr.Name = params[i];
													if(ReadFirstKey("Name",BPIOdourr,1,true))then begin
														INr.BPIOdour = BPIOdourr.Code;
													end else begin
														res = 13;
													end;
				case"Clarity1":
													BPIClarityr.Name = params[i];
													if(ReadFirstKey("Name",BPIClarityr,1,true))then begin
														INr.BPIClarity = BPIClarityr.Code;
													end else begin
														res = 14;
													end;
			end;
		end;
	end;
	
	
	
	t = 0;
	vclassification["BRAND"] = INr.BPIBrand;
	Brandr.Code = INr.BPIBrand;
	if(nonblank(Brandr.Code) and !readfirstmain(Brandr,1,true))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: BRAND",i,"BrandSC");
		// goto LNewINVcRecordCheck;
	end;
	if(nonblank(Brandr.Code) and Brandr.Closed!=0)then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification["BRAND"] & " Закрыта: BRAND",i,"BrandSC");
		// goto LNewINVcRecordCheck;
	end;
	aTipeClass[t] = "CATEGORY";
	vclassificationfield[aTipeClass[t]] = "Category";
	vclassification["CATEGORY"] = INr.BPICategory;
	BPICategoryr.Code = INr.BPICategory;
	if(nonblank(BPICategoryr.Code) and !readfirstmain(BPICategoryr,1,true) and (INr.ConsgType!=3 and INr.ConsgType!=4))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: CATEGORY",i,"classif31");
		// goto LNewINVcRecordCheck;
	end;
	aTipeClass[t+=1] = "CLARITY";
	vclassificationfield[aTipeClass[t]] = "Clarity1";
	vclassification["CLARITY"] = INr.BPIClarity;
	BPIClarityr.Code = INr.BPIClarity;
	if(nonblank(BPIClarityr.Code) and !readfirstmain(BPIClarityr,1,true) and (INr.ConsgType!=3 and INr.ConsgType!=4))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: CLARITY",i,"ClaritySC");
		// goto LNewINVcRecordCheck;
	end;
	aTipeClass[t+=1] = "COLLECT";
	vclassification["COLLECT"] = INr.BPICollection;
	Collectr.Code = INr.BPICollection;
	if(nonblank(Collectr.Code) and !readfirstmain(Collectr,1,true) and (INr.ConsgType!=3 and INr.ConsgType!=4))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: COLLECT",i,"Collection");
		// goto LNewINVcRecordCheck;
	end;
	aTipeClass[t+=1] = "COLOR";
	vclassificationfield[aTipeClass[t]] = "Color";
	vclassification["COLOR"] = INr.BPIColor;
	BPIColorr.Code = INr.BPIColor;
	if(nonblank(BPIColorr.Code) and !readfirstmain(BPIColorr,1,true) and (INr.ConsgType!=3 and INr.ConsgType!=4))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: COLOR",i,"Color");
		// goto LNewINVcRecordCheck;
	end;
	aTipeClass[t+=1] = "CUT";
	vclassificationfield[aTipeClass[t]] = "Cut1";
	vclassification["CUT"] = INr.BPICut;
	BPICutr.Code = INr.BPICut;
	if(nonblank(BPICutr.Code) and !readfirstmain(BPICutr,1,true) and (INr.ConsgType!=3 and INr.ConsgType!=4))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: CUT",i,"CutCl");
		// goto LNewINVcRecordCheck;
	end;
	aTipeClass[t+=1] = "GROUP";
	vclassification["GROUP"] = INr.BPIGroup;
	Groupr.Code = INr.BPIGroup;
	if(nonblank(Groupr.Code) and !readfirstmain(Groupr,1,true))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: GROUP",i,"GroupCl");
		// goto LNewINVcRecordCheck;
	end;
	aTipeClass[t+=1] = "MATERIAL";
	vclassificationfield[aTipeClass[t]] = "Material";
	vclassification["MATERIAL"] = INr.BPIMaterial;
	BPIMaterialr.Code = INr.BPIMaterial;
	if(nonblank(BPIMaterialr.Code) and !readfirstmain(BPIMaterialr,1,true) and (INr.ConsgType!=3 and INr.ConsgType!=4))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: MATERIAL",i,"Material");
		// goto LNewINVcRecordCheck;
	end;
	aTipeClass[t+=1] = "ODOUR";
	vclassificationfield[aTipeClass[t]] = "Odour";
	vclassification["ODOUR"] = INr.BPIOdour;
	BPIOdourr.Code = INr.BPIOdour;
	if(nonblank(BPIOdourr.Code) and !readfirstmain(BPIOdourr,1,true) and (INr.ConsgType!=3 and INr.ConsgType!=4))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: ODOUR",i,"OdourCl");
		// goto LNewINVcRecordCheck;
	end;
	aTipeClass[t+=1] = "PLATING";
	vclassificationfield[aTipeClass[t]] = "Plating";
	vclassification["PLATING"] = INr.BPIPlating;
	BPIPlatingr.Code = INr.BPIPlating;
	if(nonblank(BPIPlatingr.Code) and !readfirstmain(BPIPlatingr,1,true) and (INr.ConsgType!=3 and INr.ConsgType!=4))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: PLATING",i,"PlatingCl");
		// goto LNewINVcRecordCheck;
	end;
	aTipeClass[t+=1] = "SEX";
	vclassificationfield[aTipeClass[t]] = "Gender";
	vclassification["SEX"] = INr.BPISex;
	BPISexr.Code = INr.BPISex;
	if(nonblank(BPISexr.Code) and !readfirstmain(BPISexr,1,true) and (INr.ConsgType!=3 and INr.ConsgType!=4))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: SEX",i,"SexCl");
		// goto LNewINVcRecordCheck;
	end;
	aTipeClass[t+=1] = "SHAPE";
	vclassificationfield[aTipeClass[t]] = "Shape";
	vclassification["SHAPE"] = INr.BPIShape;
	BPIShaper.Code = INr.BPIShape;
	if(nonblank(BPIShaper.Code) and !readfirstmain(BPIShaper,1,true) and (INr.ConsgType!=3 and INr.ConsgType!=4))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: SHAPE",i,"ShapeCut");
		// goto LNewINVcRecordCheck;
	end;
	aTipeClass[t+=1] = "SIZE";
	vclassificationfield[aTipeClass[t]] = "Size";
	vclassification["SIZE"] = INr.BPISize;
	BPISizer.Code = INr.BPISize;
	if(nonblank(BPISizer.Code) and !readfirstmain(BPISizer,1,true) and (INr.ConsgType!=3 and INr.ConsgType!=4))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: SIZE",i,"SizeCl");
		// goto LNewINVcRecordCheck;
	end;
	aTipeClass[t+=1] = "STRAP";
	vclassificationfield[aTipeClass[t]] = "Strap Material";
	vclassification["STRAP"] = INr.BPIStrap;
	BPIStrapr.Code = INr.BPIStrap;
	if(nonblank(BPIStrapr.Code) and !readfirstmain(BPIStrapr,1,true) and (INr.ConsgType!=3 and INr.ConsgType!=4))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: STRAP",i,"Strap");
		// goto LNewINVcRecordCheck;
	end;
	aTipeClass[t+=1] = "STONE";
	vclassificationfield[aTipeClass[t]] = "Stone1";
	vclassification["STONE"] = INr.BPIStone;
	BPIStoner.Code = INr.BPIStone;
	if(nonblank(BPIStoner.Code) and !readfirstmain(BPIStoner,1,true) and (INr.ConsgType!=3 and INr.ConsgType!=4))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: STONE",i,"StoneCl");
		// goto LNewINVcRecordCheck;
	end;
	aTipeClass[t+=1] = "WEIGHT";
	vclassificationfield[aTipeClass[t]] = "Weight";
	vclassification["WEIGHT"] = INr.BPIWeight;
	BPIWeightr.Code = INr.BPIWeight;
	if(nonblank(BPIWeightr.Code) and !readfirstmain(BPIWeightr,1,true) and (INr.ConsgType!=3 and INr.ConsgType!=4))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: WEIGHT",i,"WeightCl");
		// goto LNewINVcRecordCheck;
	end;
	//aTipeClass[t+=1] = "SUBGROUP";
	vclassificationfield[aTipeClass[t]] = "Sub-Group";
	vclassification["SUBGROUP"] = INr.BPISubGroup;
	SGroupr.Code = INr.BPISubGroup;
	if(nonblank(SGroupr.Code) and !readfirstmain(SGroupr,1,true))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: SUBGROUP",i,"SubGroupCl");
		// goto LNewINVcRecordCheck;
	end;
	aTipeClass[t+=1] = "USE";
	vclassificationfield[aTipeClass[t]] = "Use";
	vclassification["USE"] = INr.BPIUse;
	BPIUser.Code = INr.BPIUse;
	if(nonblank(BPIUser.Code) and !readfirstmain(BPIUser,1,true) and (INr.ConsgType!=3 and INr.ConsgType!=4))then begin
		// res = -1;
		// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа классификации: USE",i,"UseCl");
		// goto LNewINVcRecordCheck;
	end;
	tcnt = t + 1;
	
	TrHs = true;
	NCSr.Group = "";
	while (loopmain(NCSr,1,TrHs)) begin
		if(NCSr.Type==vclassification["SUBGROUP"])then begin
			rwcnt = matrowcnt(NCSr);
			for (j=0;j<rwcnt;j=j+1)begin
				matrowget(NCSr,j,NCSrw);
				AllSetTypes[NCSrw.CType] = true;
				if(blank(vclassification[NCSrw.CType]))then begin
					// res = -1;
					// RecordCheckError(31228," с типом: " & NCSrw.CType & " должна быть заполнена!",i,vclassificationfield[NCSrw.CType]);
					// goto LNewINVcRecordCheck;
				end else begin
					vclasstipecode[NCSrw.CType & NCSrw.CCode] = true;
				end;
			end;
			for (j=0;j<rwcnt;j=j+1)begin
				matrowget(NCSr,j,NCSrw);
				if(!vclasstipecode[NCSrw.CType & vclassification[NCSrw.CType]])then begin
					// res = -1;
					// RecordCheckError(31228," " & vclassification[NCSrw.CType] & " недопустима для данного типа классификации: " & NCSrw.CType,i,vclassificationfield[NCSrw.CType]);
					// goto LNewINVcRecordCheck;
				end;
			end;
			for (j=0;j<rwcnt;j=j+1)begin
				matrowget(NCSr,j,NCSrw);
				vclasstipecode[NCSrw.CType & NCSrw.CCode] = false;
			end;
			TrHs = false;
		end;
	end;
	ResetLoop(NCSr);

	for (t=0;t<tcnt;t=t+1) begin
		if(nonblank(vclassification[aTipeClass[t]]) and AllSetTypes[aTipeClass[t]]==false)then begin
			// res = -1;
			// RecordCheckError(31228," " & vclassification[aTipeClass[t]] & " не определена для данного типа: " & aTipeClass[t],i,vclassificationfield[aTipeClass[t]]);
			// goto LNewINVcRecordCheck;
		end;
	end;
	
	CheckClassifGlblImprt = res;
	return;
end;













global webpublic updating procedure WebChangeDownpaymentAcc()
begin
	record IVVc IVr,oldIVr;
	row IVVc IVrw;
	record TRVc  TRr,oldTRr;
	row TRVc TRrw;
	integer i,rwcnt,trrwcnt,j,dcnt;
	boolean storef,trsoref,TrHs;
	
	setcompany(28,false);
	
	//IVr.SerNr = 2100559;
	TrHs = true;
	while(loopmain(IVr,1,TrHs))begin
		if(IVr.SerNr!=2100559)then begin
			//TrHs = false;
		end;
		if(TrHs	)then begin
			recordcopy(oldIVr,IVr);
			storef = false;
			dcnt = 0;
		
			rwcnt = matrowcnt(IVr);
			for(i=0;i<rwcnt;i=i+1)begin
				matrowget(IVr,i,IVrw);
				if(IVrw.SalesAcc=="46")then begin
					dcnt = dcnt + 1;
				end;
				if(IVrw.stp==kInvoiceRowTypeDownpayment)then begin
					if(IVrw.SalesAcc=="46")then begin
						storef = true;
						IVrw.SalesAcc = "981";
						matrowput(IVr,i,IVrw);
					end;
				end;
			end;
			
			logtext(0,"WebChangeDownpaymentAcc storef " & storef);
			logtext(0,"WebChangeDownpaymentAcc dcnt " & dcnt);
		
			if(storef and dcnt>1)then begin
				
				TRr.Number = IVr.SerNr;
				TRr.IntYc = IVYc;
				if(readfirstmain(TRr,2,true))then begin
					trsoref = false;
					recordcopy(oldTRr,TRr);
					trrwcnt = matrowcnt(TRr);
					//storef = false;
				
					for(i=0;i<rwcnt;i=i+1)begin
						matrowget(oldIVr,i,IVrw);
						if(IVrw.stp==kInvoiceRowTypeDownpayment)then begin
							if(IVrw.SalesAcc=="46")then begin
								logtext(0,"IVrw.Sum " & IVrw.Sum);
								if(IVrw.Sum<0)then begin
									for(j=0;j<trrwcnt;j=j+1)begin
										matrowget(TRr,j,TRrw);
										if(TRrw.AccNumber=="46" and TRrw.CurDebVal==-IVrw.Sum)then begin
											TRrw.AccNumber = "981";
											TRrw.Comment = TRrw.Comment & "(46)";
											trsoref = true;
											matrowput(TRr,j,TRrw);
										end;
									end;
								end;
							end;
						end;
					end;

					if(trsoref)then begin
						if(recordupdate(oldTRr,TRr,true)==0)then begin
							storef = true;
						end;
					end;
				end;
			end;
		
			if(storef and dcnt==1)then begin
				TRr.Number = IVr.SerNr;
				TRr.IntYc = IVYc;
				if(readfirstmain(TRr,2,true))then begin
					//storef = false;
					trsoref = false;
					recordcopy(oldTRr,TRr);
					trrwcnt = matrowcnt(TRr);
					for(j=0;j<trrwcnt;j=j+1)begin
						matrowget(TRr,j,TRrw);
						if(TRrw.AccNumber=="46")then begin
							TRrw.AccNumber = "981";
							TRrw.Comment = TRrw.Comment & "(46)";
							trsoref = true;
							matrowput(TRr,j,TRrw);
						end;
					end;
					if(trsoref)then begin
						if(recordupdate(oldTRr,TRr,true)==0)then begin
							storef = true;
						end;
					end;
				end;
			end;
		
			if(storef and dcnt==1)then begin
				TRr.Number = IVr.SerNr;
				TRr.IntYc = IVYc;
				if(readfirstmain(TRr,2,true))then begin
					//storef = false;
					trsoref = false;
					recordcopy(oldTRr,TRr);
					trrwcnt = matrowcnt(TRr);
					for(j=0;j<trrwcnt;j=j+1)begin
						matrowget(TRr,j,TRrw);
						if(TRrw.AccNumber=="46")then begin
							TRrw.AccNumber = "981";
							trsoref = true;
							matrowput(TRr,j,TRrw);
						end;
					end;
					if(trsoref)then begin
						if(recordupdate(oldTRr,TRr,true)==0)then begin
							storef = true;
						end;
					end;
				end;
			end;
		
			if(storef)then begin
				recordstore(IVr,true);
			end;
		end;
	end;

return;
end;

global webpublic updating procedure WebFixIdeaObjects()
begin
	record IVVc IVr,oldIVr;
	row IVVc IVrw;
	record ORVc ORr;
	row ORVc ORrw;
	record SHVc SHr;
	row SHVc SHrw;
	record INVc INr;
	record ITVc ITr;
	string 255 obj;
	
	record TRVc  TRr,oldTRr;
	row TRVc TRrw;
	integer i,rwcnt,trrwcnt,j,dcnt;
	boolean storef,trsoref,TrHs;
	
	setcompany(28,false);
	
	IVr.SerNr = -1;
	TrHs = true;
	while(loopmain(IVr,1,TrHs))begin
		storef = false;
		rwcnt = matrowcnt(IVr);
		for(i=0;i<rwcnt;i=i+1)begin
			matrowget(IVr,i,IVrw);
			if(IVrw.stp==1)then begin
				if(blank(IVrw.Objects))then begin
					obj = "";
					INr.Code = IVrw.ArtCode;
					if(readfirstmain(INr,1,true))then begin
						obj = INr.Objects;
						ITr.Code = INr.Group;
						if(readfirstmain(ITr,1,true))then begin
							if(nonblank(ITr.Objects))then begin
								obj = AddObjectToObjectList(obj,ITr.Objects);
							end;
						end;
					end;
					if(nonblank(obj))then begin
						IVrw.Objects = obj;
						matrowput(IVr,i,IVrw);
						storef = true;
						obj = "";
					end;
				end;
			end;
		end;
		if(storef)then begin
			recordstore(IVr,true);
		end;
	end;
	
	ORr.SerNr = -1;
	TrHs = true;
	while(loopmain(ORr,1,TrHs))begin
		storef = false;
		rwcnt = matrowcnt(ORr);
		for(i=0;i<rwcnt;i=i+1)begin
			matrowget(ORr,i,ORrw);
			if(ORrw.stp==1)then begin
				if(blank(ORrw.Objects))then begin
					obj = "";
					INr.Code = ORrw.ArtCode;
					if(readfirstmain(INr,1,true))then begin
						obj = INr.Objects;
						ITr.Code = INr.Group;
						if(readfirstmain(ITr,1,true))then begin
							if(nonblank(ITr.Objects))then begin
								obj = AddObjectToObjectList(obj,ITr.Objects);
							end;
						end;
					end;
					if(nonblank(obj))then begin
						ORrw.Objects = obj;
						matrowput(ORr,i,ORrw);
						storef = true;
						obj = "";
					end;
				end;
			end;
		end;
		if(storef)then begin
			recordstore(ORr,true);
		end;
	end;
	
	SHr.SerNr = -1;
	TrHs = true;
	while(loopmain(SHr,1,TrHs))begin
		storef = false;
		rwcnt = matrowcnt(SHr);
		for(i=0;i<rwcnt;i=i+1)begin
			matrowget(SHr,i,SHrw);
			if(SHrw.stp==1)then begin
				if(blank(SHrw.Objects))then begin
					obj = "";
					INr.Code = SHrw.ArtCode;
					if(readfirstmain(INr,1,true))then begin
						obj = INr.Objects;
						ITr.Code = INr.Group;
						if(readfirstmain(ITr,1,true))then begin
							if(nonblank(ITr.Objects))then begin
								obj = AddObjectToObjectList(obj,ITr.Objects);
							end;
						end;
					end;
					if(nonblank(obj))then begin
						SHrw.Objects = obj;
						matrowput(SHr,i,SHrw);
						storef = true;
						obj = "";
					end;
				end;
			end;
		end;
		if(storef)then begin
			recordstore(SHr,true);
		end;
	end;

return;
end;



global webpublic updating procedure WebFixIdeaObjectsAccc()
begin
	record IVVc IVr,oldIVr;
	row IVVc IVrw;
	record ORVc ORr;
	row ORVc ORrw;
	record SHVc SHr;
	row SHVc SHrw;
	record INVc INr;
	record ITVc ITr;
	string 255 obj;
	record MainVc Mainr;
	record TRVc TRr,oldTRr;
	row TRVc TRrw;
	integer i,rwcnt,trrwcnt,j,dcnt;
	boolean storef,trsoref,TrHs;
	
	setcompany(28,false);
	
	Mainr.AccNumber = "45";
	Mainr.IntYc = SHYc;
	TrHs = true;
	while(loopkey("IntYc",Mainr,2,TrHs))begin
		if(Mainr.AccNumber!="45")then begin TrHs = false; end;
		if(Mainr.IntYc!=SHYc)then begin TrHs = false; end;
		
		if(TrHs)then begin
			
			TRr.Number = Mainr.TransNr;
			TRr.IntYc = Mainr.IntYc;
			if(readfirstmain(TRr,2,true))then begin
				storef = false;
				recordcopy(oldTRr,TRr);
				rwcnt = matrowcnt(TRr);
				for(i=0;i<rwcnt;i=i+1)begin
					matrowget(TRr,i,TRrw);
					if(TRrw.AccNumber=="45")then begin
						if(blank(TRrw.Objects))then begin
							logtext(0,"TransNr " & Mainr.TransNr);
							SHr.SerNr = TRr.Number;
							if(readfirstmain(SHr,1,true))then begin
								if(matrowcnt(SHr)>=(i+2)/2)then begin
									matrowget(SHr,((i+2)/2)-1,SHrw);
									if(nonblank(SHrw.Objects))then begin
										logtext(0,TRrw.AccNumber & " NewObkects " & SHrw.Objects);
										TRrw.Objects = SHrw.Objects;
										matrowput(TRr,i,TRrw);
										storef = true;
									end;
								end;
							end;
						end;
					end;
				end;
				
				if(storef)then begin
					recordupdate(oldTRr,TRr,true);
				end;
			end;
		end;
	
	end;
	

return;
end;


global webpublic updating procedure WebFixIdeaObjectsAccc46()
begin
	record IVVc IVr,oldIVr;
	row IVVc IVrw;
	record ORVc ORr;
	row ORVc ORrw;
	record SHVc SHr;
	row SHVc SHrw;
	record INVc INr;
	record ITVc ITr;
	string 255 obj;
	record MainVc Mainr;
	record TRVc TRr,oldTRr;
	row TRVc TRrw;
	integer i,rwcnt,trrwcnt,j,dcnt;
	boolean storef,trsoref,TrHs;
	
	setcompany(28,false);
	
	Mainr.AccNumber = "46";
	Mainr.IntYc = IVYc;
	TrHs = true;
	while(loopkey("IntYc",Mainr,2,TrHs))begin
		if(Mainr.AccNumber!="46")then begin TrHs = false; end;
		if(Mainr.IntYc!=IVYc)then begin TrHs = false; end;
		
		if(TrHs)then begin
			
			TRr.Number = Mainr.TransNr;
			TRr.IntYc = Mainr.IntYc;
			if(readfirstmain(TRr,2,true))then begin
				storef = false;
				recordcopy(oldTRr,TRr);
				rwcnt = matrowcnt(TRr);
				for(i=0;i<rwcnt;i=i+1)begin
					matrowget(TRr,i,TRrw);
					if(TRrw.AccNumber=="46")then begin
						if(blank(TRrw.Objects))then begin
							logtext(0,"TransNr " & Mainr.TransNr);
							IVr.SerNr = TRr.Number;
							if(readfirstmain(IVr,1,true))then begin
								recordcopy(oldIVr,IVr);
									IVr.OKFlag = 0;
								if(recordupdate(oldIVr,IVr,true)==0)then begin
									recordcopy(oldIVr,IVr)
									IVr.OKFlag = 1;
									recordupdate(oldIVr,IVr,true);
								end;
							end;							
						end;
					end;
				end;
			end;
		end;
	
	end;
	

return;
end;

global webpublic updating procedure WebFix3Level()
begin
	record BtrxThirdLevelCatVc BtrxThirdLevelCatr;
	
	while(loopmain(BtrxThirdLevelCatr,1,true))begin
	
		if(blank(BtrxThirdLevelCatr.PathScndCode))then begin
			recorddelete(BtrxThirdLevelCatr);
			stepback(BtrxThirdLevelCatr);
		end;
	end;


return;
end;

global 
webpublic updating procedure WebFillTreePathMn()
begin
	record GlobalItemVc GIr;
	record BtrxFirstLevelCatVc BtrxFirstLevelCatr;
	record BtrxSecondLevelCatVc BtrxSecondLevelCatr, BSLLastCoder;
	record BtrxThirdLevelCatVc BtrxThirdLevelCatr, BTLLastCoder,old3cetr;
	boolean testf, TrHs;
	string 255 catName, catNameRUS, catNameAZ, OldCode, sCatName, tCatName,tstr,new3cat;
	vector string 200 tlvelto2;
	integer pos;
	
	BtrxThirdLevelCatr.Name = "";
	while (loopkey("Name",BtrxThirdLevelCatr,1,testf)) begin
		tlvelto2[BtrxThirdLevelCatr.Name & ";;;" & BtrxThirdLevelCatr.PathScndCode] = BtrxThirdLevelCatr.Code;
	end;
	
	
	GIr.Code = "";
	while (LoopMain(GIr,1,true)) begin
		if(nonblank(GIr.BTRxFirstLevCat) and nonblank(GIr.BTRxSecondLevCat) and nonblank(GIr.BTRxThirdLevCat))then begin
			logtext(0,GIr.Code);
			
			pos = 0;
			new3cat = "";
			ExtractObj(GIr.BTRxThirdLevCat,pos,tstr);
			while(nonblank(tstr))begin
				if(nonblank(tstr) and left(tstr,5)=="THLVL")then begin
					BtrxThirdLevelCatr.Code = tstr;
					if(ReadFirstMain(BtrxThirdLevelCatr,1,true))then begin 
						if(BtrxThirdLevelCatr.PathScndCode!=GIr.BTRxSecondLevCat and left(BtrxThirdLevelCatr.Code,5)=="THLVL")then begin
							if(nonblank(tlvelto2[BtrxThirdLevelCatr.Name & ";;;" & GIr.BTRxSecondLevCat]))then begin
								tstr = tlvelto2[BtrxThirdLevelCatr.Name & ";;;" & GIr.BTRxSecondLevCat];
							end else begin
								BTLLastCoder.Code = "THLVL9999";
								if (readlastkey("Code",BTLLastCoder,1,false)) begin
									OldCode = BTLLastCoder.Code;
									recordcopy(BTLLastCoder,BtrxThirdLevelCatr);
									NextM4SerialNumber(OldCode,BTLLastCoder.Code);
									old3cetr.Code = BTLLastCoder.Code;
									if(readfirstmain(old3cetr,1,true)==false)then begin
										BTLLastCoder.PathScndCode = GIr.BTRxSecondLevCat;
										BtrxSecondLevelCatr.Code = GIr.BTRxSecondLevCat;
										if(readfirstmain(BtrxSecondLevelCatr,1,true))then begin
											BTLLastCoder.CatSecLvlName = BtrxSecondLevelCatr.Name;
										end;
										tlvelto2[BTLLastCoder.Name & ";;;" & BTLLastCoder.PathScndCode] = BTLLastCoder.Code;
										tstr = BTLLastCoder.Code;
										recordstore(BTLLastCoder,true);
									end;
								end;
							end;
						end;
					end;
				end;
				if(nonblank(new3cat))then begin
					new3cat = new3cat & "," & tstr;
				end else begin
					new3cat = tstr;
				end;
				ExtractObj(GIr.BTRxThirdLevCat,pos,tstr);
			end;
			if(nonblank(new3cat))then begin
				if(GIr.BTRxThirdLevCat!=new3cat)then begin
					GIr.BTRxThirdLevCat = new3cat;
					recordstore(GIr,true);
					new3cat = "";
				end;
			end;
			
		end;
	end;
return;
end;

procedure MyExtractObj(string ostr,var Integer pos,var string rstr)
BEGIN
  string 1 c1;
	integer i;
	
	rstr = "";
	if(pos<len(ostr))then begin
		for(i=pos;i<len(ostr);i=i+1)begin
			c1 = mid(ostr,i,1);
			if ((c1==",") or (c1==".") or (c1==";")) then begin
				pos = i+1;
				i = len(ostr);
			end else begin
				rstr = rstr & c1;
				pos = i+1;
			end;
		end;
	end;
	
  RETURN;
END;


global 
webpublic updating procedure WebFixGlobalWatchesMn()
begin
	record GlobalItemVc GIr;
	record BtrxFirstLevelCatVc BtrxFirstLevelCatr;
	record BtrxSecondLevelCatVc BtrxSecondLevelCatr, BSLLastCoder;
	record BtrxThirdLevelCatVc BtrxThirdLevelCatr, BTLLastCoder,old3cetr;
	boolean testf, TrHs;
	string 255 catName, catNameRUS, catNameAZ, OldCode, sCatName, tCatName,tstr,new3cat;
	string 1 c;
	vector string 200 tlvelto2,brand,lv1name,lv2name,lv3name;
	integer pos,i;
	boolean ch;
	record BPIBrandVc BPIBrandr;
	
	setcompany(1,false);
	
	
	while(loopmain(BtrxThirdLevelCatr,1,true))begin
		tlvelto2[BtrxThirdLevelCatr.Code] = BtrxThirdLevelCatr.PathScndCode;
		lv3name[BtrxThirdLevelCatr.Code] = BtrxThirdLevelCatr.Name;
	end;
	
	while(loopmain(BtrxSecondLevelCatr,1,true))begin
		lv2name[BtrxSecondLevelCatr.Code] = BtrxSecondLevelCatr.Name;
	end;
	
	while(loopmain(BtrxFirstLevelCatr,1,true))begin
		lv1name[BtrxFirstLevelCatr.Code] = BtrxFirstLevelCatr.Name;
	end;
	
	while(loopmain(BPIBrandr,1,true))begin
		brand[BPIBrandr.Code] = BPIBrandr.Name;
	end;
	
	while(loopmain(GIr,1,true))begin
		ch = false;
		
		/*if(nonblank(GIr.BTRxThirdLevCat))then begin
			tstr = "";
			for(i=0;i<len(GIr.BTRxThirdLevCat);i=i+1)begin
				c = mid(GIr.BTRxThirdLevCat,i,1);
				if(c=="_")then begin
					tstr = tstr & ",";
				end else begin
					tstr = tstr & c;
				end;
			end;
			
			if(tstr!=GIr.BTRxThirdLevCat)then begin
				logtext(0,GIr.Code & " " & GIr.BTRxThirdLevCat & " -> " & tstr);
			end;
		end;*/
		
		
		/*
		ch = false;
		tstr = "";
		pos = 0;
		new3cat = "";
		MyExtractObj(GIr.BTRxThirdLevCat,pos,tstr);
		while(nonblank(tstr))begin
			if(nonblank(tstr) and left(tstr,5)=="THLVL")then begin
				if(nonblank(tlvelto2[tstr]))then begin
					if(tlvelto2[tstr]!=GIr.BTRxSecondLevCat)then begin
						//logtext(0,"Error in 3 level wronglink" & GIr.Code);
						
						logtext(0,GIr.HansaCode & ";;;" & brand[GIr.BPIBrand] & ";;;" & GIr.Name & ";;;" & lv1name[GIr.BTRxFirstLevCat] & ";;;" & lv2name[GIr.BTRxSecondLevCat] & ";;;" & lv3name[GIr.BTRxThirdLevCat]);
					end;
				end else begin
					//logtext(0,"Error in 3 level levelnotexist" & GIr.Code);
					logtext(0,GIr.HansaCode & ";;;" & brand[GIr.BPIBrand] & ";;;" & GIr.Name & ";;;" & lv1name[GIr.BTRxFirstLevCat] & ";;;" & lv2name[GIr.BTRxSecondLevCat] & ";;;" & lv3name[GIr.BTRxThirdLevCat]);
				end;
			end;
			MyExtractObj(GIr.BTRxThirdLevCat,pos,tstr);
		end;
		*/
		
		/*if(GIr.BTRxFirstLevCat=="THLVL0109")then begin
			GIr.BTRxFirstLevCat = "THLVL0090";
			ch = true;
		end;
		if(GIr.BTRxFirstLevCat=="THLVL0083")then begin
			GIr.BTRxFirstLevCat = "THLVL0023";
			ch = true;
		end;
		if(GIr.BTRxSecondLevCat=="SCLVL0010")then begin
			GIr.BTRxSecondLevCat = "SCLVL0017";
			ch = true;
		end;*/
		/*if(GIr.BTRxFirstLevCat=="THLVL0031")then begin
			GIr.BTRxFirstLevCat = "THLVL0062";
			ch = true;
		end;*/
		
		/*if(GIr.BTRxFirstLevCat=="THLVL0096")then begin
			GIr.BTRxFirstLevCat = "THLVL0036";
			ch = true;
		end;
		
		if(ch)then begin
			logtext(0,GIr.Code);
			recordstore(GIr,true);
		end;*/
		if(GIr.BTRxFirstLevCat=="THLVL0095")then begin
			GIr.BTRxFirstLevCat = "THLVL0037";
			ch = true;
		end;
		
		if(ch)then begin
			logtext(0,GIr.Code);
			recordstore(GIr,true);
		end;
	end;
	
	
	/*while(loopmain(BtrxThirdLevelCatr,1,true))begin
		if(BtrxThirdLevelCatr.PathScndCode=="SCLVL0010")then begin
			BtrxThirdLevelCatr.PathScndCode = "SCLVL0017";
			logtext(0,"BtrxThirdLevelCatr " & BtrxThirdLevelCatr.Code);
			recordstore(BtrxThirdLevelCatr,true);
		end;
	end;*/
	
	return;
end;


global 
webpublic updating procedure WebDrawCategoryTree()
begin
	record GlobalItemVc GIr;
	record BtrxFirstLevelCatVc BtrxFirstLevelCatr;
	record BtrxSecondLevelCatVc BtrxSecondLevelCatr, BSLLastCoder;
	record BtrxThirdLevelCatVc BtrxThirdLevelCatr, BTLLastCoder,old3cetr;
	boolean testf, TrHs;
	string 255 catName, catNameRUS, catNameAZ, OldCode, sCatName, tCatName,tstr,new3cat;
	string 1 c;
	vector string 200 tlvelto2,brand,lv1name,lv2name,lv3name;
	integer pos,i;
	boolean ch;
	record BPIBrandVc BPIBrandr;
	
	setcompany(1,false);
	
	while(loopmain(BtrxFirstLevelCatr,1,true))begin
		lv1name[BtrxFirstLevelCatr.Code] = BtrxFirstLevelCatr.Name;
	end;
	resetloop(BtrxFirstLevelCatr);
	
	while(loopmain(BtrxSecondLevelCatr,1,true))begin
		lv2name[BtrxSecondLevelCatr.Code] = BtrxSecondLevelCatr.Name;
	end;
	resetloop(BtrxSecondLevelCatr);
	
	while(loopmain(BtrxThirdLevelCatr,1,true))begin
		lv3name[BtrxThirdLevelCatr.Code] = BtrxThirdLevelCatr.Name;
	end;
	resetloop(BtrxThirdLevelCatr);
	WebOutString("<BR>");
	BtrxFirstLevelCatr.Code = "";
	while(loopmain(BtrxFirstLevelCatr,1,true))begin
		WebOutString(BtrxFirstLevelCatr.Name & "(" & BtrxFirstLevelCatr.Code & ")" & BtrxFirstLevelCatr.NameRUS);
		weboutstring("<BR>");
		resetloop(BtrxSecondLevelCatr);
		BtrxSecondLevelCatr.Code = "";
		while(loopmain(BtrxSecondLevelCatr,1,true))begin
			if(BtrxSecondLevelCatr.PathFrstCode==BtrxFirstLevelCatr.Code)then begin
				lv2name[BtrxSecondLevelCatr.Code] = "";
				WebOutString("---------------------------" & BtrxSecondLevelCatr.Name & "(" & BtrxSecondLevelCatr.Code & ")" & BtrxSecondLevelCatr.NameRUS);
				weboutstring("<BR>");
				resetloop(BtrxThirdLevelCatr);
				BtrxThirdLevelCatr.Code = "";
				while(loopmain(BtrxThirdLevelCatr,1,true))begin
					if(BtrxThirdLevelCatr.PathScndCode==BtrxSecondLevelCatr.Code)then begin
						lv3name[BtrxThirdLevelCatr.Code] = "";
						WebOutString("------------------------------------------------------" & BtrxThirdLevelCatr.Name & "(" & BtrxThirdLevelCatr.Code & ")" & BtrxThirdLevelCatr.NameRUS);
						weboutstring("<BR>");
					end;
				end;
			end;
		end;
	end;
	
	weboutstring("<BR>");
	weboutstring("<BR>");
	weboutstring("Problems...");
	weboutstring("<BR>");
	weboutstring("<BR>");
	
	resetloop(BtrxSecondLevelCatr);
	BtrxSecondLevelCatr.Code = "";
	while(loopmain(BtrxSecondLevelCatr,1,true))begin
		if(nonblank(lv2name[BtrxSecondLevelCatr.Code]))then begin
			weboutstring(BtrxSecondLevelCatr.Code & "_____" & BtrxSecondLevelCatr.Name);
			weboutstring("<BR>");
		end;
	end;
	
	resetloop(BtrxThirdLevelCatr);
	BtrxThirdLevelCatr.Code = "";
	while(loopmain(BtrxThirdLevelCatr,1,true))begin
		if(nonblank(lv3name[BtrxThirdLevelCatr.Code]))then begin
			weboutstring(BtrxThirdLevelCatr.Code & "_____" & BtrxThirdLevelCatr.Name);
			weboutstring("<BR>");
		end;
	end;
	
	
	return;
end;


global procedure LogProcTime(string procname, longint timems)
begin
	area logfile;
	
	addtexttoarea(currentdate & chr(9) & currenttime & chr(9) & procname & chr(9) & currentcompany & chr(9) & timems & chr(13) & chr(10),logfile);
	
	writeareatofile(logfile,"ProcTimes.txt",1);
	

return;
end;


webpublic global
procedure WebCalcRHist()
begin
	record RHistVc RHr;
	vector longint cnter;
	string 1 c,nul;
	integer cter,i,pref,check;
	boolean TrHs;
	string 50 recname,compnr;
	array string 50 vtags;
	
	
	setcompany(1,false);
  RHr.SerNr = -1;
  TrHs = true;
  while(loopmain(RHr,1,TrHs))begin
  
  	if(check>1000)then begin
  		//TrHs = false;
  	end;
  	
  	if(fileexists("stop"))then begin
  		TrHs = false;
  	end;
  	
  	//check = check + 1;
  	
  	c = left(RHr.RecidStr,1);
  	recname = "";
  	cter = 0;
  	if(blank(RHr.RecidStr))then begin
  		cnter["BLANK"] = cnter["BLANK"] + 1;
  	end else begin
  		pref = asc(c) + 1;
  		compnr = mid(RHr.RecidStr,1,asc(c));
  		if(pref<len(RHr.RecidStr))then begin
				for(i=pref;i<len(RHr.RecidStr);i=i+1)begin
						c = mid(RHr.RecidStr,i,1);
					if(asc(c)==0)then begin
						i = len(RHr.RecidStr);
					end else begin
						recname = recname & c;
					end;
				end;
  		end else begin
  			cnter["BLANK"] = cnter["BLANK"] + 1;
  		end;
  	end;
  	if(nonblank(recname))then begin
  		cnter[compnr & "_" & recname] = cnter[compnr & "_" & recname] + 1;
  	end else begin
  		cnter["BLANK"] = cnter["BLANK"] + 1;
  	end;
  end;
  
  getvectortags(cnter,vtags);
  for(i=0;i<vtags.length;i=i+1)begin
  	weboutstring(vtags[i] & " ----- " & cnter[vtags[i]]);
  	weboutstring("<BR>");
  end;
  
return;
end;




// webpublic global
// updating procedure WebFillglobalClassFromIN()
// begin
	// record INVc INr;
	// record GlobalItemVc GIr;
	// boolean TrHs;
	// integer i,rwcnt,j,rwcnt2,curcomp,compNo;
  // string 50 store;
  // record CompaniesBlock CBb;
	// array string 255 noBrIt;

	// blockload(CBb);
	
	// j = 0;
	// GIr.Code = "";
	// while (loopMain(GIr,1,true)) begin
		// if(blank(GIr.BPIBrand))then begin
			// noBrIt[j] = GIr.HansaCode;
			// j = j + 1;
		// end;
	// end;
	// resetloop(GIr);
	// rwcnt = j;
	
	
	

	// for (i=0;i<matrowcnt(CBb);i=i+1) begin
		// compNo = i + 1;
		// if(compNo!=9 and compNo!=18 and compNo!=28 and compNo!=29 and compNo!=32 and compNo!=33 and !(CompanyIsJWLikeCompany(compNo) and compNo!=3))then begin
			// SetCompany(compNo,false);
			// logtext(0,"Company - " & compNo);
			// for (j=0;j<rwcnt;j=j+1) begin
				// INr.Code = noBrIt[j];
				// if (ReadFirstMain(INr,1,true)) begin
					// if(nonblank(INr.BPIBrand))then begin
						// GIr.Code = INr.BPIBrand & "_" & INr.Code;
						// if(ReadFirstMain(GIr,1,true))then begin
							// GIr.BPIBrand = INr.BPIBrand;
							// if(nonblank(INr.BPICollection))then begin
								// GIr.BPICollection = INr.BPICollection;
							// end;
							// if(nonblank(INr.BPICollection))then begin
								// GIr.BPIGroup = INr.BPICollection;
							// end;
							// if(nonblank(INr.BPISubGroup))then begin
								// GIr.BPISubGroup = INr.BPISubGroup;
							// end;
							// if(nonblank(INr.BPICategory))then begin
								// GIr.BPICategory = INr.BPICategory;
							// end;
							// if(nonblank(INr.BPIMaterial))then begin
								// GIr.BPIMaterial = INr.BPIMaterial;
							// end;
							// if(nonblank(INr.BPIColor))then begin
								// GIr.BPIColor = INr.BPIColor;
							// end;
							// if(nonblank(INr.BPIShape))then begin
								// GIr.BPIShape = INr.BPIShape;
							// end;
							// if(nonblank(INr.BPISize))then begin
								// GIr.BPISize = INr.BPISize;
							// end;
							// if(nonblank(INr.BPIUse))then begin
								// GIr.BPIUse = INr.BPIUse;
							// end;
							// if(nonblank(INr.BPISex))then begin
								// GIr.BPISex = INr.BPISex;
							// end;
							// if(nonblank(INr.BPIPlating))then begin
								// GIr.BPIPlating = INr.BPIPlating;
							// end;
							// if(nonblank(INr.BPIClarity))then begin
								// GIr.BPIClarity = INr.BPIClarity;
							// end;
							// if(nonblank(INr.BPIWeight))then begin
								// GIr.BPIWeight = INr.BPIWeight;
							// end;
							// if(nonblank(INr.BPICut))then begin
								// GIr.BPICut = INr.BPICut;
							// end;
							// if(nonblank(INr.BPIStone))then begin
								// GIr.BPIStone = INr.BPIStone;
							// end;
							// if(nonblank(INr.BPIStrap))then begin
								// GIr.BPIStrap = INr.BPIStrap;
							// end;
							// if(nonblank(INr.BPIOdour))then begin
								// GIr.BPIOdour = INr.BPIOdour;
							// end;
							// if(nonblank(INr.BTRxGiftClass))then begin
								// GIr.BTRxGiftClass = INr.BTRxGiftClass;
							// end;
							// if(nonblank(INr.BTRxInterCatClass))then begin
								// GIr.BTRxInterCatClass = INr.BTRxInterCatClass;
							// end;
							// if(nonblank(INr.BTRxFirstLevCat))then begin
								// GIr.BTRxFirstLevCat = INr.BTRxFirstLevCat;
							// end;
							// if(nonblank(INr.BTRxSecondLevCat))then begin
								// GIr.BTRxSecondLevCat = INr.BTRxSecondLevCat;
							// end;
							// if(nonblank(INr.BTRxThirdLevCat))then begin
								// GIr.BTRxThirdLevCat = INr.BTRxThirdLevCat;
							// end;
							// if(nonblank(INr.AlternativeCode))then begin
								// GIr.AlternativeCode = INr.AlternativeCode;
							// end;
							// if(nonblank(INr.Cert))then begin
								// GIr.Cert = INr.Cert;
							// end;
							// if(nonblank(INr.BTRxWatchMechanism))then begin
								// GIr.BTRxWatchMechanism = INr.BTRxWatchMechanism;
							// end;
							// if(nonblank(INr.BTRxPowerReserve))then begin
								// GIr.BTRxPowerReserve = INr.BTRxPowerReserve;
							// end;
							// if(nonblank(INr.BPIStrap))then begin
								// GIr.BPIStrap = INr.BPIStrap;
							// end;
							// if(nonblank(INr.BTRxStrapColour))then begin
								// GIr.BTRxStrapColour = INr.BTRxStrapColour;
							// end;
							// if(nonblank(INr.BTRxPlacerScatt))then begin
								// GIr.BTRxPlacerScatt = INr.BTRxPlacerScatt;
							// end;
							// if(nonblank(INr.BTRxPhoneModel))then begin
								// GIr.BTRxPhoneModel = INr.BTRxPhoneModel;
							// end;
							// if(nonblank(INr.BTRxFilling))then begin
								// GIr.BTRxFilling = INr.BTRxFilling;
							// end;
							// if(nonblank(INr.Depth))then begin
								// GIr.Depth = INr.Depth;
							// end;
							// if(nonblank(INr.Width))then begin
								// GIr.Width = INr.Width;
							// end;
							// if(nonblank(INr.Height))then begin
								// GIr.Height = INr.Height;
							// end;
							// if(nonblank(INr.BTRxDiam))then begin
								// GIr.BTRxDiam = INr.BTRxDiam;
							// end;
							// if(nonblank(INr.Volume))then begin
								// GIr.Volume = INr.Volume;
							// end;
							// if(nonblank(INr.Weight))then begin
								// GIr.Weight = INr.Weight;
							// end;
							// if(nonblank(INr.BTRxProdColour))then begin
								// GIr.BTRxProdColour = INr.BTRxProdColour;
							// end;
							// if(nonblank(INr.BTRxChainMaterial))then begin
								// GIr.BTRxChainMaterial = INr.BTRxChainMaterial;
							// end;
							// if(nonblank(INr.BTRxWatchGradeA))then begin
								// GIr.BTRxWatchGradeA = INr.BTRxWatchGradeA;
							// end;
							// if(nonblank(INr.BTRxWatchGradeB))then begin
								// GIr.BTRxWatchGradeB = INr.BTRxWatchGradeB;
							// end;
							// if(nonblank(INr.BTRxWatchGradeC))then begin
								// GIr.BTRxWatchGradeC = INr.BTRxWatchGradeC;
							// end;
							// if(nonblank(INr.BTRxStoneA))then begin
								// GIr.BTRxStoneA = INr.BTRxStoneA;
							// end;
							// if(nonblank(INr.BTRxStoneScattA))then begin
								// GIr.BTRxStoneScattA = INr.BTRxStoneScattA;
							// end;
							// if(nonblank(INr.BTRxStoneB))then begin
								// GIr.BTRxStoneB = INr.BTRxStoneB;
							// end;
							// if(nonblank(INr.BTRxStoneScattB))then begin
								// GIr.BTRxStoneScattB = INr.BTRxStoneScattB;
							// end;
							// if(nonblank(INr.BTRxStoneC))then begin
								// GIr.BTRxStoneC = INr.BTRxStoneC;
							// end;
							// if(nonblank(INr.BTRxStoneScattC))then begin
								// GIr.BTRxStoneScattC = INr.BTRxStoneScattC;
							// end;
							// if(nonblank(INr.BTRxLimitedGood))then begin
								// GIr.BTRxLimitedGood = INr.BTRxLimitedGood;
							// end;
							// if(RecordStore(GIr,true))then begin 
								// logtext(0,GIr.Code & "_" & compNo);
							// end;
						// end else begin
							// CreateNewGlobalItem(INr);
						// end;
					// end;
				// end;
			// end;
		// end;
	// end;
	
	



// end;




// webpublic global
// updating procedure WebFillglobalClassFromIN()
// begin
	// record INVc INr;
	// record GlobalItemVc GIr;
	// boolean TrHs;
	// integer i,rwcnt,j,rwcnt2,curcomp,compNo;
  // string 50 store;
  // record CompaniesBlock CBb;
	// array string 255 noBrIt;

	// blockload(CBb);
	
	// GIr.Code = "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ";
	// while (loopBackKey("Code",GIr,1,true)) begin
		// if(blank(GIr.BPIBrand))then begin
			// recorddelete(GIr);
			// logtext(0,GIr.Code);
		// end;
	// end;
	// resetloop(GIr);
	
// end;








webpublic global
updating procedure WebCalcRHistWithDeleting()
begin
	record RHistVc RHr;
	vector longint cnter;
	string 1 c,nul;
	integer cter,i,pref,check;
	boolean TrHs;
	string 50 recname,compnr;
	array string 50 vtags;
	date fd;
	
	fd.year = 2018;
	fd.month = 6;
	fd.day = 31;
	
	Logtext(0,"WebCalcRHistWithDeleting start");
	setcompany(1,false);
  RHr.SerNr = -1;
  TrHs = true;
  while(loopmain(RHr,1,TrHs))begin
  
  	if(check>1000)then begin
  		//TrHs = false;
  	end;
  	
  	if(fileexists("stop"))then begin
  		TrHs = false;
  	end;
  	
  	//check = check + 1;
  	
  	c = left(RHr.RecidStr,1);
  	recname = "";
  	cter = 0;
  	if(blank(RHr.RecidStr))then begin
  		cnter["BLANK"] = cnter["BLANK"] + 1;
  	end else begin
  		pref = asc(c) + 1;
  		compnr = mid(RHr.RecidStr,1,asc(c));
  		if(pref<len(RHr.RecidStr))then begin
				for(i=pref;i<len(RHr.RecidStr);i=i+1)begin
						c = mid(RHr.RecidStr,i,1);
					if(asc(c)==0)then begin
						i = len(RHr.RecidStr);
					end else begin
						recname = recname & c;
					end;
				end;
  		end else begin
  		end;
  	end;
  	if(blank(recname))then begin
  		recname = "BLANK";
  	end;
  	
  	switch(recname)begin
  		case"ACCESSVC":cnter[recname] = cnter[recname] + 1;
  						recorddelete(RHr);
  						stepback(RHr);
  		case"ACTVC":cnter[recname] = cnter[recname] + 1;
  						recorddelete(RHr);
  						stepback(RHr);
  		case"CLCORSPVC":cnter[recname] = cnter[recname] + 1;
  						recorddelete(RHr);
  						stepback(RHr);
  		case"DIVC":cnter[recname] = cnter[recname] + 1;
  						recorddelete(RHr);
  						stepback(RHr);
  		case"IVVC":
  						if(RHr.TransDate<=fd)then begin
								cnter[recname] = cnter[recname] + 1;
								recorddelete(RHr);
								stepback(RHr);
  						end;
  		/*case"INVC":
  						if(RHr.TransDate<=fd)then begin
								cnter[recname] = cnter[recname] + 1;
								recorddelete(RHr);
								stepback(RHr);
  						end;*/
  		/*case"PLVC":
  						if(RHr.TransDate<=fd)then begin
								cnter[recname] = cnter[recname] + 1;
								recorddelete(RHr);
								stepback(RHr);
  						end;*/
  		case"CLINVC":
  						if(RHr.TransDate<=fd)then begin
								cnter[recname] = cnter[recname] + 1;
								recorddelete(RHr);
								stepback(RHr);
  						end;
  		case"CLOUTVC":
  						if(RHr.TransDate<=fd)then begin
								cnter[recname] = cnter[recname] + 1;
								recorddelete(RHr);
								stepback(RHr);
  						end;
  		case"ERVC":
  						if(RHr.TransDate<=fd)then begin
								cnter[recname] = cnter[recname] + 1;
								recorddelete(RHr);
								stepback(RHr);
  						end;
  		/*case"LOYALTYCARDVC":
  						if(RHr.TransDate<=fd)then begin
								cnter[recname] = cnter[recname] + 1;
								recorddelete(RHr);
								stepback(RHr);
  						end;*/
  		case"OBJVC":cnter[recname] = cnter[recname] + 1;
  						recorddelete(RHr);
  						stepback(RHr);
  		case"PFORMVC":cnter[recname] = cnter[recname] + 1;
  						recorddelete(RHr);
  						stepback(RHr);
  		case"PLDEFVC":cnter[recname] = cnter[recname] + 1;
  						recorddelete(RHr);
  						stepback(RHr);
  		case"REBVC":cnter[recname] = cnter[recname] + 1;
  						recorddelete(RHr);
  						stepback(RHr);
  		case"RETPUVC":cnter[recname] = cnter[recname] + 1;
  						recorddelete(RHr);
  						stepback(RHr);
  		case"RETVC":cnter[recname] = cnter[recname] + 1;
  						recorddelete(RHr);
  						stepback(RHr);
  		case"SDVC":cnter[recname] = cnter[recname] + 1;
  						recorddelete(RHr);
  						stepback(RHr);
  		case"SHVC":cnter[recname] = cnter[recname] + 1;
  						recorddelete(RHr);
  						stepback(RHr);
  		case"STOCKMOVVC":cnter[recname] = cnter[recname] + 1;
  						recorddelete(RHr);
  						stepback(RHr);
  		case"STOCKTAKEVC":cnter[recname] = cnter[recname] + 1;
  						recorddelete(RHr);
  						stepback(RHr);
  		case"TRVC":
  						if(RHr.TransDate<=fd)then begin
								cnter[recname] = cnter[recname] + 1;
								recorddelete(RHr);
								stepback(RHr);
  						end;
  		case"USERVC":cnter[recname] = cnter[recname] + 1;
  						recorddelete(RHr);
  						stepback(RHr);
  		case"VIVC":cnter[recname] = cnter[recname] + 1;
  						recorddelete(RHr);
  						stepback(RHr);
  		otherwise
  						if(compnr=="10" or compnr=="14")then begin
								cnter[recname] = cnter[recname] + 1;
								recorddelete(RHr);
								stepback(RHr);
  						end;
  	end;
  end;
  
  Logtext(0,"WebCalcRHistWithDeleting end");
  
  getvectortags(cnter,vtags);
  for(i=0;i<vtags.length;i=i+1)begin
  	weboutstring(vtags[i] & " ----- " & cnter[vtags[i]]);
  	weboutstring("<BR>");
  end;
  
  Logtext(0,"WebCalcRHistWithDeleting end");
  
return;
end;

function string 100 fixPhone(string inpphone)
begin
	string 100 res;
	integer i;
	string 1 c;
	
	for(i=0;i<len(inpphone);i=i+1)begin
		c = mid(inpphone,i,1);
		if(asc(c)>47 and asc(c)<58)then begin	
			res = res & c;
		end;
	end;
	
	if(len(res)==10)then begin
		res = right(res,9);
	end;
	if(len(res)==20)then begin
		res = mid(res,1,9) & "," & mid(res,11,9);
	end;
	
	fixPhone = res;
return;
end;

function string 255 CheckCustomersWithSamePhnes(record CUVc origCUr,string phone)
begin
	boolean TrHs,testf;
	string 255 res;
	record CUVc CUr;
	
	if(nonblank(phone))then begin
		CUr.Phone = phone;
		TrHs = true;
		while(loopkey("Phone",CUr,1,TrHs))begin
			if(CUr.Phone!=phone)then begin TrHs = false; end;
			
			if(CUr.blockedFlag==0 and CUr.Code!=origCUr.Code and TrHs)then begin
				res = res & CUr.Code & ",";
			end;
		end;
		resetloop(CUr);
		
		CUr.Mobile = phone;
		TrHs = true;
		while(loopkey("Mobile",CUr,1,TrHs))begin
			if(CUr.Mobile!=phone)then begin TrHs = false; end;
			
			if(CUr.blockedFlag==0 and CUr.Code!=origCUr.Code and TrHs)then begin
				res = res & CUr.Code & ",";
			end;
		end;
		resetloop(CUr);
		
		CUr.AltPhone = phone;
		TrHs = true;
		while(loopkey("AltPhone",CUr,1,TrHs))begin
			if(CUr.AltPhone!=phone)then begin TrHs = false; end;
			
			if(CUr.blockedFlag==0 and CUr.Code!=origCUr.Code and TrHs)then begin
				res = res & CUr.Code & ",";
			end;
		end;
		resetloop(CUr);
	end;
	
	CheckCustomersWithSamePhnes = res;
return;
end;

global webpublic procedure WebGetDuplClient()
begin
	record CUVc CUr,oldCUr;
	boolean TrHs,testf;
	integer i,pos;
	string 100 tstr,normphone,dupcust;
	
	setcompany(28,false);
	
	CUr.CustCat = "IDEA";
	TrHs = true;
	while(loopkey("Group",CUr,1,TrHs))begin
		testf = true;
		if(CUr.CustCat!="IDEA")then begin TrHs = false; testf = false; end;
		if(CUr.blockedFlag==1)then begin testf = false; end;
		if(CUr.CUType==0)then begin testf = false; end;
		
		
		if(testf)then begin
			normphone = fixPhone(CUr.Phone);
			tstr = "";
			pos = 0;
			dupcust = "";
			if(nonblank(normphone))then begin
				ExtractObj(normphone,pos,tstr);
				while(nonblank(tstr))begin
					dupcust = dupcust & CheckCustomersWithSamePhnes(CUr,normphone);
					ExtractObj(normphone,pos,tstr);
				end;
			end;
			NormalizeObjstr(dupcust);
			if(nonblank(dupcust))then begin
				weboutstring("Custcomer code:" & CUr.Code & "&nbsp| name &nbsp" & CUr.Name & "&nbsp| Phone &nbsp" & fixPhone(CUr.Phone) & "&nbsp|&nbspDuplicates: " & dupcust);
				weboutstring("<BR>");
			end;
		end;
	end;
	
return;
end;





global webpublic procedure WebGetBlankThrdCat()
begin
	record GlobalItemVc GIr;
	record BtrxFirstLevelCatVc BtrxFirstLevelCatr;
	record BtrxSecondLevelCatVc BtrxSecondLevelCatr;
	record BtrxThirdLevelCatVc BtrxThirdLevelCatr;
	record BTRxBrandVc BTRxBrandr;

	boolean TrHs,testf;
	integer i,pos;
	string 100 tstr,normphone,dupcust;
	
	SetCompany(18,false);
	
	GIr.Code = "";
	while (LoopMain(GIr,1,true)) begin
		if(nonblank(GIr.BTRxFirstLevCat) and nonblank(GIr.BTRxSecondLevCat) and blank(GIr.BTRxThirdLevCat))then begin
			BTRxBrandr.Code = GIr.BPIBrand;
			if(ReadFirstMain(BTRxBrandr,1,true))then begin end;
			BtrxFirstLevelCatr.Code = GIr.BTRxFirstLevCat;
			if(ReadFirstMain(BtrxFirstLevelCatr,1,true))then begin end;
			BtrxSecondLevelCatr.Code = GIr.BTRxSecondLevCat;
			if(ReadFirstMain(BtrxSecondLevelCatr,1,true))then begin end;
			
			weboutstring("Global code: " & GIr.Code & " --------- Brand: " & BTRxBrandr.Name & " --------- BTRxFirstLevCat: " & BtrxFirstLevelCatr.Name & " --------- BTRxSecondLevCat: " & BtrxSecondLevelCatr.Name);
			weboutstring("<BR>");
		end;
	end;
	
	
return;
end;











global updating procedure ChangeAllBrandBPIBrandMn(record RcVc RepSpec)
begin
record INVc INr,oldINr;
integer i,curcomp,cnt,j,k;
record GlobalItemVc GIr,oldGIr;
string 100 item,oldBrand,newBrand,code,glCode;
record BPIBrandVc BPIBrandr;
record BPIBrandVc BPIBrand1r;
array string 100 abrand,anewbrand;
boolean tochan;


	curcomp = currentcompany;
	logtext(0,"start");

		cnt = cnt + 1;
		oldBrand = RepSpec.f1;
		newBrand = RepSpec.f2;
		BPIBrandr.Code = oldBrand;
		logtext(0,"oldBrand " & oldBrand);
		logtext(0,"newBrand " & newBrand);
		if(nonblank(RepSpec.f1))then begin
			if(true)then begin		
				BPIBrand1r.Code = newBrand;
				if(readfirstkey("Code",BPIBrand1r,1,true))then begin						
					for(i=1;i<33; i=i+1) begin
						if((!CompanyIsJWLikeCompany(i) or i==3) and i!=10) then begin
							SetCompany(i,false);
							resetloop(INr);
							INr.Code = "";
							while(LoopMain(INr,1,true))begin
								if(nonblank(INr.BPIBrand))then begin
									if(INr.BPIBrand==RepSpec.f1)then begin;
										tochan = true;
										logtext(0,INr.Code & " " & INr.BPIBrand & " " & INr.GlobalArtCode);
										if(setinset(INr.BPIBrand,INr.DispGroups))then begin										
											INr.DispGroups = StrReplace(INr.DispGroups,INr.BPIBrand,BPIBrand1r.Code);
										end;
										glCode = INr.GlobalArtCode;
										INr.GlobalArtCode = "";
										INr.BPIBrand = BPIBrand1r.Code;
										GIr.Code = glCode;										
										if(ReadFirstMain(GIr,1,true)) then begin
											logtext(0,"del" & GIr.Code);
											oldGIr.Code = INr.Code & "_" & INr.BPIBrand;
											if(readfirstmain(oldGIr,1,true))then begin
												tochan = false;
												logtext(0,"Failed to change brand for " & INr.Code & " in company " & currentcompany);
											end else begin
												recordcopy(oldGIr,GIr);
											 GIr.Code = INr.BPIBrand & "_" & INr.Code;
											 INr.GlobalArtCode = GIr.Code;
											 GIr.Brand = BPIBrand1r.Name;
											 GIr.BPIBrand = BPIBrand1r.Code;
											 if(nonblank(GIr.MainCode))then begin
											 	if(left(GIr.MainCode,8)!=left(GIr.Code,8))then begin
											 		GIr.MainCode = GIr.BPIBrand & right(GIr.MainCode,len(GIr.MainCode)-8);
											 	end;
											 end;
											 GIr.Classification = INr.DispGroups;
											 recordupdate(oldGIr,GIr,false);
											end;
										end;
										if(tochan)then begin
											logtext(0,"Brand Changed for item " & INr.Code & " in company " & currentcompany);
											if(recordStore(INr,true)) then begin  end;
										end;
									end; 
								end;
							end;
						end;
					end;
				end;
			end;
		end;
	SetCompany(curcomp,false);
	
logtext(0,"end");
return;
end;

updating procedure LoopItemsInOtherCom(record INVc INr,integer orgcomp)
begin
	record CompaniesBlock Compb;
  row CompaniesBlock Comprw;
  integer i,rwcnt;
  record INVc IN2r;
  boolean diff;
  
  BlockLoad(Compb);
  rwcnt = MatRowCnt(Compb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Compb,i,Comprw);
  	if((i+1)!=orgcomp)then begin
  		setcompany(i+1,false);
  		IN2r.Code = INr.Code;
  		if(readfirstmain(IN2r,1,true))then begin
  			
  			diff = false;
  			if(IN2r.BPIBrand==INr.BPIBrand)then begin
					if(IN2r.BPICollection!=INr.BPICollection)then begin diff = true; logtext(0,"BPICollection"); end;
					if(IN2r.BPIGroup!=INr.BPIGroup)then begin diff = true; logtext(0,"BPIGroup"); end;
					if(IN2r.BPISubGroup!=INr.BPISubGroup)then begin diff = true; logtext(0,"BPISubGroup"); end;
					if(IN2r.BPICategory!=INr.BPICategory)then begin diff = true; logtext(0,"BPICategory"); end;
					if(IN2r.BPIMaterial!=INr.BPIMaterial)then begin diff = true; logtext(0,"BPIMaterial"); end;
					if(IN2r.BPIColor!=INr.BPIColor)then begin diff = true; logtext(0,"BPIColor"); end;
					if(IN2r.BPIShape!=INr.BPIShape)then begin diff = true; logtext(0,"BPIShape"); end;
					if(IN2r.BPISize!=INr.BPISize)then begin diff = true; logtext(0,"BPISize"); end;
					if(IN2r.BPIUse!=INr.BPIUse)then begin diff = true; logtext(0,"BPIUse"); end;
					if(IN2r.BPISex!=INr.BPISex)then begin diff = true; logtext(0,"BPISex"); end;
					if(IN2r.BPIPlating!=INr.BPIPlating)then begin diff = true; logtext(0,"BPIPlating"); end;
					if(IN2r.BPIClarity!=INr.BPIClarity)then begin diff = true; logtext(0,"BPIClarity"); end;
					if(IN2r.BPIWeight!=INr.BPIWeight)then begin diff = true; logtext(0,"BPIWeight"); end;
					if(IN2r.BPICut!=INr.BPICut)then begin diff = true; logtext(0,"BPICut"); end;
					if(IN2r.BPIStone!=INr.BPIStone)then begin diff = true; logtext(0,"BPIStone"); end;
					if(IN2r.BPIStrap!=INr.BPIStrap)then begin diff = true; logtext(0,"BPIStrap"); end;
					if(IN2r.BPIOdour!=INr.BPIOdour)then begin diff = true; logtext(0,"BPIOdour"); end;
  				
  				if(diff)then begin
						logtext(0,"LoopItemsInOtherCom " & currentcompany & "  " & IN2r.Code);
						IN2r.BPICollection = INr.BPICollection;
						IN2r.BPIGroup = INr.BPIGroup;
						IN2r.BPISubGroup = INr.BPISubGroup;
						IN2r.BPICategory = INr.BPICategory;
						IN2r.BPIMaterial = INr.BPIMaterial;
						IN2r.BPIColor = INr.BPIColor;
						IN2r.BPIShape = INr.BPIShape;
						IN2r.BPISize = INr.BPISize;
						IN2r.BPIUse = INr.BPIUse;
						IN2r.BPISex = INr.BPISex;
						IN2r.BPIPlating = INr.BPIPlating;
						IN2r.BPIClarity = INr.BPIClarity;
						IN2r.BPIWeight = INr.BPIWeight;
						IN2r.BPICut = INr.BPICut;
						IN2r.BPIStone = INr.BPIStone;
						IN2r.BPIStrap = INr.BPIStrap;
						IN2r.BPIOdour = INr.BPIOdour;
						IN2r.Name = INr.Name;
						recordstore(IN2r,true);
  				end;
  				
  			end;
  		end;
  	end;
  end;
  
  resetcompany(orgcomp);

return;
end;

global webpublic updating  procedure offUpdateAllBenchmarkingInItemMn()
begin
	record IVVc IVr,IVr1;
	row IVVc IVrw;
	integer i,mtrw,curcomp;
	record INVc INr;
	
	curcomp = 6;
	
	setcompany(curcomp,false);
	IVr.SerNr = 4826;
	IVr1.SerNr = 4827;
	
	readfirstmain(IVr,1,true);
	readfirstmain(IVr1,1,true);
	
	mtrw = matrowcnt(IVr);
	for(i=0;i<mtrw;i=i+1)begin
		matrowget(IVr,i,IVrw);
		INr.Code = IVrw.ArtCode;
		if(readfirstmain(INr,1,true))then begin
			LoopItemsInOtherCom(INr,curcomp);
		end;
	end;
	
	mtrw = matrowcnt(IVr1);
	for(i=0;i<mtrw;i=i+1)begin
		matrowget(IVr1,i,IVrw);
		INr.Code = IVrw.ArtCode;
		if(readfirstmain(INr,1,true))then begin
			LoopItemsInOtherCom(INr,curcomp);
		end;
	end;
	
	IVr.SerNr = 4828;
	IVr1.SerNr = 4829;
	
	readfirstmain(IVr,1,true);
	readfirstmain(IVr1,1,true);
	
	mtrw = matrowcnt(IVr);
	for(i=0;i<mtrw;i=i+1)begin
		matrowget(IVr,i,IVrw);
		INr.Code = IVrw.ArtCode;
		if(readfirstmain(INr,1,true))then begin
			LoopItemsInOtherCom(INr,curcomp);
		end;
	end;
	
	mtrw = matrowcnt(IVr1);
	for(i=0;i<mtrw;i=i+1)begin
		matrowget(IVr1,i,IVrw);
		INr.Code = IVrw.ArtCode;
		if(readfirstmain(INr,1,true))then begin
			LoopItemsInOtherCom(INr,curcomp);
		end;
	end;
	
	IVr.SerNr = 4830;
	IVr1.SerNr = 4831;
	
	readfirstmain(IVr,1,true);
	readfirstmain(IVr1,1,true);
	
	mtrw = matrowcnt(IVr);
	for(i=0;i<mtrw;i=i+1)begin
		matrowget(IVr,i,IVrw);
		INr.Code = IVrw.ArtCode;
		if(readfirstmain(INr,1,true))then begin
			LoopItemsInOtherCom(INr,curcomp);
		end;
	end;
	
	mtrw = matrowcnt(IVr1);
	for(i=0;i<mtrw;i=i+1)begin
		matrowget(IVr1,i,IVrw);
		INr.Code = IVrw.ArtCode;
		if(readfirstmain(INr,1,true))then begin
			LoopItemsInOtherCom(INr,curcomp);
		end;
	end;
	
return;
end;

global webpublic procedure WebCompileAllParams()
begin
	record CompaniesBlock Compb;
  row CompaniesBlock Comprw;
  integer i,rwcnt;
  record INVc INr;
  boolean diff;
  boolean incomp;
  area aINParams,aGIParams;
  record BPIBrandVc BPIBrandr;
record BPICollectionVc BPICollectionr;
record BPIGroupVc BPIGroupr;
record BPISubGroupVc BPISubGroupr;
record BPICategoryVc BPICategoryr;
record BPIMaterialVc BPIMaterialr;
record BPIColorVc BPIColorr;
record BPIShapeVc BPIShaper;
record BPISizeVc BPISizer;
record BPIUseVc BPIUser;
record BPISexVc BPISexr;
record BPIPlatingVc BPIPlatingr;
record BPIClarityVc BPIClarityr;
record BPIWeightVc BPIWeightr;
record BPICutVc BPICutr;
record BPIStoneVc BPIStoner;
record BPIStrapVc BPIStrapr;
record BPIOdourVc BPIOdourr;
vector string 255 vClass;
longint curtick;
	record BTRxBrandVc BTRxBrandr;
	record BTRxMaterialVc BTRxMaterialr;
	record BTRxColourVc BTRxColorr;
	record BTRxSizeVc BTRxSizer;
	record BTRxSexVc BTRxSexr;
	record BTRxPlatingVc BTRxPlatingr;
	record BTRxStoneVc BTRxStoner;
	record BTRxStrapVc BTRxStrapr;
	record BTRxOdourVc BTRxOdourr;
	record BtrxInternalCatVc BtrxInternalCatr;
	record BtrxFirstLevelCatVc BtrxFirstLevelCatr;
	record BtrxSecondLevelCatVc BtrxSecondLevelCatr;
	record BtrxThirdLevelCatVc BtrxThirdLevelCatr;
	record BtrxCertificateVc BtrxCertificater;
	record BtrxWatchMechanVc BtrxWatchMechanr;
	record BtrxPowerReserveVc BtrxPowerReserver;
	record BtrxWatchGradeVc BtrxWatchGrader;
	record BtrxPhoneModelVc BtrxPhoneModelr;
	record BtrxFillingVc BtrxFillingr;
	record BtrxTypeVc BtrxTyper;
	record BtrxWaterResistantVc BtrxWatResr;
	record BtrxStrapMatVc BtrxStrapMatr;
	record BtrxBracelMatVc BtrxBracelMatr;
	record BtrxCollectionVc BtrxCollectionr;
	record BtrxCollectionGroupVc BtrxCollectionGroupr;
	record GlobalItemVc GIr;
		
	setcompany(1,false); 
	// Collect Bitrix Name start
	BTRxBrandr.Code = "";
	while (loopMain(BTRxBrandr,1,true)) begin 
		vClass [BTRxBrandr.Code] = BTRxBrandr.Name;
	end;
	
	BTRxMaterialr.Code = "";
	while (loopMain(BTRxMaterialr,1,true)) begin 
		vClass [BTRxMaterialr.Code] = BTRxMaterialr.Name;
	end;
	BTRxColorr.Code = "";
	while (loopMain(BTRxColorr,1,true)) begin 
		vClass [BTRxColorr.Code] = BTRxColorr.Name;
	end;
	BTRxSizer.Code = "";
	while (loopMain(BTRxSizer,1,true)) begin 
		vClass [BTRxSizer.Code] = BTRxSizer.Name;
	end;	
	BTRxSexr.Code = "";
	while (loopMain(BTRxSexr,1,true)) begin 
		vClass [BTRxSexr.Code] = BTRxSexr.Name;
	end;	
	BTRxPlatingr.Code = "";
	while (loopMain(BTRxPlatingr,1,true)) begin 
		vClass [BTRxPlatingr.Code] = BTRxPlatingr.Name;
	end;	
	BTRxStoner.Code = "";
	while (loopMain(BTRxStoner,1,true)) begin 
		vClass [BTRxStoner.Code] = BTRxStoner.Name;
	end;	
	BTRxStrapr.Code = "";
	while (loopMain(BTRxStrapr,1,true)) begin 
		vClass [BTRxStrapr.Code] = BTRxStrapr.Name;
	end;	
	BTRxOdourr.Code = "";
	while (loopMain(BTRxOdourr,1,true)) begin 
		vClass [BTRxOdourr.Code] = BTRxOdourr.Name;
	end;	
	BtrxInternalCatr.Code = "";
	while (loopMain(BtrxInternalCatr,1,true)) begin 
		vClass [BtrxInternalCatr.Code] = BtrxInternalCatr.Name;
	end;	
	BtrxFirstLevelCatr.Code = "";
	while (loopMain(BtrxFirstLevelCatr,1,true)) begin 
		vClass [BtrxFirstLevelCatr.Code] = BtrxFirstLevelCatr.Name;
	end;	
	BtrxSecondLevelCatr.Code = "";
	while (loopMain(BtrxSecondLevelCatr,1,true)) begin 
		vClass [BtrxSecondLevelCatr.Code] = BtrxSecondLevelCatr.Name;
	end;	
	BtrxThirdLevelCatr.Code = "";
	while (loopMain(BtrxThirdLevelCatr,1,true)) begin 
		vClass [BtrxThirdLevelCatr.Code] = BtrxThirdLevelCatr.Name;
	end;	
	BtrxCertificater.Code = "";
	while (loopMain(BtrxCertificater,1,true)) begin 
		vClass [BtrxCertificater.Code] = BtrxCertificater.Name;
	end;	
	BtrxWatchMechanr.Code = "";
	while (loopMain(BtrxWatchMechanr,1,true)) begin 
		vClass [BtrxWatchMechanr.Code] = BtrxWatchMechanr.Name;
	end;	
	BtrxPowerReserver.Code = "";
	while (loopMain(BtrxPowerReserver,1,true)) begin 
		vClass [BtrxPowerReserver.Code] = BtrxPowerReserver.Name;
	end;	
	BtrxWatchGrader.Code = "";
	while (loopMain(BtrxWatchGrader,1,true)) begin 
		vClass [BtrxWatchGrader.Code] = BtrxWatchGrader.Name;
	end;	
	BtrxPhoneModelr.Code = "";
	while (loopMain(BtrxPhoneModelr,1,true)) begin 
		vClass [BtrxPhoneModelr.Code] = BtrxPhoneModelr.Name;
	end;	
	BtrxFillingr.Code = "";
	while (loopMain(BtrxFillingr,1,true)) begin 
		vClass [BtrxFillingr.Code] = BtrxFillingr.Name;
	end;	
	BtrxTyper.Code = "";
	while (loopMain(BtrxTyper,1,true)) begin 
		vClass [BtrxTyper.Code] = BtrxTyper.Name;
	end;	
	BtrxWatResr.Code = "";
	while (loopMain(BtrxWatResr,1,true)) begin 
		vClass [BtrxWatResr.Code] = BtrxWatResr.Name;
	end;	
	BtrxStrapMatr.Code = "";
	while (loopMain(BtrxStrapMatr,1,true)) begin 
		vClass [BtrxStrapMatr.Code] = BtrxStrapMatr.Name;
	end;	
	BtrxBracelMatr.Code = "";
	while (loopMain(BtrxBracelMatr,1,true)) begin 
		vClass [BtrxBracelMatr.Code] = BtrxBracelMatr.Name;
	end;	
	BtrxCollectionr.Code = "";
	while (loopMain(BtrxCollectionr,1,true)) begin 
		vClass [BtrxCollectionr.Code] = BtrxCollectionr.Name;
	end;	
	BtrxCollectionGroupr.Code = "";
	while (loopMain(BtrxCollectionGroupr,1,true)) begin 
		vClass [BtrxCollectionGroupr.Code] = BtrxCollectionGroupr.Name;
	end;	
	// end
	// Collect BPIclassification Name start
	vClass [""] = "";
	BPIBrandr.Code = "";
	while (loopMain(BPIBrandr,1,true)) begin 
		vClass [BPIBrandr.Code] = BPIBrandr.Name;
	end;
	
	BPICollectionr.Code = "";
	while (loopMain(BPICollectionr,1,true)) begin 
		vClass [BPICollectionr.Code] = BPICollectionr.Name;
	end;
	BPIGroupr.Code = "";
	while (loopMain(BPIGroupr,1,true)) begin 
		vClass [BPIGroupr.Code] = BPIGroupr.Name;
	end;
	BPISubGroupr.Code = "";
	while (loopMain(BPISubGroupr,1,true)) begin 
		vClass [BPISubGroupr.Code] = BPISubGroupr.Name;
	end;	
	BPICategoryr.Code = "";
	while (loopMain(BPICategoryr,1,true)) begin 
		vClass [BPICategoryr.Code] = BPICategoryr.Name;
	end;	
	BPIMaterialr.Code = "";
	while (loopMain(BPIMaterialr,1,true)) begin 
		vClass [BPIMaterialr.Code] = BPIMaterialr.Name;
	end;	
	BPIColorr.Code = "";
	while (loopMain(BPIColorr,1,true)) begin 
		vClass [BPIColorr.Code] = BPIColorr.Name;
	end;	
	BPIShaper.Code = "";
	while (loopMain(BPIShaper,1,true)) begin 
		vClass [BPIShaper.Code] = BPIShaper.Name;
	end;	
	BPISizer.Code = "";
	while (loopMain(BPISizer,1,true)) begin 
		vClass [BPISizer.Code] = BPISizer.Name;
	end;	
	BPIUser.Code = "";
	while (loopMain(BPIUser,1,true)) begin 
		vClass [BPIUser.Code] = BPIUser.Name;
	end;	
	BPISexr.Code = "";
	while (loopMain(BPISexr,1,true)) begin 
		vClass [BPISexr.Code] = BPISexr.Name;
	end;	
	BPIPlatingr.Code = "";
	while (loopMain(BPIPlatingr,1,true)) begin 
		vClass [BPIPlatingr.Code] = BPIPlatingr.Name;
	end;	
	BPIClarityr.Code = "";
	while (loopMain(BPIClarityr,1,true)) begin 
		vClass [BPIClarityr.Code] = BPIClarityr.Name;
	end;	
	BPICutr.Code = "";
	while (loopMain(BPICutr,1,true)) begin 
		vClass [BPICutr.Code] = BPICutr.Name;
	end;	
	BPIStoner.Code = "";
	while (loopMain(BPIStoner,1,true)) begin 
		vClass [BPIStoner.Code] = BPIStoner.Name;
	end;	
	BPIStrapr.Code = "";
	while (loopMain(BPIStrapr,1,true)) begin 
		vClass [BPIStrapr.Code] = BPIStrapr.Name;
	end;	
	BPIOdourr.Code = "";
	while (loopMain(BPIOdourr,1,true)) begin 
		vClass [BPIOdourr.Code] = BPIOdourr.Name;
	end;	
	vClass [""] = "";
  // end 
	
  addtexttoarea("GROUP<;>SUBGROUP<;>COLLECTION<;>CATEGORY<;>MATERIAL<;>COLOR<;>SHAPE<;>SIZE<;>USE<;>SEX<;>PLATING<;>CLARITY<;>WEIGHT<;>CUT<;>STONE<;>STRAP<;>ODOUR",aINParams);
	addtexttoarea("<;>FIRST_LEVEL_CATEGORY<;>SECOND_LEVEL_CATEGORY<;>THIRD_LEVEL_CATEGORY<;>BTRX_MATERIAL<;>INTER_CATEGORY<;>BTRX_PLATING<;>WATCH_MEHANISM<;>POWER_RESERVE<;>BTRX_STRAP<;>STRAP_COLUR<;>PLACER_SCATT",aINParams);
	addtexttoarea("<;>BTRX_COLOR<;>BTRX_ODOUR<;>PHONE_MODEL<;>BTRX_TYPE<;>STRAP_MATERIAL<;>COLLECTION<;>FILLING<;>BTRX_SEX<;>BTRX_SIZE<;>DEPTH<;>WIDTH<;>HEIGHT<;>DIAMETR<;>VOLUME<;>BTRX_WEIGHT",aINParams);
	addtexttoarea("<;>PROD_COLOR<;>CHAIN_MATERIAL<;>WATCH_GRADE_A<;>WATCH_GRADE_B<;>WATCH_GRADE_C<;>STONE_A<;>STONE_SCATT_A<;>STONE_B<;>SCATT_B<;>STONE_C<;>STONE_SCATT_C",aINParams);
	addtexttoarea("<;>BRACEL_MATERIAL<;>WATER_RESIST<;>SET_QUANT<;>FINGER_GIRTH<;>LIMITE_DGOOD" & chr(13) & chr(10),aINParams);

  blockload(Compb);
  rwcnt = matrowcnt(Compb);
  for(i=1;i<=rwcnt;i=i+1)begin	
  	setcompany(i,false);
  	matrowget(Compb,i-1,Comprw);
  	incomp = true;
  	if((CompanyIsJWLikeCompany(i) and i!=3))then begin
  		incomp = false;
  	end;
  	if(i==10)then begin
  		incomp = false;
  	end;
  	if(Comprw.ActiveStatus!=0)then begin
  		incomp = false;
  	end;
  	
  	logtext(0,Currentcompany);
  	if(incomp)then begin
  		resetloop(INr);
  		while(loopmain(INr,1,true))begin
  			if(nonblank(INr.BPIBrand) and nonblank(INr.BPICategory))then begin
					addtexttoarea(vClass[INr.BPIGroup] & "<;>",aINParams);
					addtexttoarea(vClass[INr.BPISubGroup] & "<;>",aINParams);
					addtexttoarea(vClass[INr.BPICollection] & "<;>",aINParams);
					addtexttoarea(vClass[INr.BPICategory] & "<;>",aINParams);
					addtexttoarea(vClass[INr.BPIMaterial] & "<;>",aINParams);
					addtexttoarea(vClass[INr.BPIColor] & "<;>",aINParams);
					addtexttoarea(vClass[INr.BPIShape] & "<;>",aINParams);
					addtexttoarea(vClass[INr.BPISize] & "<;>",aINParams);
					addtexttoarea(vClass[INr.BPIUse] & "<;>",aINParams);
					addtexttoarea(vClass[INr.BPISex] & "<;>",aINParams);
					addtexttoarea(vClass[INr.BPIPlating] & "<;>",aINParams);
					addtexttoarea(vClass[INr.BPIClarity] & "<;>",aINParams);
					addtexttoarea(vClass[INr.BPIWeight] & "<;>",aINParams);
					addtexttoarea(vClass[INr.BPICut] & "<;>",aINParams);
					addtexttoarea(vClass[INr.BPIStone] & "<;>",aINParams);
					addtexttoarea(vClass[INr.BPIStrap] & "<;>",aINParams);
					addtexttoarea(vClass[INr.BPIOdour] & "<;>",aINParams);
					GIr.Code = INr.BPIBrand & "_" & INr.Code;
					if(ReadFirstMain(GIr,1,true) and nonblank(GIr.BTRxFirstLevCat)) then begin	
						addtexttoarea(vClass[GIr.BTRxFirstLevCat] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxSecondLevCat] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxThirdLevCat] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BPIMaterial] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxInterCatClass] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BPIPlating] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxWatchMechanism] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxPowerReserve] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BPIStrap] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxStrapColour] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxPlacerScatt] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BPIColor] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BPIOdour] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxPhoneModel] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxType] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxStrapMat] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BtrxCollection] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxFilling] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BPISex] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BPISize] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.StrDepth] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.StrWidth] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.StrHeight] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.StrBTRxDiam] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.StrVolume] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.StrWeight] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxProdColour] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxChainMaterial] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxWatchGradeA] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxWatchGradeB] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxWatchGradeC] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxStoneA] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxStoneScattA] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxStoneB] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxStoneScattB] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxStoneC] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxStoneScattC] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxBracelMat] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxWatterRes] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.StrBTRxSetQty] & "<;>",aINParams);
						addtexttoarea(vClass[GIr.BTRxFingerGirth] & "<;>",aINParams);
						addtexttoarea(vClass[INr.BTRxLimitedGood] & "<;>",aINParams);
					end;
					addtexttoarea(chr(13) & chr(10),aINParams);
				end;	
  		end;
  	end;
  end;
	
	writeareatofile(aINParams,"AllBenchMark.txt",0);
	
	weboutstring("Done");
return;
end;

global 
webpublic updating procedure WebDelAllBPU()
begin
record BigPUVc BPUr;

weboutstring("Begin");
SetCompany(18,false);
BPUr.SerNr = -1;
while(LoopMain(BPUr,1,true)) begin
	RecordDelete(BPUr);
	StepBack(BPUr);
end;	
weboutstring("Done");
return;
end;

global 
updating procedure FillAltCodeItemMn()
begin
record INVc INr;
record ConsItemVc ConsIr;

INr.Code = "";
while(LoopMain(INr,1,true)) begin
	//if(Blank(INr.AlternativeCode)) then begin
		ConsIr.Code = INr.Code;
		if(readfirstMain(ConsIr,1,true))then begin
			if(blank(INr.BarCode)) then begin
				INr.BarCode = INr.AlternativeCode;
			end;
			INr.AlternativeCode = ConsIr.LocCode;
			RecordStore(INr,true);
		end;
	//end;	
end;	
return;
end;
/*global 
webpublic updating procedure WebUpdAllINVc()
begin
record INVc INr;
boolean incomp;
record CompaniesBlock Compb;
row CompaniesBlock Comprw;
integer i,rwcnt;
weboutstring("Begin");
	blockload(Compb);
  rwcnt = matrowcnt(Compb);
for(i=1;i<=rwcnt;i=i+1)begin	
  	setcompany(i,false);
  	matrowget(Compb,i-1,Comprw);
  	incomp = true;
  	if((CompanyIsJWLikeCompany(i) and i!=3))then begin
  		incomp = false;
  	end;
  	if(i==10)then begin
  		incomp = false;
  	end;
  	if(Comprw.ActiveStatus!=0)then begin
  		incomp = false;
  	end;
  	
  	logtext(0,Currentcompany);
  	if(incomp)then begin
			INr.Code = "";
			while(LoopMain(INr,1,true)) begin
				if(INr.UpdateCost==0 or INr.SRUpdateCost==0) then begin
					INr.UpdateCost = 1;
					INr.SRUpdateCost = 1;
					RecordStore(INr,true);
				end;
			end;
			ResetLoop(INr);
		end;
end;		
weboutstring("Done");

return;
end;*/

procedure addheadertoexport(integer i)
begin
	
	exportstring("compnr");
	ExportPadString(i & chr(13) & chr(10),len(i & chr(13) & chr(9)),"",false);
	ExportPadString(chr(13) & chr(10),2,"",false);
	ExportPadString("format" & chr(13) & chr(10),len("format")+2,"",false);
	ExportPadString("1	46	1	1	0	0	0	/	" & chr(13) & chr(10),len("1	46	1	1	0	0	0	/	")+2,"",false);
	ExportPadString(chr(13) & chr(10),2,"",false);
	ExportPadString("codepage	UTF-8	" & chr(13) & chr(10),len("codepage	UTF-8	")+2,"",false);
	ExportPadString(chr(13) & chr(10),2,"",false);

return;
end;

global webpublic procedure WebExportAnyReg()
begin
	string 100 regname,blockname,dirrname;
	integer i,CompQty;
	record CompaniesBlock Compb;
	row CompaniesBlock Comprw;
	
	BlockLoad(Compb);	
	
	regname = WebGetArg("regname");
	blockname = WebGetArg("blockname");
	
	
	if(blank(regname) and blank(blockname))then begin
		WebOutString("regname or blockname");
	end else begin	
		if(nonblank(regname))then begin
			CompQty = matrowcnt(Compb);
			dirrname = "ExportData";
			if (!DirExists(dirrname)) then begin
				CreateFolder(dirrname);
			end;
			for (i=0;i<CompQty;i=i+1) begin
				matrowget(Compb,i,Comprw);
				if(Comprw.ActiveStatus==0) then begin
					SetCompany(i+1,false);
					createfile(dirrname & "\\" & regname & i+1 & ".txt");
					logtext(0,dirrname & "\\" & regname & i+1 & ".txt");
					CloseFile;
					openexportfile(dirrname & "\\" & regname & i+1 & ".txt",true);
					addheadertoexport(i+1);
					RegisterExport(regname);
					CloseFile;
				end;
			end;
		end;
		if(nonblank(blockname))then begin
			CompQty = matrowcnt(Compb);
			dirrname = "ExportData";
			if (!DirExists(dirrname)) then begin
				CreateFolder(dirrname);
			end;
			for (i=0;i<CompQty;i=i+1) begin
				matrowget(Compb,i,Comprw);
				if(Comprw.ActiveStatus==0) then begin
					SetCompany(i+1,false);
					createfile(dirrname & "\\" & blockname & i+1 & ".txt");
					CloseFile;
					openexportfile(dirrname & "\\" & blockname & i+1 & ".txt",true);
					addheadertoexport(i+1);
					BlockExport(blockname);
					CloseFile;
				end;
			end;
		end;
	end;
	runprogram("chmod","-R a+rw ExportData");
return;
end;


global webpublic procedure WebWriteRegistersFiles()
begin
integer i,curcomp,CompQty;
record CompaniesBlock Compb;
row CompaniesBlock Comprw;
area PayMode,PayDeal,Buttons,Controll;
string 255 filename;
record PDVc PayDealr; //условия оплаты
record PMBlock PMRec;
record POSButtonsVc POSr;
record OTCheckBlock OTCr;
record AccBlock Accb;
	
	BlockLoad(Accb);
	BlockLoad(PMRec);
	BlockLoad(Compb);	
	BlockLoad(OTCr);	
	CompQty = matrowcnt(Compb);
	curcomp = currentcompany;
	
	filename = "NewFileData\\";
		for (i=0;i<CompQty;i=i+1) begin
			matrowget(Compb,i,Comprw);
			if(Comprw.ActiveStatus==0) then begin
				SetCompany(i+1,false);
					/*PayDealr.Code = "";
					While(LoopMain(PayDealr,1,true)) begin 
						AddRecordToArea(PayDealr,"PDVc",PayDeal);
					end;
					if(CountRecords("PDVc")>0) then begin
						writeareatofile(PayDeal,filename & i+1 & "PayDeal.txt",0);
					end;	
					setareazerosize(PayDeal);
					ResetLoop(PayDealr);

					POSr.Page = -1;
					While(LoopKey("Page",POSr,1,true)) begin 
						AddRecordToArea(POSr,"POSButtonsVc",Buttons);
					end;
					ResetLoop(POSr);
					if(CountRecords("POSButtonsVc")>0) then begin
						writeareatofile(Buttons,filename & i+1 & "POSButton.txt",0);
					end;	
					setareazerosize(Buttons);
					*/
					
					/*createfile(filename & i+1 & "OTCheckBlock.txt");
					CloseFile;
					openexportfile(filename & i+1 & "OTCheckBlock.txt",true);
					addheadertoexport(i+1);
					BlockExport("OTCheckBlock");
					closefile*/
					
					createfile(filename & i+1 & "PDVc.txt");
					CloseFile;
					openexportfile(filename & i+1 & "PDVc.txt",true);
					addheadertoexport(i+1);
					RegisterExport("PDVc");
					CloseFile;
					
					/*createfile(filename & i+1 & "POSButtonsVc.txt");
					CloseFile;
					openexportfile(filename & i+1 & "POSButtonsVc.txt",true);
					addheadertoexport(i+1);
					RegisterExport("POSButtonsVc");
					CloseFile;*/
					
					createfile(filename & i+1 & "PMBlock.txt");
					CloseFile;
					openexportfile(filename & i+1 & "PMBlock.txt",true);
					addheadertoexport(i+1);
					BlockExport("PMBlock");
					closefile;
					
					createfile(filename & i+1 & "VATCodeBlock.txt");
					CloseFile;
					openexportfile(filename & i+1 & "VATCodeBlock.txt",true);
					addheadertoexport(i+1);
					BlockExport("VATCodeBlock");
					closefile;
										
					/*createfile(filename & i+1 & "AccBlock.txt");
					CloseFile;
					openexportfile(filename & i+1 & "AccBlock.txt",true);
					addheadertoexport(i+1);
					BlockExport("AccBlock");
					closefile;*/
					
					
			end;
		end;	
return;
end;


global webpublic procedure WebWriteRegistersTRVcFiles()
begin
integer i,curcomp,CompQty;
record CompaniesBlock Compb;
row CompaniesBlock Comprw;
area PayMode,PayDeal,Buttons,Controll;
string 255 filename;
record PDVc PayDealr; //условия оплаты
record PMBlock PMRec;
record POSButtonsVc POSr;
record OTCheckBlock OTCr;
BlockLoad(PMRec);
	BlockLoad(Compb);	
	BlockLoad(OTCr);	
	CompQty = matrowcnt(Compb);
	curcomp = currentcompany;
	
	filename = "NewFileDataTRVc\\";
		for (i=0;i<CompQty;i=i+1) begin
			matrowget(Compb,i,Comprw);
			if(Comprw.ActiveStatus==0) then begin
				SetCompany(i+1,false);
					
					createfile(filename & i+1 & "TRVc.txt");
					CloseFile;
					openexportfile(filename & i+1 & "TRVc.txt",true);
					addheadertoexport(i+1);
					RegisterExport("TRVc");
					CloseFile;
					
			end;
		end;	
return;
end;





global webpublic procedure WebWriteRegistersPeriodFiles()
begin
integer i,curcomp,CompQty;
record CompaniesBlock Compb;
row CompaniesBlock Comprw;
area PayMode,PayDeal,Buttons,Controll;
string 255 filename;
record PDVc PayDealr; //условия оплаты
record PMBlock PMRec;
record POSButtonsVc POSr;
record PeriodBlock OTCr;

	BlockLoad(PMRec);
	BlockLoad(Compb);	
	
	CompQty = matrowcnt(Compb);
	curcomp = currentcompany;
	
	filename = "NewFileDataPeriod\\";
		for (i=0;i<CompQty;i=i+1) begin
			matrowget(Compb,i,Comprw);
			if(Comprw.ActiveStatus==0) then begin
				SetCompany(i+1,false);
					BlockLoad(OTCr);	
					
					createfile(filename & i+1 & "PeriodBlock.txt");
					CloseFile;
					openexportfile(filename & i+1 & "PeriodBlock.txt",true);
					addheadertoexport(i+1);
					BlockExport("PeriodBlock");
					CloseFile;
					
			end;
		end;	
return;
end;

global 
webpublic procedure WebFindINV()
begin
record CompaniesBlock Compb;
row CompaniesBlock Comprw;
integer i,rwcnt;
record IPVc IVr;

blockload(Compb);
  rwcnt = matrowcnt(Compb);
	
	for(i=1;i<=rwcnt;i=i+1)begin	
		matrowget(Compb,i,Comprw);
		if(Comprw.ActiveStatus==0)then begin
			SetCompany(i+1,false);
			resetloop(IVr);
			IVr.TransDate = currentdate;
			while(loopkey("TransDate",IVr,1,true))begin
				if(IVr.OKFlag==1)then begin
					weboutstring("Company " & Comprw.CompName & " invoice " & IVr.SerNr & " time " & "<BR>");
				end;
			end;
		end;
	end;
	
return;
end;

global 
webpublic procedure WebCreateFolders()
begin
record BPIBrandVc BPBr;
string 255 name;
integer i;

weboutstring("begin");
BPBr.Code = "";
while(LoopMain(BPBr,1,true)) begin
name = "";
	for(i=0;i<len(BPBr.Name);i=i+1) begin
		if((ASC(mid(BPBr.Name,i,1)) >= 65 and ASC(mid(BPBr.Name,i,1)) <= 90  ) or ( ASC(mid(BPBr.Name,i,1)) >= 97 and  ASC(mid(BPBr.Name,i,1)) <= 122 ) or (ASC(mid(BPBr.Name,i,1))==95)) then begin
			name = name & mid(BPBr.Name,i,1);
		end else begin
			name = name & "_";
		end;
	end;
	CreateFolder("webcust\\BRND_" & name);
end;
weboutstring("end");
return;
end;



// global webpublic updating procedure WebRestoreItemNames()
// begin
// integer i,curcomp,CompQty;
// record CompaniesBlock Compb;
// row CompaniesBlock Comprw;
// area PayMode,PayDeal,Buttons,Controll;
// record INVc INr,oldINr;
// record RhistVc RHr,lastRHr;
// string 255 tstr;
// boolean TrHs,testf,isupd;


	// BlockLoad(Compb);	
	
	// //i = -1;
	// i = stringtoint(webgetarg("compnr"));
	// isupd = webgetarg("isupd")=="update";
	
	// CompQty = matrowcnt(Compb);
	// curcomp = currentcompany;
		// if(i>0)then begin
			// //i = 7;
			// matrowget(Compb,i,Comprw);
			// if(Comprw.ActiveStatus==0) then begin
				// if(!CompanyIsJWLikeCompany(i+1) or i==2)then begin
					// SetCompany(i+1,false);
					// resetloop(INr);
					// INr.Code = "";
					// while(loopmain(INr,1,true))begin
						// tstr = BuildRecordIdStr(INr,currentcompany);
						// resetloop(RHr);
						// RHr.RecidStr = tstr;
						// TrHs = true;
						
						// while(loopbackkey("RecidStr",RHr,1,TrHs))begin
							// testf = true;
							// if(RHr.RecidStr!=tstr)then begin TrHs = false; testf = false; end;
							// if(RHr.accode==7)then begin testf = false; end;
							
							// if(testf)then begin
								// if(RHr.TransDate<stringtodate("25/04/2019"))then begin
									// TrHs = false;
								// end;
								// if(TrHs)then begin
								 // recordcopy(lastRHr,RHr);
								// end;
							// end;
						// end;
						// if(lastRHr.RecidStr==tstr)then begin
							// ReadOriginalRecord(lastRHr,oldINr);
							// if(oldINr.Code==INr.Code and oldINr.Name!=INr.Name and lastRHr.TransDate<=stringtodate("5/5/2019"))then begin
								// if(asc(left(INr.Name,1))>128)then begin
									// weboutstring(Comprw.CompName & "---" & INr.Code & "---" & INr.Name & "---" & lastRHr.TransDate & " oldname========== " & oldINr.Name);
									// weboutstring("<BR>");
									// if(isupd)then begin
										// INr.Name = oldINr.Name;
										// recordstore(INr,true);
									// end;
								// end;
							// end;
						// end;
					// end;
				// end;
			// end;
		// end;	
// return;
// end;






global 
webpublic updating procedure WebRestoreCCItemNames()
begin
integer i,curcomp,CompQty,consComp;
record CompaniesBlock Compb;
row CompaniesBlock Comprw;
area PayMode,PayDeal,Buttons,Controll;
record INVc INr,CINr;
record RhistVc RHr,lastRHr;
string 255 tstr;
boolean TrHs,testf,isupd;
record ConsItemVc CIr;

	

	BlockLoad(Compb);	
	
	i = -1;
	i = stringtoint(webgetarg("compnr"));
	isupd = webgetarg("isupd")=="update";
	
	CompQty = matrowcnt(Compb);
	curcomp = i;
	consComp = 18;
		if(i>0)then begin
			//i = 7;
			logtext(0,"Start");
			matrowget(Compb,i-1,Comprw);
			if(Comprw.ActiveStatus==0) then begin
				if(!CompanyIsJWLikeCompany(i) or i==3)then begin
					SetCompany(i,false);
					resetloop(INr);
					INr.Code = "";
					while(loopmain(INr,1,true))begin
						resetloop(RHr);
						SetCompany(consComp,false);
						CIr.LocCode = INr.Code;
						CIr.BrandCode = INr.BPIBrand;
						if(ReadFirstKey("LocCodeBrand",CIr,2,true))then begin
							CINr.Code = CIr.Code;
							if(ReadFirstMain(CINr,1,true))then begin
								if(CINr.Name!=INr.Name)then begin
									logtext(0, "OldName ----> " & CINr.Name & "  NewName ----->" & INr.Name);
									weboutstring( "OldName ----> " & CINr.Name & "  ("  & CIr.LocCode & "  " & CIr.BrandCode & ")  NewName -----> " & INr.Name & "  ("  & INr.Code &"  " & INr.BPIBrand & ")  CompName ----> " & Comprw.CompName);
									weboutstring("<BR>");
									CINr.Name = INr.Name;
									if(isupd)then begin
										RecordStore(CINr,true);
									end;
								end;
							end;
						end;
						ResetCompany(curcomp);
					end;
				end;
			end;
			logtext(0,"Stop");
		end;	

return;
end;


global webpublic updating procedure WebRestoreItemNames()
begin
integer i,curcomp,CompQty;
record CompaniesBlock Compb;
row CompaniesBlock Comprw;
area PayMode,PayDeal,Buttons,Controll;
record INVc INr,oldINr;
record RhistVc RHr,lastRHr;
string 255 tstr;
boolean TrHs,testf,isupd;


	BlockLoad(Compb);	
	
	i = -1;
	i = stringtoint(webgetarg("compnr"));
	isupd = webgetarg("isupd")=="update";
	
	CompQty = matrowcnt(Compb);
	curcomp = currentcompany;
		if(i>0)then begin
			//i = 7;
			logtext(0,"Start");
			matrowget(Compb,i-1,Comprw);
			if(Comprw.ActiveStatus==0) then begin
				if(!CompanyIsJWLikeCompany(i) or i==3)then begin
					SetCompany(i,false);
					resetloop(INr);
					INr.Code = "";
					while(loopmain(INr,1,true))begin
						tstr = BuildRecordIdStr(INr,currentcompany);
						resetloop(RHr);
						RHr.RecidStr = tstr;
						TrHs = true;
						
						while(loopbackkey("RecidStr",RHr,1,TrHs))begin
							testf = true;
							if(RHr.RecidStr!=tstr)then begin TrHs = false; testf = false; end;
							if(RHr.accode==7)then begin testf = false; end;
							
							if(testf)then begin
								if(RHr.TransDate<stringtodate("25/04/2019"))then begin
									TrHs = false;
								end;
								if(TrHs)then begin
								 recordcopy(lastRHr,RHr);
								end;
							end;
						end;
						if(lastRHr.RecidStr==tstr)then begin
							ReadOriginalRecord(lastRHr,oldINr);
							if(oldINr.Code==INr.Code and oldINr.Name!=INr.Name and lastRHr.TransDate<=stringtodate("5/5/2019") and left(lastRHr.User,2)=="SA")then begin
								weboutstring(Comprw.CompName & "---" & INr.Code & "---" & INr.Name & "---" & lastRHr.TransDate & " oldname ========== " & oldINr.Name);
								logtext(0,Comprw.CompName & "---" & INr.Code & "---" & INr.Name & "---" & lastRHr.TransDate & " oldname ========== " & oldINr.Name);
								weboutstring("<BR>");
								if(isupd)then begin
									INr.Name = oldINr.Name;
									recordstore(INr,true);
								end;
							end;
						end;
					end;
				end;
			end;
			logtext(0,"Stop");
		end;	
return;
end;








global webpublic updating procedure WebReportItemNames()
begin
integer i,curcomp,CompQty;
record CompaniesBlock Compb;
row CompaniesBlock Comprw;
area PayMode,PayDeal,Buttons,Controll;
record INVc INr,oldINr;
record RhistVc RHr,lastRHr;
string 255 tstr;
boolean TrHs,testf,isupd;

	logtext(0,"Start");

	BlockLoad(Compb);	
	
	//i = -1;
	i = stringtoint(webgetarg("compnr"));
	isupd = webgetarg("isupd")=="update";
	
	CompQty = matrowcnt(Compb);
	curcomp = currentcompany;
		// if(i>0)then begin
		// i = 7;
		for (i=0;i<CompQty;i=i+1) begin
			matrowget(Compb,i,Comprw);
			if(Comprw.ActiveStatus==0) then begin
				if(!CompanyIsJWLikeCompany(i+1) or i==2)then begin
					SetCompany(i+1,false);
					resetloop(INr);
					INr.Code = "";
					while(loopmain(INr,1,true))begin
						tstr = BuildRecordIdStr(INr,currentcompany);
						resetloop(RHr);
						RHr.RecidStr = tstr;
						TrHs = true;
						
						while(loopbackkey("RecidStr",RHr,1,TrHs))begin
							testf = true;
							if(RHr.RecidStr!=tstr)then begin TrHs = false; testf = false; end;
							if(RHr.accode==7)then begin testf = false; end;
							
							if(testf)then begin
								if(RHr.TransDate>stringtodate("5/05/2019"))then begin
									testf = false;
								end;
								if(RHr.TransDate<stringtodate("1/03/2019"))then begin
									TrHs = false;
									testf = false;
								end;
								if(TrHs and testf)then begin
									recordcopy(lastRHr,RHr);
								end;
							end;
						end;
						ResetLoop(INr);
						if(lastRHr.RecidStr==tstr)then begin
							ReadOriginalRecord(lastRHr,oldINr);
							if(oldINr.Code==INr.Code and oldINr.Name!=INr.Name and left(lastRHr.User,2)=="SA")then begin
								weboutstring(Comprw.CompName & "---" & INr.Code & "---" & INr.Name & "---" & lastRHr.TransDate & " oldname========== " & oldINr.Name);
								logtext(0,Comprw.CompName & "---" & INr.Code & "---" & INr.Name & "---" & lastRHr.TransDate & " oldname========== " & oldINr.Name);
								weboutstring("<BR>");
								/*if(isupd)then begin
									INr.Name = oldINr.Name;
									recordstore(INr,true);
								end;*/
							end;
						end;
					end;
				end;
			end;
		end;	
	logtext(0,"End");
return;
end;



global webpublic updating procedure WebConcPlacesInCWH7()
begin
	record BPIBrandVc BPIBrandr;
	boolean TrHs;

	SetCompany(18,false);
	
	BPIBrandr.Code = "";
	TrHs = true;
	while (LoopMain(BPIBrandr,1,TrHs)) begin
		if(BPIBrandr.CWHCode == "CWH9" or BPIBrandr.CWHCode == "CWH10" or BPIBrandr.CWHCode == "CWH11") then begin
			logtext(0,BPIBrandr.Code & "  <>  " & BPIBrandr.CWHCode);
			BPIBrandr.CWHCode = "CWH7";
			recordStore(BPIBrandr,true);
		end;
	end;
	resetloop(BPIBrandr);
	return;
end;

global updating 
procedure CollectVIDaySaleMn(record RcVc RepSpec)
begin
record TRVc TRr,AccTRr,AccTRrCC;
row TRVc TRrw,AccTRrw;
record VIVc VIr,oldVIr;
row VIVc VIrw;
boolean TrHs,testf,TrHs2,testBrand;
integer cntrw,i,j,oscnt,rowCnt,oldCompany,comp,CompQty;
vector val saleSum,sumVi,saleSumRow;
val ct;
string 255 vewarn,tstr,obj,objects;
array string 255 tags,tags1;
array string 20 stores,brand;
record SHVc SHr;
record RetVc Retr;
record IVVc IVr;
vector string 255 upd,brandObj;
vector boolean brands,create;
record BrandsBanDateBlock BBBr;
row BrandsBanDateBlock BBBrw;
record CompaniesBlock Compb;
row CompaniesBlock Comprw;
date loopDate;
integer rownr,curAccDiffIntYc;
val tmpval;
boolean createTr;
longint corrTRrNum;
val Acc60,Acc61;
record SDVc SDr;
record LocationVc Locr;
string 255 fobCust;

testf = true;
oldCompany = currentCompany;
setCompany(18,false);
blockload(BBBr);
BlockLoad(Compb);
ResetCompany(oldCompany);
CompQty = matrowcnt(Compb);
//-------------------------------Brands allowed-------------------------------------
//----------------------------------------------------------------------------------
logtext(0,"Start ");
curAccDiffIntYc = 301;
loopDate = RepSpec.sStartDate;
for(comp=0;comp<CompQty;comp=comp+1) begin
	matrowget(Compb,comp,Comprw);
	if(Comprw.ActiveStatus==0  and comp+1!=33 and comp+1!=29) then begin 
		SetCompany(comp+1,false);
		RecordClear(AccTRr);
		AccTRr.IntYc = curAccDiffIntYc;
		resetloop(AccTRr);
		TrHs = true;
		while(loopkey("IntYc",AccTRr,1,TrHs)) begin
			if (AccTRr.IntYc!=curAccDiffIntYc) then begin TrHs = false; end;
			if (TrHs) and (AccTRr.TransDate>=RepSpec.sStartDate) and (AccTRr.TransDate<=RepSpec.sEndDate) then begin
				DeleteTransaction(AccTRr.Number,AccTRr.IntYc);
				stepback(AccTRr);
			end;
		end;
	end;	
end;	

while(loopDate<=RepSpec.sEndDate) begin
	for(comp=0;comp<CompQty;comp=comp+1) begin
		matrowget(Compb,comp,Comprw);
		if(Comprw.ActiveStatus==0 and comp+1!=18 and comp+1!=33 and comp+1!=29) then begin 
			SetCompany(comp+1,false);
			logtext(0,comp+1);
			createTr = false;
			RecordClear(AccTRrCC);
			RecordClear(AccTRr);
			RecordNew(AccTRr);
			RecordNew(AccTRrCC);
			AccTRr.TransDate = loopDate;
			AccTRr.IntYc = curAccDiffIntYc;
			TRr.Number = 9999999;
			TRr.IntYc = curAccDiffIntYc;
			TrHs = true;
			corrTRrNum = -1;
			while(LoopBackKey("Number",TRr,2,TrHs)) begin
				if(TRr.IntYc==curAccDiffIntYc) then begin
					TrHs = false;
					corrTRrNum = TRr.Number;
				end else begin 
					TrHs = false;
				end;
			end;
			ResetLoop(TRr);
			if (corrTRrNum<0) then begin
				corrTRrNum = 1;
			end else begin
				corrTRrNum = corrTRrNum + 1;
			end;
			AccTRr.Number = corrTRrNum;
			AccTRr.Comment = "Отмена кредиторов(не редактировать эту запись)";
			AccTRr.RegDate = loopDate;
			AccTRr.RegTime = CurrentTime;
			rownr = 0;
			TRr.TransDate = loopDate;
			VIr.VECode = "FOB_SKLAD";
			VIr.TransDate = loopDate;
			TrHs2 = true;
			while(loopkey("VECodeTransDate",VIr,2,TrHs2)) begin
				testf = true;
				if(VIr.TransDate>loopDate) then begin testf = false; TrHs2 = false; end;
				if(VIr.VECode!="FOB_SKLAD" or VIr.OKPersons != "AUTO") then begin testf = false; end;
				if(testf) then begin
					obj = "";
					ExtractObjectsByType(VIr.Objects,"STORE",stores,oscnt);
					obj = stores[0];
					if(blank(obj)) then begin obj = "blank"; end;
					sumVi[obj] = sumVi[obj] + VIr.PayVal;
					upd[obj] = VIr.SerNr;
				end;
			end;
			ResetLoop(VIr);
			ResetLoop(TRr);
			TrHs = true;
			while(loopkey("TransDate",TRr,1,TrHs)) begin
				fobCust = "";
				testf = true;
				if(TRr.TransDate>loopDate) then begin testf = false; TrHs = false; end;
				if(TRr.IntYc!=SHYc and TRr.IntYc!=RetYc and TRr.IntYc!=IVYc and TRr.IntYc!=SDYc) then begin testf=false; end;
				if(testf) then begin 
					switch(TRr.IntYc) begin
						case SHYc: SHr.SerNr = TRr.Number;
								if(ReadFirstMain(SHr,1,true)) then begin
									if(SHr.CustCode=="FOBE_COMMERCE") then begin testf=false; end;
									Locr.Code = IVr.Location;
									if(ReadFirstMain(Locr,1,true)) then begin
										fobCust = Locr.FOBSuplier;
									end;
								end;
						case 	RetYc	: Retr.SerNr = TRr.Number;
								if(ReadFirstMain(Retr,1,true)) then begin
									if(Retr.CustCode=="FOBE_COMMERCE") then begin testf=false; end;
									Locr.Code = IVr.Location;
									if(ReadFirstMain(Locr,1,true)) then begin
										fobCust = Locr.FOBSuplier;
									end;
								end;
						case 	IVYc	: IVr.SerNr = TRr.Number;
								if(ReadFirstMain(IVr,1,true)) then begin
									if(IVr.CustCode=="FOBE_COMMERCE") then begin testf=false; end;
									Locr.Code = IVr.Location;
									if(ReadFirstMain(Locr,1,true)) then begin
										fobCust = Locr.FOBSuplier;
									end;
								end;
						case 	SDYc	: SDr.SerNr = TRr.Number;
								if(ReadFirstMain(SDr,1,true)) then begin
									if(SetInSet("CENTRAL_RETURN",SDr.Objects)) then begin testf=false; end;
									Locr.Code = SDr.Location;
									if(ReadFirstMain(Locr,1,true)) then begin
										fobCust = Locr.FOBSuplier;
									end;
								end;
								
					end;			
				end;
				if(testf) then begin
					cntrw = matrowcnt(TRr);
					Acc60 = 0;
					Acc61 = 0;
					for(i=0;i<cntrw;i=i+1) begin
						matrowget(TRr,i,TRrw);
						if((TRrw.AccNumber=="45" or TRrw.AccNumber=="60" or TRrw.AccNumber=="61")and TRrw.ovst <> 1 and TRrw.stp==1) then begin
							obj = "";
							ExtractObjectsByType(TRrw.Objects,"STORE",stores,oscnt);
							obj = stores[0];
							ClearArray(brand);
							ExtractObjectsByType(TRrw.Objects,"BRAND",brand,oscnt);
							if(blank(obj)) then begin obj = "blank"; end;
							testBrand = false;
							rowCnt = matrowcnt(BBBr);
							for(j=0;j<rowCnt;j=j+1) begin
								matrowget(BBBr,j,BBBrw);
								if((SetInSet(brand[0],BBBrw.Object) or BBBrw.Object==brand[0]) and BBBrw.StartBanDate<=TRr.TransDate and nonblank(brand[0])) then begin testBrand = true; end;
							end;
							if(testBrand) then begin
								if(TRrw.AccNumber=="45") then begin
									if(TRr.IntYc!=SDYc) then begin
										saleSum[obj] = saleSum[obj] + TRrw.DebVal;
										saleSum[obj] = saleSum[obj] - TRrw.CredVal;
										brandObj[obj & brand[0]] = brand[0];
										saleSumRow[obj & brand[0]] = saleSumRow[obj & brand[0]] + TRrw.DebVal;
										saleSumRow[obj & brand[0]] = saleSumRow[obj & brand[0]] - TRrw.CredVal;
										create[obj] = true;
										brands[brand[0]] = true;
									end;	
								end else begin
									if(TRrw.AccNumber=="60") then begin
										Acc60 = TRrw.DebVal - TRrw.CredVal;
										matrowput(TRr,i,TRrw);
										matrowget(TRr,i+1,TRrw);
										if(TRrw.AccNumber=="61") then begin								
											Acc61 = TRrw.DebVal - TRrw.CredVal;
											if(Acc61+Acc60 == 0) then begin
												matrowput(TRr,i+1,TRrw);
												matrowget(TRr,i,TRrw);
												if(TRrw.DebVal!=0) then begin
													TRrw.DebVal = TRrw.DebVal*(-1);
												end;	
												if(TRrw.CredVal!=0) then begin
													TRrw.CredVal = TRrw.CredVal*(-1);
												end;	
												if(TRrw.CurDebVal!=0) then begin
													TRrw.CurDebVal = TRrw.CurDebVal*(-1);
												end;	
												if(TRrw.CurCredVal!=0) then begin
													TRrw.CurCredVal = TRrw.CurCredVal*(-1);
												end;	
												MatrowPut(AccTRr,rownr,TRrw);
												Matrowget(AccTRr,rownr,TRrw);
												ExtractObjectsByType(TRrw.Objects,"STORE",stores,oscnt);
												obj = stores[0];
												TRrw.Objects = RemoveObjectFromObjectList(TRrw.Objects,obj);
												TRrw.Objects = AddObjectToObjectList(TRrw.Objects,fobCust);
												TRrw.Objects = AddObjectToObjectList(TRrw.Objects,"CC");
												MatRowInsert(AccTRrCC,rownr,TRrw);
												MatrowPut(AccTRrCC,rownr,TRrw);
												rownr = rownr + 1;
												matrowget(TRr,i+1,TRrw);
												if(TRrw.DebVal!=0) then begin
													TRrw.DebVal = TRrw.DebVal*(-1);
												end;	
												if(TRrw.CredVal!=0) then begin
													TRrw.CredVal = TRrw.CredVal*(-1);
												end;	
												if(TRrw.CurDebVal!=0) then begin
													TRrw.CurDebVal = TRrw.CurDebVal*(-1);
												end;	
												if(TRrw.CurCredVal!=0) then begin
													TRrw.CurCredVal = TRrw.CurCredVal*(-1);
												end;	
												MatrowPut(AccTRr,rownr,TRrw);
												Matrowget(AccTRr,rownr,TRrw);
												ExtractObjectsByType(TRrw.Objects,"STORE",stores,oscnt);
												obj = stores[0];
												TRrw.Objects = RemoveObjectFromObjectList(TRrw.Objects,obj);
												TRrw.Objects = AddObjectToObjectList(TRrw.Objects,fobCust);
												TRrw.Objects = AddObjectToObjectList(TRrw.Objects,"CC");
												MatRowInsert(AccTRrCC,rownr,TRrw);
												MatrowPut(AccTRrCC,rownr,TRrw);
												rownr = rownr + 1;
												createTr = true;
											end;	
										end;
									end;	
								end;
							end;
						end;
					end;
				end;
			end;	

			if(createTr) then begin
				TRSumup(AccTRr,tmpval);
				RecordInsert(AccTRr,true);
				SetCompany(18,false);
				ResetLoop(TRr);
				TRr.Number = 9999999;
				TRr.IntYc = curAccDiffIntYc;
				TrHs = true;
				corrTRrNum = -1;
				while(LoopBackKey("Number",TRr,2,TrHs)) begin
					if(TRr.IntYc==curAccDiffIntYc) then begin
						TrHs = false;
						corrTRrNum = TRr.Number;
					end else begin 
						TrHs = false;
					end;
				end;
				if (corrTRrNum<0) then begin
					corrTRrNum = 1;
				end else begin
					corrTRrNum = corrTRrNum + 1;
				end;
				AccTRr.Number = corrTRrNum;
				for(i=0;i<matrowcnt(AccTRrCC);i=i+1) begin
					matrowget(AccTRrCC,i,TRrw);
					if(TRrw.DebVal!=0) then begin
						TRrw.DebVal = TRrw.DebVal*(-1);
					end;	
					if(TRrw.CredVal!=0) then begin
						TRrw.CredVal = TRrw.CredVal*(-1);
					end;	
					if(TRrw.CurDebVal!=0) then begin
						TRrw.CurDebVal = TRrw.CurDebVal*(-1);
					end;	
					if(TRrw.CurCredVal!=0) then begin
						TRrw.CurCredVal = TRrw.CurCredVal*(-1);
					end;	
					matrowput(AccTRr,i,TRrw);
				end;
				TRSumup(AccTRr,tmpval);
				RecordInsert(AccTRr,true);
				SetCompany(comp+1,false);
			END;
			ResetLoop(TRr);
			getvectortags(brands,tags1);
			getvectortags(saleSum,tags);
			if(tags.length>0) then begin 
				for(i=0;i<tags.length;i=i+1) begin
					if(create[tags[i]) then begin
						if(nonblank(upd[tags[i]])) then begin
							if(sumVi[tags[i]]!=saleSum[tags[i]]) then begin
								VIr.SerNr = upd[tags[i]];
								if(ReadFirstMain(VIr,1,true)) then begin
									RecordCopy(oldVIr,VIr);
									VIr.OKFlag = 0;
									if(RecordUpdate(oldVIr,VIr,true)==0) then begin end;
									RecordCopy(oldVIr,VIr);
									rowCnt = 0;
									for(j=0;j<tags1.length;j=j+1) begin
										if(nonblank(brandObj[tags[i] & tags1[j]])) then begin
											matRowget(VIr,rowCnt,VIrw);
											VIrw.Objects = tags[i] & "," & brandObj[tags[i] & tags1[j]];
											VIrw.AccNumber = "41/06";
											if (GetAccName(VIrw.AccNumber,tstr,60)) then begin end;
											VIrw.Comment = tstr; 
											VIrw.Sum = saleSumRow[tags[i] & tags1[j]];
											matrowput(VIr,rowCnt,VIrw);  
											rowCnt = rowCnt + 1;
										end;	
									end;	
									VICalcVals(VIr);
									VISumup(VIr,ct); 
									VIr.PayVal = VIr.PayVal - ct;
									VIVc_PastePayVal(VIr);
									if(RecordUpdate(oldVIr,VIr,true)==0) then begin end;
									if(saleSum[tags[i]]!=0) then begin
										RecordCopy(oldVIr,VIr);
										VIr.OKFlag = 1;
										if(RecordUpdate(oldVIr,VIr,true)==0) then begin end;
									end;	
								end;	
							end;
						end else begin	
							RecordNew(VIr);
							VIr.VECode = "FOB_SKLAD";
							VIVc_PasteVECode(VIr,0,false,true,vewarn);
							VIr.SerNr = NextSerNr("VIVc",currentdate,-1,false,""); 
							logtext(0,"new " & VIr.SerNr);
							VIr.TransDate = loopDate;
							if(blank(VIr.Objects) and tags[i]!="blank") then begin VIr.Objects = tags[i]; end;
							if(!SetInSet(tags[i],VIr.Objects) and tags[i]!="blank") then begin VIr.Objects = VIr.Objects & "," & tags[i]; end;
							rowCnt = 0;
							for(j=0;j<tags1.length;j=j+1) begin
								if(nonblank(brandObj[tags[i] & tags1[j]])) then begin
									VIrw.Objects = tags[i] & "," & brandObj[tags[i] & tags1[j]];
									VIrw.AccNumber = "41/06";
									if (GetAccName(VIrw.AccNumber,tstr,60)) then begin end;
									VIrw.Comment = tstr; 
									VIrw.Sum = saleSumRow[tags[i] & tags1[j]];
									matrowput(VIr,rowCnt,VIrw);  
									rowCnt = rowCnt + 1;
								end;	
							end;	
							VICalcVals(VIr);
							VISumup(VIr,ct); 
							VIr.PayVal = -ct;
							VIVc_PastePayVal(VIr);
							VIr.OKPersons = "AUTO";
							VIr.InvDate = loopDate;
							VIr.DueDate = loopDate;
							if (RecordInsert(VIr,true)) then begin end;
							RecordCopy(oldVIr,VIr);
							VIr.OKFlag = 1;
							if(RecordUpdate(oldVIr,VIr,true)==0) then begin  logtext(0,"VIr created " & VIr.SerNr & " company " & currentcompany); end;
						end;
					end;	
				end;	
			end;
			ClearVector(saleSum);
			ClearVector(sumVi);
			ClearVector(create);
			ClearVector(saleSumRow);
			ClearVector(brandObj);
			ClearVector(upd);
			ClearArray(tags);
			ClearArray(tags1);
		end;	
	end;	
	loopDate = AddDay(loopDate,1);
end;	
ResetCompany(oldCompany);
logtext(0,"fin ");
return;
end;

/*global updating
procedure CollectVIDaySaleRecalkMn(record RcVc RepSpec)
begin
record TRVc TRr;
row TRVc TRrw;
record VIVc VIr,oldVIr;
row VIVc VIrw;
boolean TrHs,testf,TrHs2,testBrand;
integer cntrw,i,j,oscnt,rowCnt,comp,oldComp,CompQty;
vector val saleSum,sumVi,saleSumRow;
val ct;
string 255 vewarn,tstr,obj,objects;
array string 255 tags,tags1;
array string 20 stores,brand;
record SHVc SHr;
record RetVc Retr;
record IVVc IVr;
vector string 255 upd,brandObj;
vector boolean brands,create;
date loopDate;
record CompaniesBlock Compb;
row CompaniesBlock Comprw;
record BrandsBanDateBlock BBBr;
row BrandsBanDateBlock BBBrw;
testf = true;
//-------------------------------Brands allowed-------------------------------------
//----------------------------------------------------------------------------------
BlockLoad(Compb);

oldComp = currentcompany;
SetCompany(18,false);
blockload(BBBr);
ResetCompany(oldComp);
CompQty = matrowcnt(Compb);

loopDate = RepSpec.sStartDate;
while(loopDate<=RepSpec.sEndDate) begin
	for(comp=0;comp<CompQty;comp=comp+1) begin
		matrowget(Compb,comp,Comprw);
		if(Comprw.ActiveStatus==0 and comp+1!=18 and comp+1!=33 and comp+1!=29) then begin 
			SetCompany(comp+1,false);
			logtext(0,comp+1);
			TRr.TransDate = loopDate;
			TrHs = true;
			VIr.VECode = "FOB_SKLAD";
			VIr.TransDate = loopDate;
			TrHs2 = true;
			while(loopkey("VECodeTransDate",VIr,2,TrHs2)) begin
				testf = true;
				if(VIr.TransDate>loopDate) then begin testf = false; TrHs2 = false; end;
				if(VIr.VECode!="FOB_SKLAD" or VIr.OKPersons != "AUTO") then begin testf = false; end;
				if(testf) then begin
					obj = "";
					ExtractObjectsByType(VIr.Objects,"STORE",stores,oscnt);
					obj = stores[0];
					if(blank(obj)) then begin obj = "blank"; end;
					upd[obj] = VIr.SerNr;
				end;
			end;
			ResetLoop(VIr);
			while(loopkey("TransDate",TRr,1,TrHs)) begin
				testf = true;
				if(TRr.TransDate>loopDate) then begin testf = false; TrHs = false; end;
				if(TRr.IntYc!=SHYc and TRr.IntYc!=RetYc and TRr.IntYc!=IVYc) then begin testf=false; end;
				if(testf) then begin 
					switch(TRr.IntYc) begin
						case SHYc: SHr.SerNr = TRr.Number;
								if(ReadFirstMain(SHr,1,true)) then begin
									if(SHr.CustCode=="FOBE_COMMERCE") then begin testf=false; end;
								end;
						case 	RetYc	: Retr.SerNr = TRr.Number;
								if(ReadFirstMain(Retr,1,true)) then begin
									if(Retr.CustCode=="FOBE_COMMERCE") then begin testf=false; end;
								end;
						case 	IVYc	: IVr.SerNr = TRr.Number;
								if(ReadFirstMain(IVr,1,true)) then begin
									if(IVr.CustCode=="FOBE_COMMERCE") then begin testf=false; end;
								end;
					end;			
				end;
				if(testf) then begin
					cntrw = matrowcnt(TRr);
					for(i=0;i<cntrw;i=i+1) begin
						matrowget(TRr,i,TRrw);
						if(TRrw.AccNumber=="45" and TRrw.ovst <> 1 and TRrw.stp==1) then begin
							obj = "";
							testBrand = false;
							ExtractObjectsByType(TRrw.Objects,"STORE",stores,oscnt);
							obj = stores[0];
							ClearArray(brand);
							ExtractObjectsByType(TRrw.Objects,"BRAND",brand,oscnt);
							if(blank(obj)) then begin obj = "blank"; end;
							rowCnt = matrowcnt(BBBr);
							for(j=0;j<rowCnt;j=j+1) begin
								matrowget(BBBr,j,BBBrw);
								if((SetInSet(brand[0],BBBrw.Object) or BBBrw.Object==brand[0]) and BBBrw.StartBanDate<=TRr.TransDate and nonblank(brand[0])) then begin testBrand = true; end;
							end;
							if(testBrand) then begin
								saleSum[obj] = saleSum[obj] + TRrw.DebVal;
								saleSum[obj] = saleSum[obj] - TRrw.CredVal;
								brandObj[obj & brand[0]] = brand[0];
								saleSumRow[obj & brand[0]] = saleSumRow[obj & brand[0]] + TRrw.DebVal;
								saleSumRow[obj & brand[0]] = saleSumRow[obj & brand[0]] - TRrw.CredVal;
								create[obj] = true;
								brands[brand[0]] = true;
							end;
						end;
					end;
				end;
			end;	
			ResetLoop(TRr);
			getvectortags(brands,tags1);
			getvectortags(saleSum,tags);
			if(tags.length>0) then begin 
				for(i=0;i<tags.length;i=i+1) begin
					if(create[tags[i]) then begin
						VIr.SerNr = upd[tags[i]];
						if(ReadFirstMain(VIr,1,true)) then begin
							RecordCopy(oldVIr,VIr);
							VIr.OKFlag = 0;
							if(RecordUpdate(oldVIr,VIr,true)==0) then begin end;
							RecordCopy(oldVIr,VIr);
							rowCnt = 0;
							for(j=matrowcnt(VIr);j>=0;j=j-1) begin
								MatRowDelete(VIr,j);
							end;
							for(j=0;j<tags1.length;j=j+1) begin
								if(nonblank(brandObj[tags[i] & tags1[j]])) then begin
									VIrw.Objects = tags[i] & "," & brandObj[tags[i] & tags1[j]];
									VIrw.AccNumber = "41/06";
									if (GetAccName(VIrw.AccNumber,tstr,60)) then begin end;
									VIrw.Comment = tstr; 
									VIrw.Sum = saleSumRow[tags[i] & tags1[j]];
									logtext(0,VIrw.Sum );
									matrowput(VIr,rowCnt,VIrw);  
									rowCnt = rowCnt + 1;
								end;	
							end;	
							VICalcVals(VIr);
							VISumup(VIr,ct); 
							VIr.PayVal = VIr.PayVal - ct;
							VIVc_PastePayVal(VIr);
							if(RecordUpdate(oldVIr,VIr,true)==0) then begin end;
							if(saleSum[tags[i]]!=0) then begin
								RecordCopy(oldVIr,VIr);
								VIr.OKFlag = 1;
								if(RecordUpdate(oldVIr,VIr,true)==0) then begin end;
							end;	
						end;	
					end;	
				end;	
			end;	
			ClearVector(saleSum);
			ClearVector(sumVi);
			ClearVector(create);
			ClearVector(saleSumRow);
			ClearVector(brandObj);
			ClearVector(upd);
			ClearArray(tags);
			ClearArray(tags1);
		end;
	end;
	loopDate = AddDay(loopDate,1);
end;	
ResetCompany(oldComp);	
return;
end;*/

global
updating procedure CreateINConsItem(string code, integer company)
begin
record INVc ConsINr,UINr,OldConsINr,INr;
record ConsItemVc CIr;
boolean TrHs2;
string 255 OldCode;

CIr.LocCode = code;
if(ReadFirstKey("LocCodeBrand",CIr,1,true)==false) then begin 
	SetCompany(company,false);
	INr.Code = code;
	ReadFirstmain(INr,1,true);
	SetCompany(18,false);
	recordNew(UINr);
	recordNew(ConsINr);
	RecordCopy(ConsINr,INr);
	if(blank(ConsINr.BarCode)) then begin
		ConsINr.BarCode = INr.AlternativeCode;
	end;
	ConsINr.AlternativeCode = INr.Code;
	OldConsINr.Code = "IN_9999999";
	TrHs2 = true;
	while (LoopBackKey("Code",OldConsINr,1,TrHs2)) begin
		OldCode = OldConsINr.Code;
		TrHs2 = false;
	end;
	ResetLoop(OldConsINr);
	if(blank(OldCode)) then begin oldCode = "IN_0000000"; end;
	NextM4SerialNumber(OldCode,ConsINr.Code);
	ConsINr.UUID = UINr.UUID;
	CIr.LocCode = INr.Code;
	CIr.BrandCode = ConsINr.BPIBrand;
	if(!ReadFirstKey("LocCodeBrand",CIr,2,true))then begin	
		if(RecordStore(ConsINr,true))then begin
			logtext(0,ConsINr.Code & " Code");
			recordNew(CIr);
			CIr.Code = ConsINr.Code;
			CIr.LocCode = INr.Code;
			CIr.BrandCode = ConsINr.BPIBrand;
			if(RecordStore (CIr,true)) then begin end;	
		end;
	end;
end;
return;
end;	

global webpublic procedure WebCollectSDIn()
begin
	record SDVc SDr;
	boolean TrHs,testf;
	record CompaniesBlock Compb;
	row CompaniesBlock Comprw;
	integer comp,oldComp,CompQty;
	logtext(0,"Start");
	blockload(Compb);
	oldComp = currentCompany;
	CompQty = matrowcnt(Compb);
	for(comp=0;comp<CompQty;comp=comp+1) begin
		matrowget(Compb,comp,Comprw);
		if(Comprw.ActiveStatus==0 and comp+1!=18 and comp+1!=33) then begin 
			SetCompany(comp+1,false);
			weboutstring("<BR>");
			weboutstring("<BR>");
			weboutstring(Comprw.CompName);
			TrHs = true;
			SDr.TransDate = currentdate;
			while(LoopBackKey("TransDate",SDr,1,true)) begin
				testf = true;
				if(SDr.TransDate<addDay(currentdate,-3)) then begin testf = false; TrHs = false; end;
				if(SDr.OKFlag==0 or SDr.CostAcc!="41/06" or !SetInSet("CENTRAL_RETURN",SDr.Objects)) then begin testf = false; end;
				if(testf) then begin
					weboutstring("<BR>");
					weboutstring(SDr.SerNr);
				end;
			end;
			ResetLoop(SDr);
		end;
	end;	
	ResetCompany(oldComp);
	logtext(0,"End");
	return;
end;

global webpublic procedure WebcheckAlternativeIn()
begin
	record INVc INr;
	boolean TrHs,testf;
	record CompaniesBlock Compb;
	row CompaniesBlock Comprw;
	integer comp,oldComp,CompQty;
	vector boolean AltCode;
	logtext(0,"Start");
	oldComp = currentCompany;
	SetCompany(18,false);
		INr.Code = "";
		TrHs = true;
		while(LoopMain(INr,1,TrHs)) begin
			if(AltCode[INr.AlternativeCode]==true) then begin
				weboutstring("<BR>");
				weboutstring("<BR>");
				weboutstring(INr.AlternativeCode);
			end else begin
				AltCode[INr.AlternativeCode] = true;
			end;
		end;
	ResetCompany(oldComp);
	logtext(0,"End");
	return;
end;




// global webpublic updating procedure WebPriceChanges()
// begin
  // record PUVc PUr;
	// row PUVc PUrw;
	// vector val vPUPrice, vCurItemPrice;
	// vector string 255 vPUCur, vCurItemCurrency;
	// integer i,j,cicnt;
	// record ConsItemVc CIr;
	// record CompaniesBlock Compb;
	// row CompaniesBlock Comprw; 
	// integer Compcnt, compNo;
	// vector boolean ItemToCorrf;
	// record ItemHistVc IHr, oldIHr;
	// record INVc INr;
	// boolean TrHs, testf;
	// array string 255 aCorrArtCodes, aCorrItBrnds;
	// BlockLoad(Compb);
	
	// SetCompany(18,false);
	// PUr.SerNr = "";
	// weboutstring("Сбор товаров для коррекции________________________________________________________________________________________");
	// weboutstring("<BR>");
	// logtext(0,"1________________________________________________________________________________________");
	// j = 0;
	// while (loopmain(PUr,1,true)) begin
		// if(left(PUr.VECode,3)=="FOB" and PUr.OKFlag == 1 and PUr.CurncyCode!="AZN")then begin
			// for (i=0;i<matrowcnt(PUr);i=i+1) begin
				// matrowget (PUr,i,PUrw);
				// CIr.Code = PUrw.ArtCode;
				// if(ReadFirstMain(CIr,1,true))then begin
					// if(vPUPrice [CIr.LocCode & "_" & CIr.BrandCode]==blankval)then begin
						// vPUPrice [CIr.LocCode & "_" & CIr.BrandCode] = PUrw.UPrice;
						// vPUCur [CIr.LocCode & "_" & CIr.BrandCode]  = PUr.CurncyCode;
						// aCorrArtCodes[j] = CIr.LocCode;
						// aCorrItBrnds[j] = CIr.BrandCode;
						// j = j + 1;
						// weboutstring(PUrw.ArtCode & " --- " & vPUPrice [CIr.LocCode & "_" & CIr.BrandCode] & " --- " & PUrw.UPrice);
						// weboutstring("<BR>");
					// end;
				// end;
			// end;
		// end;
	// end;
	// cicnt = j;
	// ResetLoop (PUr);
	// weboutstring("Коррекция истории товаров по поступлениям в компаниях__________________________________________________");
	// weboutstring("<BR>");
	// logtext(0,"2________________________________________________________________________________________");
	// Compcnt = matrowcnt(Compb);
	// for (i=0;i<Compcnt;i=i+1) begin
		// compNo = i + 1;
		// if(compNo!=18 and compNo!=28 and compNo!=29 and compNo!=32 and compNo!=33)then begin
			// SetCompany(compNo,false);
			
			
			// weboutstring("Компания - " & compNo);
			// weboutstring("<BR>");
			
			
			// for (j=0;j<cicnt;j=j+1) begin
				// INr.Code = aCorrArtCodes[j];
				// if(ReadFirstMain(INr,1,true))then begin
					// if(INr.BPIBrand==aCorrItBrnds[j])then begin
						// ItemToCorrf[INr.Code & "_" & compNo] = true; 
						// vCurItemPrice[INr.Code & "_" & compNo] = vPUPrice [INr.Code & "_" & INr.BPIBrand]; 
						// vCurItemCurrency[INr.Code & "_" & compNo] = vPUCur [INr.Code & "_" & INr.BPIBrand]; 
					// end;
				// end;
			// end;
			
			
			// IHr.TransDate = CurrentDate;
			// TrHs = true;
			// while (LoopBackKey("TransDate",IHr,1,TrHs)) begin
				// testf = true;
				// if(IHr.TransDate<stringtodate("1/12/2019"))then begin TrHs = false; end;
				// if(!ItemToCorrf[IHr.ArtCode & "_" & compNo])then begin testf = false; end;
				// if(IHr.CurncyCode!="AZN")then begin testf = false; end;
				// if(TrHs and testf)then begin
					// RecordCopy(oldIHr,IHr);
					// IHr.TotCostPriceCurncy = vCurItemPrice[IHr.ArtCode & "_" & compNo] * AbsoluteVal(IHr.Qty);
					// if(IHr.RemQty>0)then begin
						// IHr.RemCostPriceCurncy = vCurItemPrice[IHr.ArtCode & "_" & compNo] * AbsoluteVal(IHr.RemQty);
					// end;
					// IHr.CurncyCode = vCurItemCurrency[IHr.ArtCode & "_" & compNo];
					// if(recordupdate(oldIHr,IHr,true)==0)then begin
						// weboutstring(" ItemHist in company " & IHr.TransDate & " --- " & IHr.ArtCode & " --- " & compNo & " --- " & IHr.FileName);
						// weboutstring("<BR>");
						// if(IHr.FileName=="PUVc")then begin
							// PUr.SerNr = IHr.TransNr;
							// if(ReadFirstMain(PUr,1,true))then begin
								// matrowget (PUr,IHr.Row,PUrw);
								// PUrw.UPrice = vCurItemPrice[IHr.ArtCode & "_" & compNo];
								// matrowput (PUr,IHr.Row,PUrw);
								// PUr.CurncyCode = vCurItemCurrency[IHr.ArtCode & "_" & compNo];
								// if(RecordStore(PUr,true))then begin
									// weboutstring(" PU in company " & PUr.SerNr & " --- " & PUrw.ArtCode & " --- " & compNo);
									// weboutstring("<BR>");
								// end;
							// end;
						// end;
					// end;
				// end;
			// end;
			// ResetLoop (IHr);
		// end;
	// end;
	
	// ResetCompany(18);
	// weboutstring("Коррекция истории товаров по поступлениям от FOB в CC__________________________________________________");
	// weboutstring("<BR>");
	// logtext(0,"3________________________________________________________________________________________");
	// PUr.SerNr = "";
	// while (loopmain(PUr,1,true)) begin
		// if(left(PUr.VECode,3)=="FOB" and PUr.CurncyCode=="AZN")then begin
			// for (i=0;i<matrowcnt(PUr);i=i+1) begin
				// matrowget (PUr,i,PUrw);
				// CIr.Code = PUrw.ArtCode;
				// if(ReadFirstMain(CIr,1,true))then begin
					// if(vPUPrice [CIr.LocCode & "_" & CIr.BrandCode]==blankval)then begin
						// PUrw.UPrice = vPUPrice [CIr.LocCode & "_" & CIr.BrandCode];
						// matrowput (PUr,i,PUrw);
						// if(RecordStore(PUr,true))then begin
							// weboutstring(" PU in CCpompany " & PUr.SerNr & " --- " & PUrw.ArtCode & " --- ");
							// weboutstring("<BR>");
							// IHr.FileName = "PUVc";
							// IHr.TransNr = PUr.SerNr;
							// IHr.Row = i;
							// TrHs = true;
							// while (LoopBackKey("FNTransNr",IHr,3,TrHs)) begin
								// if(IHr.FileName!="PUVc")then begin TrHs = false; end;
								// if(IHr.TransNr!=PUr.SerNr)then begin TrHs = false; end;
								// if(IHr.Row!=i)then begin TrHs = false; end;
								// if(IHr.ArtCode==PUrw.ArtCode and TrHs)then begin
									// RecordCopy(oldIHr,IHr);
									// IHr.TotCostPriceCurncy = PUrw.UPrice * AbsoluteVal(IHr.Qty);
									// if(IHr.RemQty>0)then begin
										// IHr.RemCostPriceCurncy = PUrw.UPrice * AbsoluteVal(IHr.RemQty);
									// end;
									// IHr.CurncyCode = vPUCur [CIr.LocCode & "_" & CIr.BrandCode];
									// if(recordupdate(oldIHr,IHr,true)==0)then begin
										// weboutstring(" ItemHist in CCompany " & IHr.TransDate & " --- " & IHr.ArtCode & " --- ");
										// weboutstring("<BR>");
									// end;
								// end;
							// end;
							// ResetLoop (IHr);
						// end;
					// end;
				// end;
			// end;
		// end;
	// end;
	// ResetLoop (PUr);
	
	
	// IHr.TransDate = CurrentDate;
	// TrHs = true;
	// while (LoopBackKey("TransDate",IHr,1,TrHs)) begin
		// testf = true;
		// if(IHr.TransDate<stringtodate("1/12/2019"))then begin TrHs = false; end;
		// CIr.Code = IHr.ArtCode;
		// if(ReadFirstMain(CIr,1,true))then begin end;
		// if(blank(vPUCur [CIr.LocCode & "_" & CIr.BrandCode]))then begin testf = false; end;
		// if(IHr.CurncyCode!="AZN")then begin testf = false; end;
		// if(TrHs and testf)then begin
			// RecordCopy(oldIHr,IHr);
			// IHr.TotCostPriceCurncy = vPUPrice[CIr.LocCode & "_" & CIr.BrandCode] * AbsoluteVal(IHr.Qty);
			// if(IHr.RemQty>0)then begin
				// IHr.RemCostPriceCurncy = vPUPrice[CIr.LocCode & "_" & CIr.BrandCode] * AbsoluteVal(IHr.RemQty);
			// end;
			// IHr.CurncyCode = vPUCur[CIr.LocCode & "_" & CIr.BrandCode];
			// if(recordupdate(oldIHr,IHr,true)==0)then begin
				// weboutstring(" ItemHist in CCompany " & IHr.TransDate & " --- " & IHr.ArtCode & " --- " & IHr.FileName);
				// weboutstring("<BR>");
			// end;
		// end;
	// end;
	// ResetLoop (IHr);
	
	// return;
// end;







global updating procedure ExchCurrInTr41AccRow(string FileName, longint DocNr)
begin
	record TRVc TRr, OldTRr;
	row TRVc TRrw, TR61rw;
	integer i,j,rwcnt, mtrw, i4120;
	array string 255 aArtCodes, aRowCrncy, a60and61Curr;
	array val aRowCostPrice, aChckFIFORV, a60and61Val, Chck60and61Val;
	array integer aItRows;
	boolean trf, TrHs, chckFIFORowf, f4102;
	record ItemHistVc IHr;
	record SDVc SDr;
	row SDVc SDrw;
	record SHVc SHr;
	row SHVc SHrw;
	record RetVc Retr;
	row RetVc Retrw;
	record RetPUVc RetPUr;
	row RetPUVc RetPUrw;
	record StockMovVc SMr;
	row StockMovVc SMrw;
	
	if(nonblank(FileName) and DocNr!=-1)then begin
		switch (FileName) begin
			case "SDVc":
									SDr.SerNr = DocNr;
									if(ReadFirstMain(SDr,1,true))then begin
										j = 0;
										for (i=0;i<matrowcnt(SDr);i=i+1) begin
											matrowget(SDr,i,SDrw);
											if(nonblank(SDrw.ArtCode))then begin
												aArtCodes[j] = SDrw.ArtCode;
												aItRows[j] = i;
												aChckFIFORV[j] = SDrw.FIFORowVal;
												chckFIFORowf = true;
												j=j+1;
											end;
										end;
										rwcnt = j;
									end;
									TRr.Number = DocNr;
									TRr.IntYc = SDYc;
									if (ReadFirstMain(TRr,2,true)) then begin
										RecordCopy(OldTRr,TRr);
										trf = true;
									end;
			case "SHVc":
									SHr.SerNr = DocNr;
									if(ReadFirstMain(SHr,1,true))then begin
										j = 0;
										for (i=0;i<matrowcnt(SHr);i=i+1) begin
											matrowget(SHr,i,SHrw);
											if(nonblank(SHrw.ArtCode))then begin
												aArtCodes[j] = SHrw.ArtCode;
												aItRows[j] = i;
												aChckFIFORV[j] = SHrw.FIFORowVal;
												chckFIFORowf = true;
												j=j+1;
											end;
										end;
										rwcnt = j;
									end;
									TRr.Number = DocNr;
									TRr.IntYc = SHYc;
									if (ReadFirstMain(TRr,2,true)) then begin
										RecordCopy(OldTRr,TRr);
										trf = true;
									end;
			case "RetVc":
									Retr.SerNr = DocNr;
									if(ReadFirstMain(Retr,1,true))then begin
										j = 0;
										for (i=0;i<matrowcnt(Retr);i=i+1) begin
											matrowget(Retr,i,Retrw);
											if(nonblank(Retrw.ArtCode))then begin
												aArtCodes[j] = Retrw.ArtCode;
												aItRows[j] = i;
												aChckFIFORV[j] = Retrw.Quant * Retrw.CostPrice;
												chckFIFORowf = true;
												j=j+1;
											end;
										end;
										rwcnt = j;
									end;
									TRr.Number = DocNr;
									TRr.IntYc = RetYc;
									if (ReadFirstMain(TRr,2,true)) then begin
										RecordCopy(OldTRr,TRr);
										trf = true;
									end;
			case "RetPUVc":
									RetPUr.SerNr = DocNr;
									if(ReadFirstMain(RetPUr,1,true))then begin
										j = 0;
										for (i=0;i<matrowcnt(RetPUr);i=i+1) begin
											matrowget(RetPUr,i,RetPUrw);
											if(nonblank(RetPUrw.ArtCode))then begin
												aArtCodes[j] = RetPUrw.ArtCode;
												aItRows[j] = i;
												aChckFIFORV[j] = RetPUrw.FIFORowVal;
												chckFIFORowf = true;
												j=j+1;
											end;
										end;
										rwcnt = j;
									end;
									TRr.Number = DocNr;
									TRr.IntYc = RetPUYc;
									if (ReadFirstMain(TRr,2,true)) then begin
										RecordCopy(OldTRr,TRr);
										trf = true;
									end;
		end;
		
		if(trf)then begin
			for (j=0;j<rwcnt;j=j+1) begin
				aRowCostPrice[j] = 0;
				aRowCrncy[j] = "";
				IHr.FileName = FileName;
				IHr.TransNr = DocNr;
				IHr.Row = aItRows[j];
				TrHs = true;
				while (LoopKey("FNTransNr",IHr,3,TrHs)) begin
					if(IHr.FileName!=FileName)then begin TrHs = false; end;
					if(IHr.TransNr!=DocNr)then begin TrHs = false; end;
					if(IHr.Row!=aItRows[j])then begin TrHs = false; end;
					if(TrHs)then begin
						aRowCostPrice[j] = aRowCostPrice[j] + IHr.TotCostPriceCurncy;
						aRowCrncy[j] = IHr.CurncyCode;
					end;
				end;
				ResetLoop(IHr);
			end;
			j = 0;
			i4120 = 0;
			mtrw = matrowcnt(TRr);
			for (i=0;i<mtrw;i=i+1) begin
				matrowget(TRr,i,TRrw);
				if(TRrw.AccNumber=="41/01" or TRrw.AccNumber=="41/02")then begin
					if (TRrw.AccNumber=="41/02") then begin  
						f4102 = true; 
						a60and61Curr[i4120] = aRowCrncy[j];
						a60and61Val[i4120] = aRowCostPrice[j];
						if(TRrw.DebVal!=blankval)then begin
							Chck60and61Val[i4120] = TRrw.DebVal;
						end else begin
							Chck60and61Val[i4120] = TRrw.CredVal;
						end;
						i4120 = i4120 + 1; 
					end;
					if (chckFIFORowf and (Round(aChckFIFORV[j],SetRoundModeD(2))==TRrw.DebVal or Round(aChckFIFORV[j],SetRoundModeD(2))==TRrw.CredVal)) then begin
						if (TRrw.DebVal!=blankval) then begin
							TRrw.CurDebVal = aRowCostPrice[j];
							TRrw.Curncy = aRowCrncy[j];
							matrowput (TRr,i,TRrw);
						end;
						if (TRrw.CredVal!=blankval) then begin
							TRrw.CurCredVal = aRowCostPrice[j];
							TRrw.Curncy = aRowCrncy[j];
							matrowput (TRr,i,TRrw);
						end;
						j = j + 1;
						if(rwcnt==j)then begin i = mtrw + 1; end;
					end;
					if(!chckFIFORowf)then begin
						if (TRrw.DebVal!=blankval) then begin
							TRrw.CurDebVal = aRowCostPrice[j];
							TRrw.Curncy = aRowCrncy[j];
							matrowput (TRr,i,TRrw);
						end;
						if (TRrw.CredVal!=blankval) then begin
							TRrw.CurCredVal = aRowCostPrice[j];
							TRrw.Curncy = aRowCrncy[j];
							matrowput (TRr,i,TRrw);
						end;
						j = j + 1;
						if(rwcnt==j)then begin i = mtrw + 1; end;
					end;
				end;
			end;
			
			j = 0;
			mtrw = matrowcnt(TRr);
			for (i=0;i<mtrw;i=i+1) begin
				matrowget(TRr,i,TRrw);
				matrowget(TRr,i+1,TR61rw);
				if(TRrw.AccNumber=="60" and TR61rw.AccNumber=="61" and (Chck60and61Val[j]==AbsoluteVal(TRrw.DebVal) or Chck60and61Val[j]==AbsoluteVal(TRrw.CredVal)))then begin
					if (TRrw.DebVal!=blankval) then begin
						TRrw.CurDebVal = a60and61Val[j] * (TRrw.DebVal / AbsoluteVal(TRrw.DebVal));
						TRrw.Curncy = a60and61Curr[j];
						matrowput (TRr,i,TRrw);
					end;
					if (TRrw.CredVal!=blankval) then begin
						TRrw.CurCredVal = a60and61Val[j] * (TRrw.CredVal / AbsoluteVal(TRrw.CredVal));
						TRrw.Curncy = a60and61Curr[j];
						matrowput (TRr,i,TRrw);
					end;
					i=i+1;
					matrowget(TRr,i,TRrw);
					if (TRrw.DebVal!=blankval) then begin
						TRrw.CurDebVal = a60and61Val[j] * (TRrw.DebVal / AbsoluteVal(TRrw.DebVal));
						TRrw.Curncy = a60and61Curr[j];
						matrowput (TRr,i,TRrw);
					end;
					if (TRrw.CredVal!=blankval) then begin
						TRrw.CurCredVal = a60and61Val[j] * (TRrw.CredVal / AbsoluteVal(TRrw.CredVal));
						TRrw.Curncy = a60and61Curr[j];
						matrowput (TRr,i,TRrw);
					end;
					j = j + 1;
					if(i4120==j)then begin i = mtrw + 1; end;
				end;
			end;
			
			
			
			if(recordupdate(oldTRr,TRr,true)==0) then begin
				logtext(0,"TRr Updated");
			end;
		end;
	end;
return;
end;

global updating procedure MyAddBalaceCUMn(record RcVc RepSpec)
begin
	record CSVc CSr;
	
	CSr.CustCode = RepSpec.f1;
  //CSr.BranchID = "";
  //CSr.Class = "";
  CSr.CurncyCode = RepSpec.f2; 
	readfirstmain(CSr,1,true);
  AddBalance(CSr,RepSpec.d1,"",0,"",0,"",0,"",0,"balance",RepSpec.vals0,"",0);
  AddBalance(CSr,RepSpec.d1,"",0,"",0,"",0,"",0,"paidvalue",RepSpec.vals0,"",0);
  
return;
end;

global updating procedure MyAddBalaceVEMn(record RcVc RepSpec)
begin
	record VSVc CSr;
	
	CSr.VECode = RepSpec.f1;
  //CSr.BranchID = "";
  //CSr.Class = "";
  CSr.CurncyCode = RepSpec.f2; 
	readfirstmain(CSr,1,true);
  AddBalance(CSr,RepSpec.d1,"",0,"",0,"",0,"",0,"vebalance",RepSpec.vals0,"",0);
  AddBalance(CSr,RepSpec.d1,"",0,"",0,"",0,"",0,"vepaidvalue",RepSpec.vals0,"",0);
  
return;
end;

global updating procedure SortAccessMn(record RcVc RepSpec)
begin
record AccessVc Acsr;
row AccessVc Acsrw;
boolean TrHs;
integer i,cnt,k;
vector string 255 type;
array string 255 tags;
Acsr.Code = "";
TrHs = true;
while(LoopMain(Acsr,1,TrHs)) begin
	cnt = matrowcnt(Acsr);
	for(i=0;i<cnt;i=i+1) begin
		matrowget(Acsr,i,Acsrw);
		if(blank(Acsrw.AccName)) then begin Acsrw.AccName = "јјј"; end;
		type[Acsrw.AccType & Acsrw.AccName] =  Acsrw.AccType & Acsrw.AccName;
	end;
	GetVectorTags(type,tags);
  SortStringArray(tags);
	for(k=0;k<tags.length;k=k+1) begin
		for(i=0;i<cnt;i=i+1) begin
			matrowget(Acsr,i,Acsrw);
			if(blank(Acsrw.AccName)) then begin Acsrw.AccName = "јјј"; end;
			if(Acsrw.AccType & Acsrw.AccName == tags[k]) then begin
				if(Acsrw.AccName == "јјј") then begin Acsrw.AccName = ""; end;
				matrowput(Acsr,cnt+i,Acsrw);
				i = cnt;
			end;
		end;	
	end;
	for(i=cnt;i>=0;i=i-1) begin
		MatRowDelete(Acsr,i);	
	end;
	ClearVector(type);
	ClearArray(tags);
	RecordStore(Acsr,true);
end;	
return;
end;






















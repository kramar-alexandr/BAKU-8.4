external function Boolean HasApprovals();
remote function Integer PUApprovalStatus(record PUVc,var record AcceptanceRulesVc);
external function Boolean BulkSerialNos_CalculateQuantityAndSerialNr(record SerNrTrackBlock,Boolean,string,var string,var val);
external function Boolean PUDchrsum(record PUVc,Integer);
external function string 255 FillupTaxMatrix(Integer,string,string,string,string,string,var record TaxMatrixVc);
external function Boolean GetItemPurchasePriceDiscount(string,string,Date,string,string,val,string,string,string,string,Integer,Boolean,val,val,val,val,val,
         var record INVc,var record PIVc,var Boolean,var val,var string,var val,var string,var string,var Boolean,var string);
external function Boolean SerialNrEverinStock(string,string);
external function Integer SerBlockCheckOverlap(LongInt,LongInt,LongInt,LongInt);
external procedure RowCalculateTaxMatrix_VIVc(var record VIVc,Integer,row VIVc,Integer);
external function Boolean CalculateOPPrepaymentAvgRate(record PUVc,LongInt,val,var val,var val,var val,var val,var val);
external function roundmode GetCostRoundMode(record RoundBlock);
external function roundmode DefaultRoundMode();
external updating function Integer ValidatePORecord(var record POVc,record POVc,LongInt,LongInt,Boolean,var string);
external procedure DivPIFactor(val,val,var val);
external procedure RoundVATSum(string,string,string,var val);
external function string 255 FindINObjects(string,string);
external procedure PURecalcCost(var record PUVc);
external procedure PUSetShipCost(var record PUVc,Integer);
external function Integer GetPUPControlAcc(string,string,Integer,string,string,record AccBlock,Integer,var string,var string,Boolean);
external function Integer GetPUStockAcc(Integer,string,string,string,record AccBlock,Integer,var string,var string,Boolean);
external procedure NextM4Number(string,var string);
external procedure M4PadString(string,Integer,string,Boolean,var string);
external function string 20 FindFreePositionInLocArea_ExcludePositionFromArray(string,string,val,record INVc,Integer,Array string,Integer);
external procedure CalculatePURowSum(val,val,string,var val,val,
                                     val,val,val,val,val,
                                     string,var val,Boolean,string,
                                     val,val,val,val,val);
external function Boolean GetFirstItem(var string,var record INVc);
external function Integer GetPO(LongInt,var record POVc,string,Boolean);
external function val DivRateToBase1(string,val,val,val,val,val,val,roundmode);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function val FindVAT(string,val,Integer,Integer);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure GetAPAcc(string,var string);
external function Boolean FindItemVAR(string,var string,var string,var string,var string);
external function Boolean GetFirstPurchaseItem(string,string,string,var record PIVc);
external procedure CurValToOtherCur(Date,string,val,string,var val,roundmode);
external procedure PUCalcPerc(val,string,var val);
external procedure PUSumUp(var record PUVc);
external procedure PUCalcCostPrice(string,val,Integer,Integer,string,string,
                                   val,val,val,val,val,
                                   val,val,val,val,val,val,
                                   string,var val,val,var val,string,Integer);
external procedure ReadLastINSer(string,var string);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external procedure GetItemVATCode(string,Integer,var string,Boolean);
external function Boolean GetAccName(string,var string,Integer);
external procedure GetPurchaseControlAcc(string,Integer,string,record AccBlock,string,var string,string);
external procedure MulM4ProcVal(val,val,var val);
remote procedure VISumup(record VIVc,var val);
remote procedure VICalcVals(var record VIVc);
remote procedure VICalcEReb(var record VIVc);
remote procedure AddExtraCostRow(record AccBlock,record BaseCurBlock,record VIVc,string,val,Integer,Integer,Integer,string,var record SMVc,Integer);
remote function Boolean VIVc_PasteVECode(var record VIVc,Integer,Boolean,Boolean,var string);
remote procedure AddPrepaymentPORows(var record VIVc,LongInt);	//Edit----------------------Dima  11.03.2015
external function string 255 NormalizeSetString(string);// Edit ************************** BPI Ukraine - KramarAlexandr - Tuesday, 3 April 2018 12:00:28
external function string 60 UserDefined(string,string); //Edit----------------------ABR  10.09.2019
external procedure ExtractObjWithSeparator(string,string,Boolean,var Integer,var string);
external procedure NextM4Number(string,var string);
remote procedure BigPUSumUp(var record BigPUVc);



SetLangMode(LangRussian,"RUS",0);
global
procedure NextNumber(string code,var string next)
BEGIN
  string 255 pre;
  string 255 suff;
  Integer i,j;
  val t;
  string 1 c;
  string 255 zerostr,tstr;
  Integer padcnt;

  for (i=len(code);i>0;i=i-1) begin
    c = Mid(code,i-1,1);
    if ((asc(c)<asc("0")) or (asc(c)>asc("9"))) then begin//if it is 0, next number for 0123 will be 124
      goto L10NextNumber;
    end;
  end;
L10NextNumber:;
  for (j=0;j<i;j=j+1) begin
    pre = pre & Mid(code,j,1);
  end;  
  for (j=i;j<=len(code);j=j+1) begin
    suff = suff & Mid(code,j,1);
  end;
  padcnt = len(suff);
  t = StringToVal(suff,M40Val);
  t = t + 1;
//  tstr = Left(t,len(t)-3);
  tstr = ValToString(t,M40Val,"","",0);  
  M4PadString(tstr,padcnt,"0",true,suff);
  next = pre & suff;
  if (next=="0") then begin next = "1"; end;
  if (next=="") then begin next = "1"; end;
  if (nonblank(zerostr)) then begin
    suff = next;
    next = zerostr & suff;
  end;
  RETURN;
END;

global
procedure NextM4SerialNumber(string code,var string next)
BEGIN
  string 255 pre;
  string 255 suff;
  Integer i,j;
  val t;
  string 1 c;
  string 255 zerostr,tstr;
  Integer padcnt;

  for (i=len(code);i>0;i=i-1) begin
    c = Mid(code,i-1,1);
    if ((asc(c)<asc("0")) or (asc(c)>asc("9"))) then begin//if it is 0, next number for 0123 will be 124
      goto L10NextM4SerialNumber;
    end;
  end;
L10NextM4SerialNumber:;
  for (j=0;j<i;j=j+1) begin
    pre = pre & Mid(code,j,1);
  end;  
  for (j=i;j<=len(code);j=j+1) begin
    suff = suff & Mid(code,j,1);
  end;
  padcnt = len(suff);
  if (padcnt==0) then begin 
    padcnt = 1; 
  end;
  t = StringToVal(suff,M40Val);
  t = t + 1;
  tstr = ValToString(t,M40Val,"","",0);  
  if (len(suff))<(len(tstr)) then begin
    suff = tstr;
  end else begin
    M4PadString(tstr,padcnt,"0",true,suff);
  end;
  next = pre & suff;
  if (next=="0") then begin next = "1"; end;
  if (next=="") then begin next = "1"; end;
  if (nonblank(zerostr)) then begin
    suff = next;
    next = zerostr & suff;
  end;
  RETURN;
END;

global
procedure NextCode(string code,var string next)
BEGIN
  string 255 pre;
  string 255 suff;
  Integer i,j;
  val t;
  string 1 c;
  string 255 zerostr,tstr;
  Integer padcnt;

  for (i=len(code);i>0;i=i-1) begin
    c = Mid(code,i-1,1);
    if ((asc(c)<asc("0")) or (asc(c)>asc("9"))) then begin//if it is 0, next number for 0123 will be 124
      goto L10NextM4SerialNumber;
    end;
  end;
L10NextM4SerialNumber:;
  for (j=0;j<i;j=j+1) begin
    pre = pre & Mid(code,j,1);
  end;  
  for (j=i;j<=len(code);j=j+1) begin
    suff = suff & Mid(code,j,1);
  end;
  padcnt = len(suff);
  if (padcnt==0) then begin 
    padcnt = 1; 
  end;
  t = StringToVal(suff,M4Val);
  t = t + 1;
  tstr = ValToString(t,M4Val,"","",0); 
	tstr = left(tstr,len(tstr)-2);
  if (len(suff))<(len(tstr)) then begin
    suff = tstr;
  end else begin
    M4PadString(tstr,padcnt,"0",true,suff);
  end;
  next = pre & suff;
  if (next=="0") then begin next = "1"; end;
  if (next=="") then begin next = "1"; end;
  if (nonblank(zerostr)) then begin
    suff = next;
    next = zerostr & suff;
  end;
  RETURN;
END;


global
procedure NextSerialNumberWithPad(string code,Integer extrapad,var string next)
BEGIN
  string 255 pre;
  string 255 suff;
  Integer i,j;
  val t;
  string 1 c;
  string 255 zerostr,tstr;
  Integer padcnt;
  Boolean alphaf;

  for (i=len(code);i>0;i=i-1) begin
    c = Mid(code,i-1,1);
    if ((asc(c)<asc("0")) or (asc(c)>asc("9"))) then begin//if it is 0, next number for 0123 will be 124
      alphaf = true;
      goto L10NextSerialNumberWithPad;
    end;
  end;
L10NextSerialNumberWithPad:;  
  for (j=0;j<i;j=j+1) begin
    pre = pre & Mid(code,j,1);
  end; 
  for (j=i;j<=len(code);j=j+1) begin
    suff = suff & Mid(code,j,1);
  end;
  if (alphaf==false) then begin
    if (i==0) then begin
      pre = suff; 
      suff = "";
    end;
    padcnt = len(suff);
    if (padcnt==0) then begin 
      padcnt = 1; 
      padcnt = padcnt + extrapad - 1; 
    end else begin
      padcnt = padcnt + extrapad;
    end;
  end else begin  
    padcnt = len(suff);
    if (padcnt==0) then begin 
      padcnt = 1; 
      padcnt = padcnt + extrapad - 1; 
    end else begin
      padcnt = padcnt + extrapad;
    end;
  end;
  if (padcnt<0) then begin
    padcnt = 0;
  end;
  t = StringToVal(suff,M40Val);
  t = t + 1;
  tstr = ValToString(t,M40Val,"","",0);  
  M4PadString(tstr,padcnt,"0",true,suff);
  next = pre & suff;
  if (next=="0") then begin next = "1"; end;
  if (next=="") then begin next = "1"; end;
  if (nonblank(zerostr)) then begin
    suff = next;
    next = zerostr & suff;
  end;
  RETURN;
END;

global
function string 255 NextSerialNumber(string artcode,string curserialnr,record SerNrTrackBlock SNrb)
BEGIN
  string 255 next,lastnr;
  Integer extrapad;
  
  lastnr = curserialnr;
  if (SNrb.SerNrLength<=0) then begin
    NextM4SerialNumber(lastnr,next);
  end else begin
    if (blank(lastnr)) then begin
      switch (SNrb.GenSerNumber) begin
        case 0: lastnr = "0";
        case 1: lastnr = artcode;
      end;
      if (SNrb.SerNrLength<0) then begin
        extrapad = 0;
      end else begin
        extrapad = SNrb.SerNrLength - len(lastnr);
      end;
      NextSerialNumberWithPad(lastnr,extrapad,next);
    end else begin
      NextM4SerialNumber(lastnr,next);
    end;    
  end;
  NextSerialNumber = next;
  RETURN;
END;

global
function Integer VIRowExists(record CYBlock CYb,record VIVc VIp,string accnumber,string vatcode,string taxtemplate,val rowsump,val q)
BEGIN
  Integer res;
  row VIVc VIrw;
  Integer i,rwcnt;
  Boolean testf;
 
  res = -1;
  rwcnt = MatRowCnt(VIp);
  for (i=0;i<rwcnt;i=i+1) begin  
    MatRowGet(VIp,i,VIrw);
    testf = false;
    if (CYb.UseTaxTemplatesforTaxCalc==0) then begin
      if ((accnumber==VIrw.AccNumber) and (vatcode==VIrw.VATCode)) then begin
        testf = true;
      end;
    end else begin
      if ((accnumber==VIrw.AccNumber) and (taxtemplate==VIrw.TaxTemplateCode)) then begin
        testf = true;
      end;
    end;
    if (testf) then begin//TaxTemplateCode
      VIrw.Sum = VIrw.Sum + rowsump;
      VIrw.qty = VIrw.qty + q;
      MatRowPut(VIp,i,VIrw);
      res = i;
      goto LVIRowExists;
    end;
  end;  
LVIRowExists:; 
  VIRowExists = res; 
  RETURN;
END;

global
function Integer VIPRRowExists(record VIVc VIp,string prcode,string artcode,string vatcode,val rowsump,val q)
begin
  Integer res;
  row VIVc VIrw;
  Integer i,rwcnt;
 
  res = -1;
  rwcnt = MatRowCnt(VIp);
  for (i=0;i<rwcnt;i=i+1) begin  
    MatRowGet(VIp,i,VIrw);
    if ((vatcode==VIrw.VATCode) and (artcode==VIrw.Item) and (prcode==VIrw.PRCode)) then begin
//TaxTemplateCode    
      VIrw.Sum = VIrw.Sum + rowsump;
      VIrw.qty = VIrw.qty + q;
      MatRowPut(VIp,i,VIrw);
      res = i;
      goto LVIPRRowExists;
    end;
  end;  
LVIPRRowExists:; 
  VIPRRowExists = res; 
  return;
end;

global
function Boolean PUQtyInvoiced(LongInt PUNr,LongInt PURow,LongInt POSerNr,var val puqtyinvd)
begin
  Boolean res;
  record VIVc VIr;
  row VIVc VIrw;
  Integer i,rwcnt;
  Boolean found,testf;
  
  puqtyinvd = blankval;
  if (POSerNr>0) then begin
    found = true;
    VIr.POSerNr = POSerNr;
    while (LoopKey("POSerNr",VIr,1,found)) begin
      if (VIr.POSerNr!=POSerNr) then begin found = false; end;
      if (found) then begin
        testf = true;
        if (VIr.Invalid!=0) then begin testf = false; end;
        if (testf) then begin
          rwcnt = MatRowCnt(VIr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(VIr,i,VIrw);
            if (PUNr>0) and (PURow>=0) then begin
              if (VIrw.PUNr==PUNr) and (VIrw.PURow==PURow) then begin
                if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) then begin
                  puqtyinvd = puqtyinvd - VIrw.qty;
                end else begin
                  puqtyinvd = puqtyinvd + VIrw.qty;
                end;
                res = true;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
  PUQtyInvoiced = res;
  return;
end;

/*
function Boolean POQtyInvoiced(LongInt POSerNr,LongInt RowPOSerNr,LongInt PORow,var val puqtyinvd)
begin
  Boolean res;
  record POVc POr;
  row POVc POrw;
  
  puqtyinvd = blankval;
  if (PORow>=0) then begin
    if (RowPOSerNr>0) then begin
      POr.SerNr = RowPOSerNr;
    end else begin
      POr.SerNr = POSerNr;
    end;
    if (ReadFirstMain(POr,1,true)) then begin
      MatRowGet(POr,PORow,POrw);
      puqtyinvd = POrw.Invd;    
      if (POrw.Invd!=0) then begin
        res = true;
      end;
    end;
  end;
  POQtyInvoiced = res;
  return;
end;
*/

function Boolean POQtyInvoiced(LongInt PUNr,LongInt PURow,LongInt POSerNr,var val puqtyinvd,var val powopuqtyinvd)
begin
  Boolean res;
  record VIVc VIr;
  row VIVc VIrw;
  Integer i,rwcnt;
  Boolean found,testf,purowf;
  
  puqtyinvd = blankval;
  powopuqtyinvd = blankval;
  if (POSerNr>0) then begin
    found = true;
    VIr.POSerNr = POSerNr;
    while (LoopKey("POSerNr",VIr,1,found)) begin
      if (VIr.POSerNr!=POSerNr) then begin found = false; end;
      if (found) then begin
        testf = true;
        if (VIr.Invalid!=0) then begin testf = false; end;
        if (testf) then begin
          rwcnt = MatRowCnt(VIr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(VIr,i,VIrw);
            purowf = false;
            if (PUNr>0) and (PURow>=0) then begin
              if (VIrw.PUNr==PUNr) and (VIrw.PURow==PURow) then begin
//              if (VIrw.PUNr>0) and (VIrw.PURow>=0) then begin
                if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) then begin
                  puqtyinvd = puqtyinvd - VIrw.qty;
                end else begin
                  puqtyinvd = puqtyinvd + VIrw.qty;
                end;
                res = true;
                purowf = true;
              end;
            end;
            if (purowf==false) then begin
              if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) then begin
                powopuqtyinvd = powopuqtyinvd - VIrw.qty;
              end else begin
                powopuqtyinvd = powopuqtyinvd + VIrw.qty;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
  POQtyInvoiced = res;
  return;
end;

function Boolean POQtyOrdered(LongInt POSerNr,LongInt RowPOSerNr,LongInt PORow,var val poqtyord)
begin
  Boolean res;
  record POVc POr;
  row POVc POrw;
  
  poqtyord = blankval;
  if (PORow>=0) then begin
    if (RowPOSerNr>0) then begin
      POr.SerNr = RowPOSerNr;
    end else begin
      POr.SerNr = POSerNr;
    end;
    if (ReadFirstMain(POr,1,true)) then begin
      MatRowGet(POr,PORow,POrw);
      poqtyord = POrw.Quant;    
      res = true;
    end;
  end;
  POQtyOrdered = res;
  return;
end;

function val FrieghtAlreadyInvoiced(LongInt PUNr,LongInt POSerNr)
begin
  val res;
  record VIVc VIr;
  row VIVc VIrw;
  Integer i,rwcnt;
  Boolean found;
  
  if (POSerNr>0) then begin
  found = true;
  VIr.POSerNr = POSerNr;
  while (LoopKey("POSerNr",VIr,1,found)) begin
    if (VIr.POSerNr!=POSerNr) then begin found = false; end;
    if (found) then begin
      rwcnt = MatRowCnt(VIr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(VIr,i,VIrw);
        if (PUNr>0) then begin
          if (VIrw.PUNr==PUNr) then begin
            res = res + VIrw.Sum;
          end;
        end;
      end;
    end;
  end;
  end;
  FrieghtAlreadyInvoiced = res;
  return;
end;

global
procedure PUAddFreightRow(record PUVc PUp,record VIVc VIp,
                           record AccBlock ARb,record APAccBlock APb,record BaseCurBlock BCb,
                           var Integer nrwcnt)
begin
  row VIVc VIrw;
  string 255 tstr;
  val t,alreadyinvd;

  if (PUp.ShipCost!=0) then begin
    if (GetAccName(ARb.PUFreightAcc,tstr,60)==false) then begin
      goto LPUAddFreightRow;
    end;
    alreadyinvd = FrieghtAlreadyInvoiced(PUp.SerNr,VIp.POSerNr);
    ClearRow(VIp,VIrw,1);
    VIrw.AccNumber = ARb.PUFreightAcc;
    VIrw.Comment = tstr;
    if (ARb.BookPriceVar!=0) then begin
      VIrw.OrdRow = -8;
    end;

    VIrw.qty = PUp.SumQuant;
    VIrw.PUNr = PUp.SerNr;
    VIrw.Objects = "";
    VIrw.Sum = PUp.ShipCost;    
    switch (VIp.ExportFlag) begin
      case 0: VIrw.VATCode = APb.VATCodeDom;
      case 1: VIrw.VATCode = APb.VATCodeEU;
      case 3: VIrw.VATCode = APb.VATCodeEU;
      case 2: VIrw.VATCode = APb.VATCodeExp;
      case 4: VIrw.VATCode = APb.VATCodeExp;
    end;
    switch (VIp.ExportFlag) begin
      case 0: VIrw.TaxTemplateCode = APb.TaxTemplateCode;
      case 1: VIrw.TaxTemplateCode = APb.TaxTemplateCodeEU;
      case 3: VIrw.TaxTemplateCode = APb.TaxTemplateCodeEU;
      case 2: VIrw.TaxTemplateCode = APb.TaxTemplateCodeExp;
      case 4: VIrw.TaxTemplateCode = APb.TaxTemplateCodeExp;
    end;
    if (BCb.BaseCur1!=VIp.CurncyCode) then begin
      CurValToOtherCur(PUp.TransDate,BCb.BaseCur1,VIrw.Sum,VIp.CurncyCode,t,DefaultCurRoundOff);
      VIrw.Sum = t;
    end;
    VIrw.Sum = VIrw.Sum - alreadyinvd;
    if (VIrw.Sum>0) then begin
      MatRowPut(VIp,nrwcnt,VIrw);
      nrwcnt = nrwcnt + 1;
    end;
  end;  
LPUAddFreightRow:;
  return;
end;

procedure AddFreightRow(record PUVc PUp,row PUVc PUrw,Integer purow,record VIVc VIp,
                        record AccBlock ARb,record APAccBlock APb,record BaseCurBlock BCb,
                        var Integer nrwcnt)
BEGIN
  row VIVc VIrw;
  string 255 tstr;
  val t;
  
  if (PUrw.ShipCost!=0) then begin
    if (GetAccName(ARb.PUFreightAcc,tstr,60)==false) then begin
      goto LAddFreightRow;
    end;
    ClearRow(VIp,VIrw,1);
    VIrw.AccNumber = ARb.PUFreightAcc;
    VIrw.Comment = tstr;
    if (ARb.BookPriceVar!=0) then begin
      VIrw.OrdRow = -8;
    end else begin
      VIrw.Item = PUrw.ArtCode;
      VIrw.OrdRow = PUrw.OrdRow;
    end;
//      VIrw.PONr = PUp.PONr;

//    VIrw.qty = PUrw.Quant;, qty can not be here
    VIrw.PUNr = PUp.SerNr;
    VIrw.PURow = purow;
    VIrw.Objects = PUrw.Objects;
    VIrw.Sum = PUrw.Quant*PUrw.ShipCost;    
    switch (VIp.ExportFlag) begin
      case 0: VIrw.VATCode = APb.VATCodeDom;
      case 1: VIrw.VATCode = APb.VATCodeEU;
      case 3: VIrw.VATCode = APb.VATCodeEU;
      case 2: VIrw.VATCode = APb.VATCodeExp;
      case 4: VIrw.VATCode = APb.VATCodeExp;
    end;
    switch (VIp.ExportFlag) begin
      case 0: VIrw.TaxTemplateCode = APb.TaxTemplateCode;
      case 1: VIrw.TaxTemplateCode = APb.TaxTemplateCodeEU;
      case 3: VIrw.TaxTemplateCode = APb.TaxTemplateCodeEU;
      case 2: VIrw.TaxTemplateCode = APb.TaxTemplateCodeExp;
      case 4: VIrw.TaxTemplateCode = APb.TaxTemplateCodeExp;
    end;
    if (BCb.BaseCur1!=VIp.CurncyCode) then begin
      CurValToOtherCur(PUp.TransDate,BCb.BaseCur1,VIrw.Sum,VIp.CurncyCode,t,DefaultCurRoundOff);
      VIrw.Sum = t;
    end;
    MatRowPut(VIp,nrwcnt,VIrw);
    nrwcnt = nrwcnt + 1;
  end;
LAddFreightRow:;  
  RETURN;
END;






global 
updating procedure CreateVIFromBigPU(longint BigPUNr, record RcVc RepSpec,record VIVc VIp)
begin
record BigPUVc BPUr;
record VIVc VIp2;
record VIVc VIp3;
record VIVc VIp4;
record CUVc VEr;
record APAccBlock APb;
record AccBlock ARb;
record CostAccBlock CAb;
record BaseCurBlock BCb;
record VITBlock VITb;
record SMVc VATr;
record CYBlock CYb;
row VIVc VIrw;
val t;
record VIVc oldVIp;
string 255 obj;
record LocationVc Locr;
boolean createVi;
string 255 tstr,newnr;
Integer i,rwcnt,vatcnt;
boolean allCreated;
string 255 incorrectObj,label;

	BlockLoad(BCb);
  BlockLoad(ARb);
  BlockLoad(APb);
  BlockLoad(VITb);
  BlockLoad(CYb);
  BlockLoad(CAb);  
	VEr.Code = RepSpec.f1;
  BPUr.SerNr = BigPUNr;
	createVi = false;
	if(ReadFirstMain(BPUr,1,true)) then begin end;
	if (ReadFirstMain(VEr,1,true)==false) then begin 
    goto LPastebigPUInVI; 
  end;
	VIp.VECode = RepSpec.f1;
	Locr.Code = BPUr.Location;
	if(ReadFirstMain(Locr,1,true)) then begin
		obj = Locr.Objects;
	end;
	if(!SetInSet(obj,VIp.Objects)) then begin
		if(blank(VIp.Objects)) then begin
			VIp.Objects = obj;
		end else begin
			VIp.Objects = VIp.Objects & obj;
		end;
	end;	
	VIVc_PasteVECode(VIp,0,true,false,tstr);
	while (MatRowCnt(VIp)>0) begin
    MatRowDelete(VIp,0);
  end;
	RecordNew(VIp2);
	allCreated = true;
 if (RepSpec.flags[6]) then begin
		if(BPUr.ApprovedCustomsCost!=0) then begin
			//AddExtraCostRow(ARb,BCb,VIp,"customs",BPUr.CustomsCost,BPUr.InclVAT,VIp.ExportFlag,BPUr.ExportFlag,BPUr.CurncyCode,VATr,vatcnt);
			VIrw.AccNumber = ARb.PUCustomsAcc;
			if (GetAccName(VIrw.AccNumber,tstr,60)==false) then begin end;	
			VIrw.Comment = tstr;		
			VIrw.Sum = BPUr.CustomsCost;
			if(BPUr.CurrencyT!="AZN" and nonblank(BPUr.CurrencyT)) then begin
				if(BPUr.CurrencyT!=BPUr.CurrencyF) then begin
					RecordNew(VIp4);
					VIp4.VECode = RepSpec.f1;
					VIVc_PasteVECode(VIp4,0,true,false,tstr);
					while (MatRowCnt(VIp4)>0) begin
						MatRowDelete(VIp4,0);
					end;
					VIp4.TransDate = BPUr.TransDate;
					VIp4.CurncyCode = BPUr.CurrencyT;
					VIp4.FrRate =  BPUr.FrRateT;
					VIp4.ToRateB1 =  BPUr.ToRateT;
					VIp4.BigPUNr = BPUr.SerNr;
					VIp4.ExtraCostObj = "customs";
					MatRowPut(VIp4,MatRowCnt(VIp4),VIrw);
					VICalcVals(VIp4);
					VISumup(VIp4,t);
					VIp4.PayVal = -t;
					VIp4.PayVal = Round(VIp4.PayVal,DefaultRoundMode);
					VICalcEReb(VIp4);
					VIp4.SerNr = NextSerNr("VIVc",VIp4.TransDate,newnr,false,"");
					if(!SetInSet(obj,VIp4.Objects)) then begin
						if(blank(VIp4.Objects)) then begin
							VIp4.Objects = obj;
						end else begin
							VIp4.Objects = VIp4.Objects & "," & obj;
						end;
					end;	
					RecordStore(VIp4,false);
					Createrecordlink(BPUr,CurrentCompany,VIp4,CurrentCompany);
					Createrecordlink(VIp4,CurrentCompany,BPUr,CurrentCompany);
				end else begin 
					VIp2.VECode = RepSpec.f1;
					VIVc_PasteVECode(VIp2,0,true,false,tstr);
					while (MatRowCnt(VIp2)>0) begin
						MatRowDelete(VIp2,0);
					end;
					VIp2.TransDate = BPUr.TransDate;
					VIp2.CurncyCode = BPUr.CurrencyT;
					VIp2.FrRate =  BPUr.FrRateT;
					VIp2.ToRateB1 =  BPUr.ToRateT;
					MatRowPut(VIp2,MatRowCnt(VIp2),VIrw);
					VICalcVals(VIp2);
					VISumup(VIp2,t);
					VIp2.BigPUNr = BPUr.SerNr;
					VIp2.ExtraCostObj = "customs";
					VIp2.PayVal = -t;
					VIp2.PayVal = Round(VIp2.PayVal,DefaultRoundMode);
					VICalcEReb(VIp2);
					VIp2.SerNr = NextSerNr("VIVc",VIp2.TransDate,newnr,false,"");
					if(!SetInSet(obj,VIp2.Objects)) then begin
						if(blank(VIp2.Objects)) then begin
							VIp2.Objects = obj;
						end else begin
							VIp2.Objects = VIp2.Objects & "," & obj;
						end;
					end;	
					RecordStore(VIp2,false);
					Createrecordlink(BPUr,CurrentCompany,VIp2,CurrentCompany);
					Createrecordlink(VIp2,CurrentCompany,BPUr,CurrentCompany);
				end;
			end else begin	
				MatRowPut(VIp,MatRowCnt(VIp),VIrw);
				VIp.BigPUNr = BPUr.SerNr;
				if(blank(VIp.Objects)) then begin
					VIp.Objects = obj;
				end else begin
					VIp.Objects = VIp.Objects & "," & obj;
				end;
				VIp.ExtraCostObj = "customs";
				createVi = true;
			end;
		end else begin
			allCreated = false;
			if(blank(incorrectObj)) then begin
				incorrectObj = "таможню";
			end else begin
				incorrectObj = incorrectObj & "," & "таможня";
			end;
		end;
  end;
  if (RepSpec.flags[7]) then begin  			
			//AddExtraCostRow(ARb,BCb,VIp,"freight",BPUr.ShipCost,BPUr.InclVAT,VIp.ExportFlag,BPUr.ExportFlag,BPUr.CurncyCode,VATr,vatcnt);
		if(BPUr.ApprovedShipCost) then begin	
				 VIrw.AccNumber = ARb.PUFreightAcc;
				 if (GetAccName(VIrw.AccNumber,tstr,60)==false) then begin end;	
				 VIrw.Comment = tstr;	
				 VIrw.Sum = BPUr.ShipCost;
			if(BPUr.CurrencyF!="AZN" and nonblank(BPUr.CurrencyF)) then begin
				if(BPUr.CurrencyT!=BPUr.CurrencyF) then begin
					RecordNew(VIp3);
					VIp3.VECode = RepSpec.f1;
					VIVc_PasteVECode(VIp3,0,true,false,tstr);
					while (MatRowCnt(VIp3)>0) begin
						MatRowDelete(VIp3,0);
					end;
					VIp3.TransDate = BPUr.TransDate;
					VIp3.CurncyCode = BPUr.CurrencyF;
					VIp3.FrRate =  BPUr.FrRateF;
					VIp3.ToRateB1 =  BPUr.ToRateF;
					MatRowPut(VIp3,MatRowCnt(VIp3),VIrw);
					VICalcVals(VIp3);
					VISumup(VIp3,t);
					VIp3.BigPUNr = BPUr.SerNr;
					VIp3.ExtraCostObj = "freight";
					VIp3.PayVal = -t;
					VIp3.PayVal = Round(VIp3.PayVal,DefaultRoundMode);
					VICalcEReb(VIp3);
					VIp3.SerNr = NextSerNr("VIVc",VIp3.TransDate,newnr,false,"");
					if(!SetInSet(obj,VIp3.Objects)) then begin
						if(blank(VIp3.Objects)) then begin
							VIp3.Objects = obj;
						end else begin
							VIp3.Objects = VIp3.Objects & "," & obj;
						end;
					end;	
					RecordStore(VIp3,false);
					Createrecordlink(BPUr,CurrentCompany,VIp3,CurrentCompany);
					Createrecordlink(VIp3,CurrentCompany,BPUr,CurrentCompany);
				end else begin 
					RecordCopy(oldVIp,VIp2);
					VIp2.VECode = RepSpec.f1;
					VIp2.TransDate = BPUr.TransDate;
					VIp2.CurncyCode = BPUr.CurrencyF;
					VIp2.FrRate =  BPUr.FrRateF;
					VIp2.ToRateB1 =  BPUr.ToRateF;
					MatRowPut(VIp2,MatRowCnt(VIp2),VIrw);
					VICalcVals(VIp2);
					VISumup(VIp2,t);
					VIp2.BigPUNr = BPUr.SerNr;
					if(Blank(VIp2.ExtraCostObj)) then begin
						VIp2.ExtraCostObj = "freight";
					end else begin
						VIp2.ExtraCostObj = VIp2.ExtraCostObj & "," & "freight";
					end;
					VIp2.PayVal = VIp2.PayVal-t;
					VIp2.PayVal = Round(VIp2.PayVal,DefaultRoundMode);
					VICalcEReb(VIp2);
					if(!SetInSet(obj,VIp2.Objects)) then begin
						if(blank(VIp2.Objects)) then begin
							VIp2.Objects = obj;
						end else begin
							VIp2.Objects = VIp2.Objects & "," & obj;
						end;
					end;	
					if(VIp2.SerNr!=-1) then begin
						RecordUpdate(oldVIp,VIp2,false);
					end else begin
						VIp2.SerNr = NextSerNr("VIVc",VIp2.TransDate,newnr,false,"");
						RecordStore(VIp2,false);
						Createrecordlink(BPUr,CurrentCompany,VIp2,CurrentCompany);
						Createrecordlink(VIp2,CurrentCompany,BPUr,CurrentCompany);
					end;				
				end;
			end else begin	
				createVi = true;
				MatRowPut(VIp,MatRowCnt(VIp),VIrw);
				if(Blank(VIp.ExtraCostObj)) then begin
					VIp.ExtraCostObj = "freight";
				end else begin
					VIp.ExtraCostObj = VIp.ExtraCostObj & "," & "freight";
				end;
			end;
		end else begin
			allCreated = false;
			if(blank(incorrectObj)) then begin
				incorrectObj = "фрахт";
			end else begin
				incorrectObj = incorrectObj & "," & "фрахт";
			end;
		end;
  end;
  if (RepSpec.flags[1]) then begin
    //AddExtraCostRow(ARb,BCb,VIp,"pucost1",BPUr.Cost1,BPUr.InclVAT,VIp.ExportFlag,BPUr.ExportFlag,BPUr.CurncyCode,VATr,vatcnt);
		if(BPUr.ApprovedCost1) then begin
			VIrw.AccNumber = ARb.PUCost1;
			if (GetAccName(VIrw.AccNumber,tstr,60)==false) then begin end;	
			VIrw.Comment = tstr;
			VIrw.Sum = BPUr.Cost1;
				if(Blank(VIp.ExtraCostObj)) then begin
					VIp.ExtraCostObj = "cost1";
				end else begin
					VIp.ExtraCostObj = VIp.ExtraCostObj & "," & "cost1";
				end;
				if(!SetInSet(obj,VIp.Objects)) then begin
					if(blank(VIp.Objects)) then begin
						VIp.Objects = obj;
					end else begin
						VIp.Objects = VIp.Objects & "," & obj;
					end;
				end;	
				createVi = true;
			MatRowPut(VIp,MatRowCnt(VIp),VIrw);
		end else begin
			allCreated = false;
			label = UserDefined("AccBlock","PUCost1");
			if(blank(incorrectObj)) then begin
				incorrectObj = label;
			end else begin
				incorrectObj = incorrectObj & ", " & label;
			end;
		end;
  end;
  if (RepSpec.flags[2]) then begin
    //AddExtraCostRow(ARb,BCb,VIp,"pucost2",BPUr.Cost2,BPUr.InclVAT,VIp.ExportFlag,BPUr.ExportFlag,BPUr.CurncyCode,VATr,vatcnt);
		if(BPUr.ApprovedCost2) then begin
			VIrw.AccNumber = ARb.PUCost2;
			if (GetAccName(VIrw.AccNumber,tstr,60)==false) then begin end;	
			VIrw.Comment = tstr;
			VIrw.Sum = BPUr.Cost2;
			if(!SetInSet(obj,VIp.Objects)) then begin
				if(blank(VIp.Objects)) then begin
					VIp.Objects = obj;
				end else begin
					VIp.Objects = VIp.Objects & "," & obj;
				end;
			end;	
				if(Blank(VIp.ExtraCostObj)) then begin
					VIp.ExtraCostObj = "cost2";
				end else begin
					VIp.ExtraCostObj = VIp.ExtraCostObj & "," & "cost2";
				end;
				createVi = true;
			MatRowPut(VIp,MatRowCnt(VIp),VIrw);
		end else begin
			allCreated = false;
			label = UserDefined("AccBlock","PUCost2");
			if(blank(incorrectObj)) then begin
				incorrectObj = label;
			end else begin
				incorrectObj = incorrectObj & ", " & label;
			end;
		end;
  end;
  if (RepSpec.flags[3]) then begin
    //AddExtraCostRow(ARb,BCb,VIp,"pucost3",BPUr.Cost3,BPUr.InclVAT,VIp.ExportFlag,BPUr.ExportFlag,BPUr.CurncyCode,VATr,vatcnt);
		if(BPUr.ApprovedCost3) then begin
			VIrw.AccNumber = ARb.PUCost3;
			if (GetAccName(VIrw.AccNumber,tstr,60)==false) then begin end;	
			VIrw.Comment = tstr;
			VIrw.Sum = BPUr.Cost3;
				if(Blank(VIp.ExtraCostObj)) then begin
					VIp.ExtraCostObj = "cost3";
				end else begin
					VIp.ExtraCostObj = VIp.ExtraCostObj & "," & "cost3";
				end;
				if(!SetInSet(obj,VIp.Objects)) then begin
					if(blank(VIp.Objects)) then begin
						VIp.Objects = obj;
					end else begin
						VIp.Objects = VIp.Objects & "," & obj;
					end;
				end;	
			createVi = true;
		MatRowPut(VIp,MatRowCnt(VIp),VIrw);
		end else begin
			allCreated = false;
			label = UserDefined("AccBlock","PUCost3");
			if(blank(incorrectObj)) then begin
				incorrectObj = label;
			end else begin
				incorrectObj = incorrectObj & ", " & label;
			end;
		end;
  end;
  if (RepSpec.flags[4]) then begin
    //AddExtraCostRow(ARb,BCb,VIp,"pucost4",BPUr.Cost4,BPUr.InclVAT,VIp.ExportFlag,BPUr.ExportFlag,BPUr.CurncyCode,VATr,vatcnt);
		if(BPUr.ApprovedCost4) then begin
			VIrw.AccNumber = ARb.PUCost4;
			if (GetAccName(VIrw.AccNumber,tstr,60)==false) then begin end;	
			VIrw.Comment = tstr;
			VIrw.Sum = BPUr.Cost4;
				if(Blank(VIp.ExtraCostObj)) then begin
					VIp.ExtraCostObj = "cost4";
				end else begin
					VIp.ExtraCostObj = VIp.ExtraCostObj & "," & "cost4";
				end;
				if(!SetInSet(obj,VIp.Objects)) then begin
					if(blank(VIp.Objects)) then begin
						VIp.Objects = obj;
					end else begin
						VIp.Objects = VIp.Objects & "," & obj;
					end;
				end;	
			createVi = true;
			MatRowPut(VIp,MatRowCnt(VIp),VIrw);
		end else begin
			allCreated = false;
			label = UserDefined("AccBlock","PUCost4");
			if(blank(incorrectObj)) then begin
				incorrectObj = label;
			end else begin
				incorrectObj = incorrectObj & ", " & label;
			end;
		end;
  end;
  if (RepSpec.flags[5]) then begin
    //AddExtraCostRow(ARb,BCb,VIp,"pucost5",BPUr.Cost5,BPUr.InclVAT,VIp.ExportFlag,BPUr.ExportFlag,BPUr.CurncyCode,VATr,vatcnt);
		if(BPUr.ApprovedCost5) then begin
			VIrw.AccNumber = ARb.PUCost5;
			if (GetAccName(VIrw.AccNumber,tstr,60)==false) then begin end;	
			VIrw.Comment = tstr;
			VIrw.Sum = BPUr.Cost5;
				if(Blank(VIp.ExtraCostObj)) then begin
					VIp.ExtraCostObj = "cost5";
				end else begin
					VIp.ExtraCostObj = VIp.ExtraCostObj & "," & "cost5";
				end;
				if(!SetInSet(obj,VIp.Objects)) then begin
					if(blank(VIp.Objects)) then begin
						VIp.Objects = obj;
					end else begin
						VIp.Objects = VIp.Objects & "," & obj;
					end;
				end;	
			createVi = true;
			MatRowPut(VIp,MatRowCnt(VIp),VIrw);
		end else begin
			allCreated = false;
			label = UserDefined("AccBlock","PUCost5");
			if(blank(incorrectObj)) then begin
				incorrectObj = label;
			end else begin
				incorrectObj = incorrectObj & ", " & label;
			end;
		end;
  end;
	if(!allCreated) then begin
		messagebox(0,"Для создания доп. затрат: " & incorrectObj & " подтвердите соответсвующие затраты" );
	end;
	VIp.BigPUNr = BPUr.SerNr;
	VIp.TransDate = BPUr.TransDate;
	VIp.CurncyCode = "AZN";
	VIp.FrRate = blankval;
	VIP.ToRateB1 = blankval;
  VICalcVals(VIp);
  VISumup(VIp,t);
  VIp.PayVal = -t;
  VIp.PayVal = Round(VIp.PayVal,DefaultRoundMode);
  VICalcEReb(VIp);
  if (VITb.autoVATflag!=0) then begin
    if (nonblank(VITb.autoVATVal)) then begin
      if ((VIp.ExportFlag==0) or (VIp.ExportFlag==3) or (VIp.ExportFlag==4)) then begin
        MulM4ProcVal(StringToVal(VITb.autoVATVal,M4Rate),VIp.PayVal,t);
        RoundVATSum(VIp.CurncyCode,VIp.PayDeal,"VIVc",t);      
        VIp.VATVal = t;
      end;
    end;
  end;
	VIp.SerNr = NextSerNr("VIVc",VIp.TransDate,newnr,false,"");
	if(createVi) then begin
		RecordStore(VIp,false);
		Createrecordlink(BPUr,CurrentCompany,VIp,CurrentCompany);
		Createrecordlink(VIp,CurrentCompany,BPUr,CurrentCompany);
	end;	
	LPastebigPUInVI:;
	return;
end;

global
procedure VIFromBigPUVClassReportDefaults(Integer wn)
BEGIN
  record RcVc RepSpec;
  
  DeselectWindow(wn,false);
  GetWindowRecord(wn,RepSpec);
  ReportDefaults(RepSpec,"VIFromBigPUVClass");  
  PutWindowRecord(wn,RepSpec);
  SelectWindow(wn);
  RETURN;
END;

global
updating function Boolean VIFromBigPUVClassOnOKWindow(Integer wn)
BEGIN
  record RcVc RepSpec;
  record VIVc VIr;
  Integer nwn;
  Integer r;
  logtext(0,"begin");
  GetWindowRecord(wn,RepSpec);
  if (blank(RepSpec.f1)) then begin
    //if (RepSpec.flags[0]==0) then begin
//      if ((RepSpec.flags[1]!=0) or (RepSpec.flags[2]!=0) or (RepSpec.flags[3]!=0) or (RepSpec.flags[4]!=0) or (RepSpec.flags[5]!=0) or (RepSpec.flags[6]!=0) or (RepSpec.flags[7]!=0)) then begin
      if ((RepSpec.flags[6]!=0) or (RepSpec.flags[7]!=0)) then begin
        MessageBox(0,USetStr(10426));
        WindowFieldGoto(wn,RepSpec,-1,"f1",true);        
        goto LVIFromBigPUVClassOnOKWindow;
      end;
    //end;
  end;
	RecordNew(VIr);
  CreateVIFromBigPU(RepSpec.FirstVer,RepSpec,VIr);
  CloseWindow(wn);
LVIFromBigPUVClassOnOKWindow:;  
  VIFromBigPUVClassOnOKWindow = false;
  RETURN;
END;

global
updating procedure VIFromBigPUDExecute(LongInt BigPUNr)
begin
  Integer nwn;
  record RcVc RepSpec;
  record POSettingBlock POSb;
  record VIVc VIr;
  Integer r;
  if (UserCanAction("POToVI",true)) then begin
    BlockLoad(POSb);
    ReportDefaults(RepSpec,"VIFromBigPUVClass");
    RepSpec.repname = "";
    RepSpec.FirstVer = BigPUNr;
    if (POSb.OpenCreateVIFromPO!=0) then begin
      nwn = OpenWindow("VIFromBigPUVClass",1,0,"","",RepSpec);
      PutWindowRecord(nwn,RepSpec);
      SelectWindow(nwn);
    end else begin
      //RepSpec.flags[0] = 1;
      RepSpec.flags[1] = 1;
      RepSpec.flags[2] = 1;
      RepSpec.flags[3] = 1;
      RepSpec.flags[4] = 1;
      RepSpec.flags[5] = 1;
      RepSpec.flags[6] = 1;
      RepSpec.flags[7] = 1;
      CreateVIFromBigPU(RepSpec.FirstVer,RepSpec,VIr);
    end;
  end else begin
    MessageBox(1274,StringFromStringSet(3,"POToVI"));
  end;
  return;
end;

global
updating procedure VIFromBigPUDsm()
begin
  Integer wn;
  record BigPUVc BPUr;

  wn = CurWindow;
  if (WindowState(wn)==Rs_normal) then begin
    GetWindowRecord(wn,BPUr);
		VIFromBigPUDExecute(BPUr.SerNr);
  end else begin
    Beep;
  end;
  RETURN;
END;






global updating procedure CreateNoterToDelBigPUDsm() // _-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_- Anton Preisinger 9:19 10.11.2020
begin
	integer wn,i,mtrw,rwcnt,j;
	record BigPUVc BPUr;
	record NotepadVc Noter,newNoter;
	integer notenr;
	record SerBalVc SBr;
	string 100 tstr;
	boolean serialfoundf,TrHs,testf;
  record RLinkVc RLr;
  boolean notercreate,skip;
	
	wn = curwindow;
	getwindowrecord(wn,BPUr);
	logtext(0,"Error store note");
	recordnew(newNoter);
	newNoter.SerNr = NextSerNr("NotepadVc",CurrentDate,-1,false,"");
	newNoter.Classification = "DEL";
	if (RecordStore(newNoter,false)) then begin
		CreateRecordLink(BPUr,CurrentCompany,newNoter,CurrentCompany); 
		CreateRecordLink(newNoter,CurrentCompany,BPUr,CurrentCompany);   
		notenr = 1;
		while (ReadRecordLink(BPUr,notenr,newNoter,RLr)) begin
			notenr = notenr + 1;
		end;
		if (ReadRecordLink(BPUr,notenr-1,newNoter,RLr)) then begin
			RLr.Comment = "Delete List";
			if (RecordStore(RLr,true)) then begin  end;
		end;
		OpenWindow("NotepadDClass",1,wn,"","",newNoter);
	end else begin
		messagebox(0,"Error store note");
	end;

return;
end;







global updating procedure DeleteItemsFromBigPUDsm() //EDIT_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-Anton 10:25 05.07.2018
begin
	integer wn,i,mtrw,rwcnt,j;
	record BigPUVc PUr;
	row BigPUVc PUrw;
	record NotepadVc Noter,newNoter;
	integer notenr, pos;
	record SerBalVc SBr;
	string 100 tstr,qtstr,ponrstr;
	boolean serialfoundf,TrHs,testf;
  record RLinkVc RLr;
  boolean notercreate,skip;
  vector boolean vartcode;
	vector Integer vquant;
	vector string 255 vponr;
	
	recordnew(newNoter);
	
	notercreate = false;
	
	wn = curwindow;
	if(windowstate(wn)==0)then begin
		getwindowrecord(wn,PUr);
		if(PUr.OKFlag==0)then begin
			mtrw = matrowcnt(PUr);
			notenr = 1;
			while (ReadRecordLink(PUr,notenr,Noter,RLr)) begin
				if ("DEL"==Noter.Classification) then begin
					rwcnt = LineTextCnt(Noter);
					for (i=0;i<rwcnt;i=i+1) begin
						pos = 0;
						ExtractObjWithSeparator(Chr(9),LineTextGet(Noter,i),true,pos,tstr);
						ExtractObjWithSeparator(Chr(9),LineTextGet(Noter,i),true,pos,qtstr);
						ExtractObjWithSeparator(Chr(9),LineTextGet(Noter,i),true,pos,ponrstr);
						if(nonblank(tstr))then begin
							vartcode[tstr] = true;
							vquant[tstr] = StringToInt(qtstr);
							vponr[tstr] = StringToLongInt(ponrstr);
						end;
					end;  
				end;
				notenr = notenr + 1;
			end;
	
			For(i=0;i<mtrw;i=i+1) begin
				matrowget(PUr,i,PUrw);
				if(vquant[PUrw.ArtCode]==PUrw.Quant and vponr[PUrw.ArtCode]==PUrw.FromOrdNr)then begin
					if(vartcode[PUrw.ArtCode]==true)then begin
						matrowdelete(PUr,i);
						i=i-1;
						mtrw = mtrw - 1;
					end;
				end else begin
					if(vquant[PUrw.ArtCode]>0 and vponr[PUrw.ArtCode]==PUrw.FromOrdNr)then begin
						PUrw.Sum = PUrw.Sum / PUrw.Quant;
						PUrw.Quant = PUrw.Quant - vquant[PUrw.ArtCode];
						PUrw.Sum = PUrw.Sum * PUrw.Quant;
						matrowput(PUr,i,PUrw);
					end;
				end;
				if(vquant[PUrw.VEItemCode]==PUrw.Quant and vponr[PUrw.VEItemCode]==PUrw.FromOrdNr)then begin
					if(vartcode[PUrw.VEItemCode]==true)then begin
						matrowdelete(PUr,i);
						i=i-1;
						mtrw = mtrw - 1;
					end;
				end else begin
					if(vquant[PUrw.VEItemCode]>0 and vponr[PUrw.VEItemCode]==PUrw.FromOrdNr)then begin
						PUrw.Sum = PUrw.Sum / PUrw.Quant;
						PUrw.Quant = PUrw.Quant - vquant[PUrw.VEItemCode];
						PUrw.Sum = PUrw.Sum * PUrw.Quant;
						matrowput(PUr,i,PUrw);
					end;
				end;
			end; 
			putwindowrecord(wn,PUr);
			BigPUSumUp(PUr);
			putwindowrecord(wn,PUr);
			MessageBox(0,"Были удалены все строки согласно списка, для отмены действия нажмите кнопку \"Отмена\" в окне поступления");
		end else begin
			messagebox(0,"Запись должна быть разокеена");
		end;
	end else begin
		messagebox(0,"Сначала сохраните запись");
	end;
	
return;
end;









global updating procedure SaveItemsFromBigPUDsm()//EDIT_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-Anton 10:25 05.07.2018
begin
	integer wn,i,mtrw,rwcnt,j;
	record BigPUVc PUr;
	row BigPUVc PUrw;
	record NotepadVc Noter,newNoter;
	integer notenr, pos;
	record SerBalVc SBr;
	string 100 tstr,qtstr,ponr;
	boolean serialfoundf,TrHs,testf;
  record RLinkVc RLr;
  boolean notercreate,skip;
  vector boolean vartcode;
	vector Integer vquant;
	vector string 255 vponr;
	
	recordnew(newNoter);
	
	notercreate = false;
	
	wn = curwindow;
	if(windowstate(wn)==0)then begin
		getwindowrecord(wn,PUr);
		if(PUr.OKFlag==0)then begin
			mtrw = matrowcnt(PUr);
			notenr = 1;
			while (ReadRecordLink(PUr,notenr,Noter,RLr)) begin
				if ("DEL"==Noter.Classification) then begin
			
					rwcnt = LineTextCnt(Noter);
					for (i=0;i<rwcnt;i=i+1) begin
						pos = 0;
						ExtractObjWithSeparator(Chr(9),LineTextGet(Noter,i),true,pos,tstr);
						ExtractObjWithSeparator(Chr(9),LineTextGet(Noter,i),true,pos,qtstr);
						ExtractObjWithSeparator(Chr(9),LineTextGet(Noter,i),true,pos,ponr);
						if(nonblank(tstr))then begin
							vartcode[tstr] = true;
							vquant[tstr] = StringToInt(qtstr);
							vponr[tstr] = StringToLongInt(ponr);
						end;
					end;  
				end;
				notenr = notenr + 1;
			end;
			For(i=0;i<mtrw;i=i+1) begin
				matrowget(PUr,i,PUrw);

				if(vartcode[PUrw.ArtCode]==true and vponr[PUrw.ArtCode]==PUrw.FromOrdNr)then begin
					if(vquant[PUrw.ArtCode]!=PUrw.Quant and nonblank(vquant[PUrw.ArtCode]) and vquant[PUrw.ArtCode]!=0)then begin
						PUrw.Sum = PUrw.Sum / PUrw.Quant;
						PUrw.Quant = vquant[PUrw.ArtCode];
						PUrw.Sum = PUrw.Sum * PUrw.Quant;
						matrowput(PUr,i,PUrw);
					end;
				end;
				if(vartcode[PUrw.VEItemCode]==true and vponr[PUrw.ArtCode]==PUrw.FromOrdNr)then begin
					if(vquant[PUrw.VEItemCode]!=PUrw.Quant and nonblank(vquant[PUrw.VEItemCode]) and vquant[PUrw.VEItemCode]!=0)then begin
						PUrw.Sum = PUrw.Sum / PUrw.Quant;
						PUrw.Quant = vquant[PUrw.VEItemCode];
						PUrw.Sum = PUrw.Sum * PUrw.Quant;
						matrowput(PUr,i,PUrw);
					end;
				end;
				if(vartcode[PUrw.VEItemCode]!=true and vartcode[PUrw.ArtCode]!=true)then begin
					matrowdelete(PUr,i);
					i=i-1;
					mtrw = mtrw - 1;
				end else begin
					if (vponr[PUrw.ArtCode]!=PUrw.FromOrdNr and vponr[PUrw.VEItemCode]!=PUrw.FromOrdNr) then begin
						matrowdelete(PUr,i);
						i=i-1;
						mtrw = mtrw - 1;
					end;
				end;
			end; 
			putwindowrecord(wn,PUr);
			BigPUSumUp(PUr);
			putwindowrecord(wn,PUr);
			MessageBox(0,"Были сохранены все строки согласно списка, для отмены действия нажмите кнопку \"Отмена\" в окне поступления");
		end else begin
			messagebox(0,"Запись должна быть разокеена");
		end;
	end else begin
		messagebox(0,"Сначала сохраните запись");
	end;
	
return;
end;





global
updating function LongInt PastePUInVI(record PUVc PUp,var record VIVc VIp,var string errmsg,
                                      Boolean customsf,Boolean freightf,Boolean cost1f,Boolean cost2f,
                                      Boolean cost3f,Boolean cost4f,Boolean cost5f,string pricelist) //Edit***************************Sasha2,17:13 18.03.2016
begin
  LongInt res;
  Integer i,rwcnt,vatcnt;
  row VIVc VIrw;
  row PUVc PUrw;  
  Integer nrwcnt,virow;
  record INVc INr;
  val net,sum,t,q;
  record CUVc VEr;
  record APAccBlock APb;
  record AccBlock ARb;
  record CostAccBlock CAb;
  record BaseCurBlock BCb;
  record VITBlock VITb;
  val from,to1,to2,base1,base2;
  string 255 tstr,viitgroup;
  val purowsum,puqinvd,puqord,powopuqtyinvd;
  record POVc POr;
  record POVc rPOr;
  record POVc oldPOr;
  row POVc POrw;
  Boolean vifound;
  record TaxMatrixVc TMr;
  record SMVc VATr;
  record CYBlock CYb;
		
  res = 0;
  BlockLoad(BCb);
  BlockLoad(ARb);
  BlockLoad(APb);
  BlockLoad(VITb);
  BlockLoad(CYb);
  BlockLoad(CAb);  
  VEr.Code = PUp.VECode;
  if (ReadFirstMain(VEr,1,true)==false) then begin 
    res = 1434;
    goto LPastePUInVI; 
  end;

  if (PUp.PONr>0) then begin
    POr.SerNr = PUp.PONr;
    if (ReadFirstMain(POr,1,true)==false) then begin 
      res = 1434;
      goto LPastePUInVI; 
    end else begin
      //res = ValidatePORecord(POr,oldPOr,Rs_insert,10,false,errmsg); //Commentet because after this procedure was updated IN 
// why to we need to validate PO when making PI from GR ? 
// 
      /*res = 0;
      if (res!=0) then begin
        goto LPastePUInVI; 
      end;*/
    end;
  end;
  GetAPAcc(VEr.Code,tstr);
  VIp.APAcc = tstr;
  VIp.POCQStatNr = -1;
  VIp.POSerNr = PUp.PONr;
  VIp.TransDate = PUp.TransDate;
  VIp.InvDate = PUp.TransDate;  
  VIp.VECode = PUp.VECode;
  VIp.VECode = PUp.VECode;
  if (PUp.PONr>0) then begin
    if (nonblank(POr.InvoiceToCode)) then begin
      VIp.OrgVE = POr.VECode;
      VIp.VECode = POr.InvoiceToCode;
    end;
  end;
//  VIp.VEName = PUp.VEName;
  VIVc_PasteVECode(VIp,0,true,false,tstr);
  while (MatRowCnt(VIp)>0) begin
    MatRowDelete(VIp,0);
  end;
  
  if (pricelist!="FOB36" and pricelist!="FOBR") then begin //Edit***************************Sasha2,17:08 18.03.2016
    VIp.CurncyCode = PUp.CurncyCode;
    VIp.FrRate = PUp.FrRate;
    VIp.ToRateB1 = PUp.ToRateB1;
    VIp.ToRateB2 = PUp.ToRateB2;
    VIp.BaseRate1 = PUp.BaseRate1;
    VIp.BaseRate2 = PUp.BaseRate2;
  
    VIp.VATFrRate = PUp.FrRate;
    VIp.VATToRateB1 = PUp.ToRateB1;
    VIp.VATToRateB2 = PUp.ToRateB2;
    VIp.VATBaseRate1 = PUp.BaseRate1;
    VIp.VATBaseRate2 = PUp.BaseRate2;
  end; //Edit***************************Sasha2,17:08 18.03.2016
  
  if(BCb.BaseCur1==VIp.CurncyCode)then begin// Edit ************************** BPI Ukraine - KramarAlexandr - Tuesday, 3 April 2018 11:56:21
  	VIp.FrRate = blankval;
    VIp.ToRateB1 = blankval;
    VIp.ToRateB2 = blankval;
    VIp.BaseRate1 = blankval;
    VIp.BaseRate2 = blankval;
  end;
  
  //VIp.CurncyCode = PUp.CurncyCode;// Edit ************************** BPI Ukraine - KramarAlexandr - Thursday, 4 January 2018 18:00:13
  VIp.LangCode = VEr.LangCode;
//  VIp.PRCode = VEr.VEInvoiceToCode;
  VIp.VATNr = VEr.VATNr;
  VIp.POCQStatNr = -1;
  VIp.PayDeal = "";
  VIp.BranchID = PUp.BranchID;
  if (blank(VIp.BranchID)) then begin
    VIp.BranchID = POr.BranchID;
  end;

  VIp.NoTAXonVAT = PUp.NoTAXonVAT;
  if ((APb.UpdBaseRate!=0) or (APb.UpdForeginRate!=0)) then begin
    GetFullCurncyRate(VIp.CurncyCode,VIp.TransDate,from,to1,to2,base1,base2);
    if (APb.UpdBaseRate!=0) then begin
      VIp.BaseRate1 = base1;
      VIp.BaseRate2 = base2;
    end;
    if (APb.UpdForeginRate!=0) then begin
      VIp.FrRate = from;
      VIp.ToRateB1 = to1;
      VIp.ToRateB2 = to2;
    end;
  end;
  VIp.PayDeal = POr.PayDeal;
  if (blank(VIp.PayDeal)) then begin 
    VIp.PayDeal = VEr.VEPayDeal;
  end;
  VIp.ExportFlag = VEr.ExportFlag;
  if (APb.APUseObj!=0) then begin
    VIp.Objects = PUp.Objects;
    if (blank(VIp.Objects)) then begin
      VIp.Objects = VEr.VEObjects;
    end;
  end;
  VIp.POCOSerNr = PUp.POCOSerNr;
  rwcnt = MatRowCnt(PUp);
  nrwcnt = 0;
  ClearRow(VIp,VIrw,1);
  for (i=0;i<rwcnt;i=i+1) begin  
    MatRowGet(PUp,i,PUrw);
    ClearRow(VIp,VIrw,1);
    POQtyOrdered(PUp.PONr,PUrw.PONr,PUrw.OrdRow,puqord);
    vifound = POQtyInvoiced(PUp.SerNr,i,PUp.PONr,puqinvd,powopuqtyinvd);
    if (vifound) then begin
      q = PUrw.Quant - puqinvd;
    end else begin
      if (VITb.VIBasedOnPU==0) then begin
        vifound = POQtyInvoiced(PUp.PONr,PUrw.PONr,PUrw.OrdRow,puqinvd,powopuqtyinvd);
        if (((PUrw.PONr>0) or (PUp.PONr>0)) and (PUrw.OrdRow>=0)) then begin
          q = puqord - puqinvd;
        end else begin
          q = PUrw.Quant - puqinvd;
        end;
      end else begin
        q = PUrw.Quant - puqinvd;
      end;
    end;
    if (PUrw.Quant>q) then begin
      PUrw.Quant = q;
    end;
    q = PUrw.Quant;
    VIrw.VATCode = PUrw.VATCode;
    if ((PUrw.PONr>0) and (PUrw.OrdRow>=0)) then begin
      VIrw.PONr = PUrw.PONr;
      VIrw.OrdRow = PUrw.OrdRow;
      if (vifound==false) and (VITb.VIBasedOnPU==0) then begin
        rPOr.SerNr = PUrw.PONr;
        if (ReadFirstMain(rPOr,1,true)) then begin 
          if (PUrw.OrdRow>=0) then begin
            MatRowGet(rPOr,PUrw.OrdRow,POrw);
            if (q>(POrw.Quant-POrw.Invd)) then begin
              q = POrw.Quant - POrw.Invd; //inst it done above ? 
            end;
          end;
        end;
      end;
      if (q>0) then begin 
        VIrw.Item = PUrw.ArtCode;
        VIrw.qty = q;
        VIrw.PUNr = PUp.SerNr;
        VIrw.PURow = i;
        VIrw.Objects = PUrw.Objects;
        VIrw.SerialNr = PUrw.SerialNr;
        if (PUrw.PONr>0) then begin
          VIrw.PRCode = rPOr.PRCode;
        end else begin
          VIrw.PRCode = POr.PRCode;
        end;
      end;
    end else begin
      if (vifound==false) and (VITb.VIBasedOnPU==0) then begin
        if (PUrw.OrdRow>=0) then begin
          MatRowGet(POr,PUrw.OrdRow,POrw);
          if (q>(POrw.Quant-POrw.Invd)) then begin
            q = POrw.Quant - POrw.Invd;
          end;
        end;
      end;
      if (q>0) then begin 
        VIrw.OrdRow = -2; // Row comes from Order, but is not connected to a specific row 
        if (VITb.TransferItems==2) or (PUrw.StockType==kStockTypeConsigment) then begin
          VIrw.Item = PUrw.ArtCode;
          VIrw.qty = q;
          VIrw.OrdRow = PUrw.OrdRow;
          VIrw.PUNr = PUp.SerNr;
          VIrw.PURow = i;
          VIrw.Objects = PUrw.Objects;
          VIrw.SerialNr = PUrw.SerialNr;//??
          if (PUrw.PONr>0) then begin
            VIrw.PRCode = rPOr.PRCode;
          end else begin
            VIrw.PRCode = POr.PRCode;
          end;
        end;
        if (PUrw.StockType!=kStockTypeConsigment) then begin
          if (VITb.TransferItems==1) then begin
            VIrw.OrdRow = PUrw.OrdRow;
            VIrw.Item = PUrw.ArtCode;
            if (PUrw.PONr>0) then begin
              VIrw.PRCode = rPOr.PRCode;
            end else begin
              VIrw.PRCode = POr.PRCode;
            end;
            VIrw.qty = q;
            
            purowsum = PUrw.Quant*PUrw.UPrice;
            if (PUrw.PONr>0) or (PUp.PONr>0) then begin
              purowsum = PUrw.Quant*PUrw.UPrice;
            end;
            sum = FindVAT(VIrw.VATCode,purowsum,PUp.InclVAT,PUp.NoTAXonVAT);
//TaxTemplateCode            
            if (PUp.InclVAT!=0) then begin
              sum = purowsum - sum;
            end else begin
              sum = purowsum;
            end;  

            virow = VIPRRowExists(VIp,VIrw.PRCode,VIrw.Item,VIrw.VATCode,sum,q);
            if (virow==-1) then begin
              if (nonblank(VIrw.AccNumber)) then begin
                VIrw.PUNr = PUp.SerNr;
              end;
            end else begin
              goto LSKIPROW;
            end;
          end;
          if (VITb.TransferItems==0) then begin
            VIrw.qty = q;
            purowsum = PUrw.Quant*PUrw.UPrice;
            if (PUrw.PONr>0) or (PUp.PONr>0) then begin
              purowsum = PUrw.Quant*PUrw.UPrice;
            end;
            sum = FindVAT(VIrw.VATCode,purowsum,PUp.InclVAT,PUp.NoTAXonVAT);
            if (PUp.InclVAT!=0) then begin
              sum = purowsum - sum;
            end else begin
              sum = purowsum;
            end;  
            GetPurchaseControlAcc(PUrw.CredAcc,CAb.ItemGroupAccounts,PUrw.ArtCode,ARb,VEr.AccCost,VIrw.AccNumber,PUp.VECode);
            GetAccName(VIrw.AccNumber,VIrw.Comment,60);
            virow = VIRowExists(CYb,VIp,VIrw.AccNumber,VIrw.VATCode,VIrw.TaxTemplateCode,sum,q);
            if (virow==-1) then begin
              if (nonblank(VIrw.AccNumber)) then begin 
              	VIrw.Objects = NormalizeSetString(VIrw.Objects);// Edit ************************** BPI Ukraine - KramarAlexandr - Tuesday, 3 April 2018 12:01:50
                MatRowPut(VIp,nrwcnt,VIrw);
                VIrw.PUNr = PUp.SerNr;
//                nrwcnt = nrwcnt + 1;
              end;
            end else begin
              goto LSKIPROW;
            end;
          end;
        end;
      end;      
    end;
//TaxTemplateCode    
    VIrw.StockType = PUrw.StockType;
    if (blank(VIrw.VATCode)) then begin
      VIrw.VATCode = VEr.VEVATCode;
      VIrw.TaxTemplateCode = VEr.VETaxTemplateCode;
    end;
    if (blank(VIrw.VATCode)) then begin
      GetItemVATCode(PUrw.ArtCode,VEr.ExportFlag,tstr,false);
      VIrw.VATCode = tstr;
    end;  
    GetPurchaseControlAcc(PUrw.CredAcc,CAb.ItemGroupAccounts,PUrw.ArtCode,ARb,VEr.AccCost,tstr,PUp.VECode);
    VIrw.AccNumber = tstr;
    if (GetAccName(VIrw.AccNumber,tstr,60)) then begin end;
    VIrw.Comment = tstr;    
    purowsum = PUrw.Quant*PUrw.UPrice;
    if (PUrw.PONr>0) or (PUp.PONr>0) then begin
      purowsum = PUrw.Quant*PUrw.UPrice;
    end;
    if (pricelist=="FOB36" or pricelist=="FOBR") then begin //Edit***************************Sasha2,17:08 18.03.2016 {
      purowsum =  PUrw.Quant*PUrw.CostPrice;
    end; //Edit***************************Sasha2,17:08 18.03.2016 }
    sum = FindVAT(VIrw.VATCode,purowsum,PUp.InclVAT,PUp.NoTAXonVAT);
    if (PUp.InclVAT!=0) then begin
      sum = purowsum - sum;
    end else begin
      sum = purowsum;
    end;  
    VIrw.Sum = Round(sum,DefaultRoundMode);
    net = net + VIrw.Sum;
    if (PUrw.PONr>0) then begin
      VIrw.PRCode = rPOr.PRCode;
    end else begin
      VIrw.PRCode = POr.PRCode;
    end;
    
    if (nonblank(VIrw.Item)) then begin
      if (blank(viitgroup)) then begin
        if (ReadFirstItem(VIrw.Item,INr,true,true)) then begin
          viitgroup = INr.Group;
        end;
      end;    
    end;
    //if (VIrw.Sum!=0) then begin// Edit ************************** Friday, 10 November 2017 11:09:42
      VIrw.TaxTemplateCode = PUrw.TaxTemplateCode;
      UnpackRowFieldMatrix(PUrw,"TaxMatrix",TMr);
      PackRowFieldMatrix(VIrw,"TaxMatrix",TMr);
      RowCalculateTaxMatrix_VIVc(VIp,nrwcnt,VIrw,0);
      
      VIrw.Objects = NormalizeSetString(VIrw.Objects);// Edit ************************** BPI Ukraine - KramarAlexandr - Tuesday, 3 April 2018 12:01:50
      
      MatRowPut(VIp,nrwcnt,VIrw);
      nrwcnt = nrwcnt + 1;         
    //end;
LSKIPROW:; 

 
  end; 
//  PUAddFreightRow(PUp,VIp,ARb,APb,BCb,nrwcnt);//setting for this is needed and customs, and PO do not add freight nor Customs to INvoice
  if (customsf) then begin
    AddExtraCostRow(ARb,BCb,VIp,"customs",PUp.CustomsCost,PUp.InclVAT,VIp.ExportFlag,PUp.ExportFlag,PUp.CurncyCode,VATr,vatcnt);
  end;
  if (freightf) then begin  
    AddExtraCostRow(ARb,BCb,VIp,"freight",PUp.ShipCost,PUp.InclVAT,VIp.ExportFlag,PUp.ExportFlag,PUp.CurncyCode,VATr,vatcnt);
  end;
  if (cost1f) then begin
    AddExtraCostRow(ARb,BCb,VIp,"pucost1",PUp.Cost1,PUp.InclVAT,VIp.ExportFlag,PUp.ExportFlag,PUp.CurncyCode,VATr,vatcnt);
  end;
  if (cost2f) then begin
    AddExtraCostRow(ARb,BCb,VIp,"pucost2",PUp.Cost2,PUp.InclVAT,VIp.ExportFlag,PUp.ExportFlag,PUp.CurncyCode,VATr,vatcnt);
  end;
  if (cost3f) then begin
    AddExtraCostRow(ARb,BCb,VIp,"pucost3",PUp.Cost3,PUp.InclVAT,VIp.ExportFlag,PUp.ExportFlag,PUp.CurncyCode,VATr,vatcnt);
  end;
  if (cost4f) then begin
    AddExtraCostRow(ARb,BCb,VIp,"pucost4",PUp.Cost4,PUp.InclVAT,VIp.ExportFlag,PUp.ExportFlag,PUp.CurncyCode,VATr,vatcnt);
  end;
  if (cost5f) then begin
    AddExtraCostRow(ARb,BCb,VIp,"pucost5",PUp.Cost5,PUp.InclVAT,VIp.ExportFlag,PUp.ExportFlag,PUp.CurncyCode,VATr,vatcnt);
  end;
  VICalcVals(VIp);
  VISumup(VIp,t);
  VIp.PayVal = -t;
  VIp.PayVal = Round(VIp.PayVal,DefaultRoundMode);
  VICalcEReb(VIp);
  if (VITb.autoVATflag!=0) then begin
    if (nonblank(VITb.autoVATVal)) then begin
      if ((VIp.ExportFlag==0) or (VIp.ExportFlag==3) or (VIp.ExportFlag==4)) then begin
        MulM4ProcVal(StringToVal(VITb.autoVATVal,M4Rate),VIp.PayVal,t);
        RoundVATSum(VIp.CurncyCode,VIp.PayDeal,"VIVc",t);      
        VIp.VATVal = t;
      end;
    end;
  end;
  if (nonblank(VEr.VEWarnText1)) then begin 
    MessageBox(0,VEr.VEWarnText1);
  end;
  
  AddPrepaymentPORows(VIp,PUp.PONr);	//Edit----------------------Dima  11.03.2015
    
LPastePUInVI:;
  PastePUInVI = res;
  RETURN;
END;

function string 255 ReadLastSerialNr(record PUVc PUp,string artcode,Integer currow)
begin
  string 255 res;
  row PUVc PUrw;
  Integer i;

  for (i=currow-1;i>=0;i=i-1) begin
    MatRowGet(PUp,i,PUrw);
    if (PUrw.ArtCode==artcode) then begin
      if (nonblank(PUrw.SerialNr)) then begin
        res = PUrw.SerialNr;
        goto LReadLastSerialNr;
      end;
    end;
  end;
LReadLastSerialNr:;  
  ReadLastSerialNr = res;
  return;
end;

global
procedure AutoFillPUSerNr(var record PUVc PUp)
begin
  Integer i,rwcnt;
  row PUVc PUrw;
  string 255 lastnr,lastitem;
  record INVc INr;
  record SerNrTrackBlock SNrb;
  Integer extrapad;
  Boolean testf;
  string 255 lastnrstart,lastnrend;
  val q;
  
  rwcnt = MatRowCnt(PUp);
  if (rwcnt==0) then begin goto LAutoFillPUSerNr; end;
  BlockLoad(SNrb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUp,i,PUrw);
    ReadFirstItem(PUrw.ArtCode,INr,true,true);
    if (INr.SerNrf==0) then begin
      goto L33AutoFillPUSerNr;
    end;
    if (blank(lastitem)) then begin
      lastitem = PUrw.ArtCode;
    end;
    if (blank(lastnr)) then begin
      if (blank(PUrw.SerialNr)) then begin
        ReadLastINSer(PUrw.ArtCode,lastnr);
      end else begin
        lastnr = PUrw.SerialNr;
        if (INr.SerNrf==1) then begin
          if (PUrw.Quant>1) then begin
            lastnrstart = FirstInRange(lastnr,60);
            lastnrend = LastInRange(lastnr,60);
            if (lastnr==lastnrend) then begin
              q = 1;
              while (q<PUrw.Quant) begin
                lastnr = NextSerialNumber(PUrw.ArtCode,lastnr,SNrb);
                q = q + 1;
              end;
            end else begin
              lastnr = lastnrend;
            end;
          end;
        end;
        goto L33AutoFillPUSerNr;
      end;
    end;
    if ((blank(PUrw.SerialNr)) and (PUrw.ArtCode==lastitem)) then begin
      if (INr.SerNrf==1) then begin
        testf = true;
        while (testf) begin
          lastnr = NextSerialNumber(PUrw.ArtCode,lastnr,SNrb);    
/*                 
          if (SerialNrEverinStock(PUrw.ArtCode,lastnr)==false) then begin
            PUrw.SerialNr = lastnr;
            testf = false;
          end;
*/          
          PUrw.SerialNr = lastnr;
          testf = false;
        end;
      end else begin
        lastnr = NextSerialNumber(PUrw.ArtCode,lastnr,SNrb);
        PUrw.SerialNr = lastnr;
      end;
    end else begin
      lastnr = PUrw.SerialNr;
      lastitem = PUrw.ArtCode;
      if (blank(lastnr)) then begin
        lastnr = ReadLastSerialNr(PUp,PUrw.ArtCode,i);
        if (blank(lastnr)) then begin
          ReadLastINSer(PUrw.ArtCode,lastnr);
        end;
      end else begin
        lastnr = PUrw.SerialNr;
        goto L33AutoFillPUSerNr;
      end;
      lastnr = NextSerialNumber(PUrw.ArtCode,lastnr,SNrb);      
      PUrw.SerialNr = lastnr;
    end;
    MatRowPut(PUp,i,PUrw);
L33AutoFillPUSerNr:;
  end;
LAutoFillPUSerNr:;
  return;
end;

global
procedure FindPUStockAcc(string vecode,record CostAccBlock CAb,string rowstockacc,string rowcontrolacc,string loccode,record INVc INr,Integer stocktype,var string stockacc,var string purchacc,Boolean findnewf)
begin
  record AccBlock ARb;
  string 255 tstr;
  record LocationVc Locr;
  record CUVc CUr;// Edit ************************** Tuesday, 22 August 2017 11:57:52

  BlockLoad(ARb);
  Locr.Code = loccode;
  if (ReadFirstMain(Locr,1,true)) then begin end;
  if (GetPUStockAcc(CAb.ItemGroupAccounts,rowstockacc,Locr.StockAcc,INr.Group,ARb,stocktype,stockacc,tstr,findnewf)==0) then begin end;  
  
  // Edit Start ---------------------------------------------- Edit Start
	//Thursday, 18 December 2014 16:33:05
	/*if(INr.ConsgType>0)then begin
		purchacc = INr.PurchAcc;
		stockacc = INr.PurchAcc;
	end else begin*/
	if(readfirstmain(CUr,1,true))then begin
		if(CUr.CustType==1)then begin
			purchacc = CUr.AccAP;
		end else begin
			if (GetPUPControlAcc(loccode,vecode,CAb.ItemGroupAccounts,rowcontrolacc,INr.Group,ARb,stocktype,purchacc,tstr,findnewf)==0) then begin end;
		end;
	end else begin
		if (GetPUPControlAcc(loccode,vecode,CAb.ItemGroupAccounts,rowcontrolacc,INr.Group,ARb,stocktype,purchacc,tstr,findnewf)==0) then begin end;
	end;
  //end;
  
	// Edit End ---------------------------------------------- Edit End
  
  return;
end;

global
function Boolean PUVc_PasteArtCode(var record PUVc PUr,Integer rownr,var string warning,var string inwarn)
BEGIN
  Boolean res;
  record CostAccBlock CAb;
  record PIVc PIr;
  record INVc INr;
  row PUVc PUrw;
  Boolean chsum,chrsum;
  string 60 sz,msk,mskrep,pcstr,tstr;
  val t,p,s,t2;
  record SysFormatBlock SFb;
  string 200 varsubset,location;
  Boolean infoundf;
  record RoundBlock Roundb;
  string 20 stockacc,purchacc;
  record LocationVc Locr;
  record MainStockBlock MSb;
  Boolean nomoreremotecalls,pifound;
  record TaxMatrixVc TMr;
  string 255 taxtemplatecode,vatcode,descstr;
  val price,reb;
	record BPIBrandVc BRNDr;
	record PosVc Posr;
  
  MatRowGet(PUr,rownr,PUrw); 
/*   
  infoundf = GetFirstItem(PUrw.ArtCode,INr);
  if (infoundf==false) then begin
    infoundf = ReadFirstItem(PUrw.ArtCode,INr,true,true);
    if (FindItemVAR(INr.Code,sz,msk,mskrep,varsubset)) then begin INr.Code = PUrw.ArtCode; end;
  end;
*/
  infoundf = GetItemPurchasePriceDiscount(PUr.VECode,PUr.Location,PUr.TransDate,PUr.CurncyCode,PUrw.ArtCode,PUrw.Quant,
                                   PUr.Location,"","","",0,true,
                                   PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,
                                   INr,PIr,pifound,price,descstr,reb,vatcode,purchacc,nomoreremotecalls,taxtemplatecode);
  if (infoundf) then begin
    BlockLoad(SFb);
    BlockLoad(CAb);    
    BlockLoad(Roundb);    
    BlockLoad(MSb);
    Locr.Code = PUr.Location;
    if (blank(Locr.Code)) then begin
      Locr.Code = MSb.MainStock;
    end;
    ReadFirstMain(Locr,1,true);

    if (nonblank(INr.WarnText1)) then begin
      inwarn = INr.WarnText1;
    end;
    if (INr.ItemType!=kItemTypeStocked) then begin
      warning = USetStr(1301);
    end;
    pcstr = "";
    if (GetFirstPurchaseItem(PUrw.ArtCode,PUr.Location,PUr.VECode,PIr)) then begin
      if (PIr.CurncyCode==PUr.CurncyCode) then begin
        PUrw.UPrice = PIr.PurPrice;
        p = PIr.PurPrice;
      end else begin
        CurValToOtherCur(PUr.TransDate,PIr.CurncyCode,PIr.PurPrice,PUr.CurncyCode,t,GetCostRoundMode(Roundb));
        PUrw.UPrice = t;  
        p = PUrw.UPrice;
      end;          
      PUrw.CountryOfOrg = PIr.OrgCountry;
      PUrw.CustomsCost = PIr.PurchaseCost;
      PUrw.VEItemCode = PIr.VEItemCode;
      PUrw.VEUnit = PIr.VEUnit;
      PUrw.CountryOfOrg = PIr.OrgCountry;
      if (INr.PriceFactor!=0) then begin
        p = p/INr.PriceFactor;
      end;
    end else begin
      PUrw.Spec = INr.Name;
      PUrw.UPrice = INr.InPrice;
      p = INr.InPrice;
      if (INr.PriceFactor!=0) then begin
        p = p/INr.PriceFactor;
      end;
      p = DivRateToBase1(PUr.CurncyCode,p,PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,GetCostRoundMode(Roundb));
    end; 
    PUrw.VATCode = PUr.VEVATCode;    
    if (blank(PUrw.VATCode)) then begin
      GetItemVATCode(PUrw.ArtCode,PUr.ExportFlag,tstr,false);
      PUrw.VATCode = tstr;
    end;
    PUrw.TaxTemplateCode = FillupTaxMatrix(1,PUr.BranchID,PUr.VECode,"","",taxtemplatecode,TMr);
    PUrw.Coefficient = INr.UnitCoefficient;
    PUrw.InPrice = INr.InPrice;
    PUrw.ArtCode = INr.Code;
    PUrw.Spec = INr.Name;
    PUrw.Objects = FindINObjects(INr.Objects,INr.Group);
    PUrw.UPrice = p;
    PUrw.UnitXval = INr.Width;
    PUrw.UnitYval = INr.Height;
    PUrw.UnitZval = INr.Depth;
    PUrw.UnitCode = INr.Unittext;
    location = PUrw.Location;
    if (blank(location)) then begin
      location = PUr.Location;
    end;
    if (Locr.RequirePos!=0) then begin
      PUrw.PosCode = Locr.WHMDefPUPosCode;
    end;

    t2 = MulRateToBase1(PUr.CurncyCode,p,PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,GetCostRoundMode(Roundb));
    PUCalcPerc(t2,PUrw.CustomsCost,t2);
    pcstr = ValToString(t2,M45Val,SFb.thousSep,SFb.decimalPt,0);
    PUrw.CustomsCost = pcstr;
    PUrw.BasePrice = INr.UPrice1;
    tstr = INr.ExtraCost;
    PUrw.Extra = tstr;
    PUrw.PIFactor = PIr.PIFactor;
    PUrw.StockType = PIr.DefStockType;
    if (PUrw.PIFactor!=0) then begin
      PUrw.UPrice = PUrw.UPrice/PUrw.PIFactor;
//      PUrw.BasePrice = PUrw.BasePrice/PUrw.PIFactor;
//BasePrice effected by Supplier Unit ? 
    end;
    DivPIFactor(PUrw.Quant,PUrw.PIFactor,t);
    PUrw.VEQuant = t;
    
    if (blank(PUrw.Location)) then begin
      FindPUStockAcc(PUr.VECode,CAb,PUrw.CostAcc,PUrw.CredAcc,PUr.Location,INr,PUrw.StockType,stockacc,purchacc,true);
    end else begin
      FindPUStockAcc(PUr.VECode,CAb,PUrw.CostAcc,PUrw.CredAcc,PUrw.Location,INr,PUrw.StockType,stockacc,purchacc,true);
    end;
    PUrw.CostAcc = stockacc;
    PUrw.CredAcc = purchacc;

    PUrw.SuppSerialNr = INr.SuppSerialNr;
    PUrw.MajStoneDet = INr.MajStoneDet;
    PUrw.Colour = INr.Colour;
    PUrw.Clarity = INr.Clarity;
    PUrw.Cert = INr.Cert;
    PUrw.MinStoneDet = INr.MinStoneDet;
    PUrw.Metal = INr.Metal;
    PUrw.RowWeight = INr.RowWeight;
    PUrw.Size = INr.Size;
    PUrw.Length = INr.Length;

    PUrw.WatchBrand = INr.WatchBrand;
    PUrw.StyleName = INr.StyleName;
    PUrw.WatchMetal = INr.WatchMetal;
    PUrw.Movement = INr.Movement;
    PUrw.BrcStr = INr.BrcStr;
    PUrw.Gender = INr.Gender;
    PUrw.Other = INr.Other;
    PUrw.Other2 = INr.Other2;

    PackRowFieldMatrix(PUrw,"TaxMatrix",TMr);
    MatRowPut(PUr,rownr,PUrw);
    chrsum = true;
    res = true;
  end else begin
    if (nonblank(PUrw.ArtCode)) then begin
      warning = USetStr(1120) & PUrw.ArtCode;
    end;
  end;
  if (chrsum) then begin
    PUCalcCostPrice(PUrw.ArtCode,PUrw.UPrice,PUr.InclVAT,PUr.NoTAXonVAT,PUrw.Extra,PUr.CurncyCode,
                    PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,
                    PUrw.ShipCost,PUrw.RowCost1,PUrw.RowCost2,PUrw.RowCost3,PUrw.RowCost4,PUrw.RowCost5,
                    PUrw.CustomsCost,p,PUrw.Quant,s,PUrw.VATCode,PUr.ExportFlag);
    PUrw.CostPrice = p;
    PUrw.Sum = s;
    chsum = true;
  end;
	if(currentCompany==18)then begin
		infoundf = GetFirstItem(PUrw.ArtCode,INr);
		if(infoundf)then begin
			PUrw.VIReconComment = INr.AlternativeCode;
			if(nonblank(INr.BPIBrand))then begin
				BRNDr.Code = INr.BPIBrand;
				if(ReadFirstMain(BRNDr,1,true))then begin
					PUrw.ToPosCode = BRNDr.CWHCode;
					PUrw.Location = BRNDr.CWHCode;
					Posr.Code = BRNDr.CWHCode;
					if (ReadFirstMain(Posr,1,true)) then begin
						PUrw.Location = Posr.Location;
					end;
				end;
			end;
		end;
	end;
	
  MatRowPut(PUr,rownr,PUrw);    
  if (chsum) then begin
    PUSumUp(PUr);
  end;
LPUVc_PasteArtCode:; 
  PUVc_PasteArtCode = res;
  RETURN;
END;
      
global
procedure PUVc_InclVATButtonAction(var record PUVc PUp)
BEGIN    
  row PUVc PUrw;
  val bas,s;
  Integer i,rwcnt;
  
  rwcnt = MatRowCnt(PUp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUp,i,PUrw);
    PUCalcCostPrice(PUrw.ArtCode,PUrw.UPrice,PUp.InclVAT,PUp.NoTAXonVAT,PUrw.Extra,PUp.CurncyCode,
                    PUp.FrRate,PUp.ToRateB1,PUp.ToRateB2,PUp.BaseRate1,PUp.BaseRate2,
                    PUrw.ShipCost,PUrw.RowCost1,PUrw.RowCost2,PUrw.RowCost3,PUrw.RowCost4,PUrw.RowCost5,
                    PUrw.CustomsCost,bas,PUrw.Quant,s,PUrw.VATCode,PUp.ExportFlag);
    PUrw.CostPrice = bas;
    PUrw.Sum = s;
    MatRowPut(PUp,i,PUrw);
  end;
  PUSumUp(PUp);
  RETURN;
END;
      
global
function Integer PUVc_PastePONr(var record PUVc PUp,Integer rownr)
BEGIN
  row PUVc PUrw;
  record POVc POr;
  Integer retval;
  
  MatRowGet(PUp,rownr,PUrw);
  if (PUrw.PONr>0) then begin
    retval = GetPO(PUrw.PONr,POr,PUp.VECode,false);
  end;
  PUVc_PastePONr = retval;
  RETURN;
END;

procedure AddToSkiposArray(string poscode,var Array string askippos,var Integer acnt)
BEGIN
  row PUVc PUrw;
  Integer i;
  
  if (blank(poscode)) then begin goto LAddToSkiposArray; end;
  for (i=0;i<acnt;i=i+1) begin
    if (askippos[i]==poscode) then begin
      goto LAddToSkiposArray;
    end;
  end;
  askippos[acnt] = poscode; 
  acnt = acnt + 1;
LAddToSkiposArray:;  
  RETURN;
END;

procedure PrepareSkiposArray(record PUVc PUr,var Array string askippos,var Integer acnt)
BEGIN
  row PUVc PUrw;
  Integer i,rwcnt;
  
  rwcnt = MatRowCnt(PUr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUr,i,PUrw);
    AddToSkiposArray(PUrw.PosCode,askippos,acnt);
    AddToSkiposArray(PUrw.ToPosCode,askippos,acnt);
  end;
  RETURN;
END;

global
function Boolean IsQtyAllowed_QtyonPallet(val Quant,string artcode)
BEGIN
  Boolean res;
  record INVc INr;
  Boolean itemfound;
  
  res = true;
  itemfound = GetFirstItem(artcode,INr);
  if (itemfound==false) then begin
    itemfound = ReadFirstItem(artcode,INr,true,false);
  end;
  if ((itemfound) and (INr.QtyonPallet>0)) then begin
    if ((Quant/INr.QtyonPallet)>78) then begin
      res = false;
    end;
  end;
  IsQtyAllowed_QtyonPallet = res;
  RETURN;
END;

global
function Integer PUVc_PasteQuant(var record PUVc PUr,Integer rownr)
BEGIN
  Integer res,i;
  row PUVc PUrw,orgPUrw;
  row PUVc palletPUrw;
  val p,s;
  Boolean chsum,testf,itemfoundf;
  record MainStockBlock MainStockRec;
  record INVc INr;
  val orgquant;
  string 255 tstr,tstr2;
  Integer lrownr;
  Array string 20 askippos;
  Integer acnt;
  record LocationVc LocRec;
  val qtyonpallet,defposhight;
  val fr,to1,to2,br1,br2;
  record SerNrTrackBlock SNrb;

  BlockLoad(SNrb);
  LocRec.Code = PUr.Location;
  if (blank(LocRec.Code)) then begin 
    BlockLoad(MainStockRec);
    LocRec.Code = MainStockRec.MainStock;
  end;
  ReadFirstMain(LocRec,1,true);
  switch (PUr.PUFromPORate) begin
    case kPURateFromPrepayment:
      if (PUr.PONr>0) then begin
        PUSumUp(PUr);
        if (CalculateOPPrepaymentAvgRate(PUr,PUr.PONr,PUr.TotUPrice,fr,to1,to2,br1,br2)) then begin
          PUr.FrRate = fr;
          PUr.ToRateB1 = to1; 
          PUr.ToRateB2 = to2;
          PUr.BaseRate1 = br1;
          PUr.BaseRate2 = br2;
        end;
      end;
  end;

  res = 0;      
  lrownr = rownr;
  MatRowGet(PUr,lrownr,PUrw);
  itemfoundf = ReadFirstItem(PUrw.ArtCode,INr,true,true);
  if (nonblank(PUrw.ArtCode)) and (INr.SerNrf==1) then begin
    if (BulkSerialNos_CalculateQuantityAndSerialNr(SNrb,false,PUrw.ArtCode,PUrw.SerialNr,PUrw.Quant)) then begin
      MatRowPut(PUr,lrownr,PUrw);
      MatRowGet(PUr,lrownr,PUrw);
    end;
  end;

  CopyRow(PUr,PUrw,orgPUrw);
  orgquant = orgPUrw.Quant;
LPUVc_PasteQuantAGAIN:;  
  if (LocRec.RequirePos!=0) then begin    
    PrepareSkiposArray(PUr,askippos,acnt);
    
    if (itemfoundf) then begin
      qtyonpallet = INr.QtyonPallet + (INr.QtyonPallet*20)/100;
      if (nonblank(INr.DefPalletItem)) then begin
        if (INr.QtyonPallet>0) then begin
          if ((PUrw.Quant/INr.QtyonPallet)>100) then begin 
            res = 1733;
            goto LPUVc_PasteQuant;
          end;
          if (PUrw.Quant>INr.QtyonPallet) then begin
            if (PUrw.Quant<=qtyonpallet) then begin
              if (PUrw.Quant>=qtyonpallet) then begin
                PUrw.Quant = qtyonpallet;
              end;
            end else begin
              PUrw.Quant = INr.QtyonPallet;
            end;
          end;
        end;
      end;
    end;
  end;
  DivPIFactor(PUrw.Quant,PUrw.PIFactor,p);
  PUrw.VEQuant = p;
  CalculatePURowSum(PUrw.Quant,PUrw.UPrice,PUrw.Extra,PUrw.CostPrice,PUrw.ShipCost,PUrw.RowCost1,PUrw.RowCost2,PUrw.RowCost3,PUrw.RowCost4,PUrw.RowCost5,
                    PUrw.CustomsCost,p,false,PUr.CurncyCode,PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2);

  PUrw.Sum = p;
  chsum = true;
  if (blank(PUrw.PosCode)) then begin 
    if (LocRec.RequirePos!=0) then begin
      PUrw.PosCode = LocRec.WHMDefPUPosCode; 
    end;
  end;
  if (LocRec.RequirePos!=0) then begin    
    if (blank(PUrw.ToPosCode)) then begin
      defposhight = INr.DefPosHeight;
      if (defposhight==0) then begin
        defposhight = INr.PalletHeight + 3; 
      end;
      //PUrw.ToPosCode = FindFreePositionInLocArea_ExcludePositionFromArray(LocRec.Code,INr.LocArea,defposhight,INr,LocRec.WHMHighestPosCodeFirst,askippos,acnt); // Edit ************************** BPI Ukraine - KramarAlexandr - Friday, 17 August 2018 14:52:42
    end;
  end;
  MatRowPut(PUr,lrownr,PUrw);    
  if (PUDchrsum(PUr,lrownr)) then begin
  end;
  if (LocRec.RequirePos!=0) then begin
    if (nonblank(INr.DefPalletItem)) then begin
      lrownr = lrownr + 1;
      ClearRow(PUr,palletPUrw,1);
      palletPUrw.PosCode = PUrw.PosCode;
      palletPUrw.ToPosCode = PUrw.ToPosCode;
      palletPUrw.ArtCode = INr.DefPalletItem;
      palletPUrw.Quant = 1;
      palletPUrw.MotherPURow = lrownr;
      MatRowInsert(PUr,lrownr,palletPUrw); 
      testf = PUVc_PasteArtCode(PUr,lrownr,tstr,tstr2);       
    end;
    lrownr = lrownr + 1;
    orgquant = orgquant - PUrw.Quant;
    if (orgquant>0) then begin
      CopyRow(PUr,orgPUrw,PUrw);
      PUrw.Quant = orgquant;
      goto LPUVc_PasteQuantAGAIN;
    end;
  end;    
LPUVc_PasteQuant:; 
//  PUSetShipCost(PUr,2);// why RowCost1 works difrent than and other RowCost and difrnet than on PO ? 
  PURecalcCost(PUr);
  PUSumUp(PUr);
  PUVc_PasteQuant = res;
  RETURN;
END;

global
procedure RefillPURows(var record PUVc PUp)
BEGIN
  Integer rwcnt,i;
  Integer oldrwcnt;
  row PUVc PUrw;
  row PUVc newPUrw;
  record INVc INr;
  record MainStockBlock MSb;
  val remn,pv,sv;
  Integer nrwcnt;
  Boolean firstf;
  
  BlockLoad(MSb);
  rwcnt = MatRowCnt(PUp);
  for (i=0;i<rwcnt;i=i+1) begin
    oldrwcnt = MatRowCnt(PUp);
    MatRowGet(PUp,i,PUrw);
    if (ReadFirstItem(PUrw.ArtCode,INr,true,true)) then begin
      if (nonblank(INr.DefPalletItem)) then begin        
        if (INr.QtyonPallet>0) then begin
          if ((PUrw.Quant/INr.QtyonPallet)>100) then begin
            MessageBox(1733,"");
          end else begin    
            if (PUVc_PasteQuant(PUp,i)==0) then begin end;
            rwcnt = MatRowCnt(PUp);
            i = i + (rwcnt - oldrwcnt);
          end;
        end;
      end;
    end;
  end;

  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUp,i,PUrw);
    if ((MSb.NoSerOnPU==0) and (PUrw.Quant>1)) then begin
      if (ReadFirstItem(PUrw.ArtCode,INr,true,true)) then begin
        if (INr.SerNrf==1) then begin
          firstf = true;
          nrwcnt = i;
          remn = PUrw.Quant;
          while (remn>0) begin
            if (rwcnt>=200) then begin
              goto LRefillPURows;
            end;
            CopyRow(PUp,PUrw,newPUrw);
            
            newPUrw.Quant = 1;
            remn = remn - 1;
            if (CharacterMatch(newPUrw.CustomsCost,"%",len(newPUrw.CustomsCost))==false) then begin
              newPUrw.CustomsCost = StringToVal(newPUrw.CustomsCost,M4Val)/PUrw.Quant;
            end;
            if (CharacterMatch(newPUrw.ShipCost,"%",len(newPUrw.ShipCost))==false) then begin
              newPUrw.ShipCost = StringToVal(newPUrw.CustomsCost,M4Val)/PUrw.Quant;
            end;
            newPUrw.RowCost1 = newPUrw.RowCost1/PUrw.Quant;
            newPUrw.RowCost2 = newPUrw.RowCost2/PUrw.Quant;
            newPUrw.RowCost3 = newPUrw.RowCost3/PUrw.Quant;
            newPUrw.RowCost4 = newPUrw.RowCost4/PUrw.Quant;
            newPUrw.RowCost5 = newPUrw.RowCost5/PUrw.Quant;            

            PUCalcCostPrice(PUrw.ArtCode,newPUrw.UPrice,PUp.InclVAT,PUp.NoTAXonVAT,newPUrw.Extra,PUp.CurncyCode,
                            PUp.FrRate,PUp.ToRateB1,PUp.ToRateB2,PUp.BaseRate1,PUp.BaseRate2,
                            newPUrw.ShipCost,newPUrw.RowCost1,newPUrw.RowCost2,newPUrw.RowCost3,newPUrw.RowCost4,newPUrw.RowCost5,
                            newPUrw.CustomsCost,pv,newPUrw.Quant,sv,newPUrw.VATCode,PUp.ExportFlag);
            newPUrw.CostPrice = pv;                                        
            newPUrw.Sum = sv;          
            if (firstf) then begin
              MatRowPut(PUp,nrwcnt,newPUrw);
              firstf = false;
            end else begin
              MatRowInsert(PUp,nrwcnt,newPUrw);
            end;
            nrwcnt = nrwcnt + 1;
          end;
          rwcnt = MatRowCnt(PUp);
          i = nrwcnt;
        end;
      end;
    end;
  end;
LRefillPURows:;  
  PUSumUp(PUp);
  RETURN;
END;

global
procedure PUDClassOnOpenWindowRemote(var record PUVc PUr,var Integer AcceptanceStatusFlag)
begin
  record AcceptanceRulesVc Acptr;
  record ActVc Actr;
  
  if (HasApprovals) then begin
    AcceptanceStatusFlag = PUApprovalStatus(PUr,Acptr);
  end;
  return;
end;